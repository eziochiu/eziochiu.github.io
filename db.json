{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/NexT2/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/NexT2/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/NexT2/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/NexT2/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/NexT2/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/NexT2/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/NexT2/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/NexT2/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/NexT2/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/NexT2/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/NexT2/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/NexT2/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/NexT2/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/NexT2/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/NexT2/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/NexT2/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/NexT2/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/NexT2/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/NexT2/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/algolia-instant-search/LICENSE","path":"lib/algolia-instant-search/LICENSE","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/algolia-instant-search/README.md","path":"lib/algolia-instant-search/README.md","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/canvas-nest/LICENSE","path":"lib/canvas-nest/LICENSE","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/canvas-nest/README.md","path":"lib/canvas-nest/README.md","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/fancybox/LICENSE","path":"lib/fancybox/LICENSE","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/fancybox/README.md","path":"lib/fancybox/README.md","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/reading_progress/LICENSE","path":"lib/reading_progress/LICENSE","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/reading_progress/package.json","path":"lib/reading_progress/package.json","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/reading_progress/README.md","path":"lib/reading_progress/README.md","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/reading_progress/reading_progress.js","path":"lib/reading_progress/reading_progress.js","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/reading_progress/reading_progress.min.js","path":"lib/reading_progress/reading_progress.min.js","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/three/LICENSE","path":"lib/three/LICENSE","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/three/README.md","path":"lib/three/README.md","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/three/gulpfile.js","path":"lib/three/gulpfile.js","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/three/package.json","path":"lib/three/package.json","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/three/yarn.lock","path":"lib/three/yarn.lock","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/NexT2/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/NexT2/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/NexT2/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/NexT2/source/js/src/clipboard.min.js","path":"js/src/clipboard.min.js","modified":1,"renderable":1},{"_id":"themes/NexT2/source/js/src/copy_code.js","path":"js/src/copy_code.js","modified":1,"renderable":1},{"_id":"themes/NexT2/source/js/src/custom.js","path":"js/src/custom.js","modified":1,"renderable":1},{"_id":"themes/NexT2/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/NexT2/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/NexT2/source/js/src/love.js","path":"js/src/love.js","modified":1,"renderable":1},{"_id":"themes/NexT2/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/NexT2/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/NexT2/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/NexT2/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/NexT2/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/fancybox/source/jquery.fancybox.min.css","path":"lib/fancybox/source/jquery.fancybox.min.css","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/fancybox/source/jquery.fancybox.min.js","path":"lib/fancybox/source/jquery.fancybox.min.js","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/three/lib/CanvasRenderer.js","path":"lib/three/lib/CanvasRenderer.js","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/three/lib/Projector.js","path":"lib/three/lib/Projector.js","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/three/src/canvas_lines.js","path":"lib/three/src/canvas_lines.js","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/three/src/canvas_sphere.js","path":"lib/three/src/canvas_sphere.js","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/three/src/three-waves.js","path":"lib/three/src/three-waves.js","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/NexT2/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/NexT2/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/robots.txt","path":"robots.txt","modified":1,"renderable":0},{"_id":"source/images/about_me.jpg","path":"images/about_me.jpg","modified":1,"renderable":0},{"_id":"source/images/background_cell.png","path":"images/background_cell.png","modified":1,"renderable":0},{"_id":"source/images/head.png","path":"images/head.png","modified":1,"renderable":0},{"_id":"source/images/alipay.png","path":"images/alipay.png","modified":1,"renderable":0},{"_id":"source/images/head_1.png","path":"images/head_1.png","modified":1,"renderable":0},{"_id":"source/images/pages_tag.png","path":"images/pages_tag.png","modified":1,"renderable":0},{"_id":"source/images/stringFromArray.png","path":"images/stringFromArray.png","modified":1,"renderable":0},{"_id":"source/images/tect_banner.jpg","path":"images/tect_banner.jpg","modified":1,"renderable":0},{"_id":"source/images/wechat.jpg","path":"images/wechat.jpg","modified":1,"renderable":0},{"_id":"source/images/wechatpay.png","path":"images/wechatpay.png","modified":1,"renderable":0},{"_id":"source/images/background/2.jpg","path":"images/background/2.jpg","modified":1,"renderable":0},{"_id":"source/images/background/city.jpg","path":"images/background/city.jpg","modified":1,"renderable":0},{"_id":"source/images/jenkins/inject-environment-varibles.png","path":"images/jenkins/inject-environment-varibles.png","modified":1,"renderable":0},{"_id":"source/images/spider/app.png","path":"images/spider/app.png","modified":1,"renderable":0},{"_id":"source/images/spider/mobile.gif","path":"images/spider/mobile.gif","modified":1,"renderable":0},{"_id":"source/images/spider/server.gif","path":"images/spider/server.gif","modified":1,"renderable":0}],"Cache":[{"_id":"source/404.html","hash":"9ee635e7dd02d5a2663b0591c471abd7ad913bae","modified":1689930633567},{"_id":"source/CNAME","hash":"e60e8bb34e5b0ae17dd71745f0b9b11ea3a58523","modified":1689930633567},{"_id":"source/robots.txt","hash":"6c4c15384073cab7cd56d978e57156937518e7b1","modified":1689930633651},{"_id":"source/_posts/AutoreleasePool源码分析.md","hash":"562af721f5bedf648b6b0fe23f24c50776a2e646","modified":1689930633567},{"_id":"source/_posts/Notification与多线程.md","hash":"984e002a6d0654ac0947758d24b4a734c07f4a41","modified":1689930633569},{"_id":"source/_posts/iOS多线程编程之GCD-更新swift3-0用法.md","hash":"e1cf168a8c38be52d2684aa850c29b58357f3153","modified":1689930633573},{"_id":"source/_posts/iOS多线程编程之线程锁.md","hash":"b3f8379f8571c3cfffeb8aa606a7f968f9ca404d","modified":1689930633573},{"_id":"source/_posts/iOS Reveal2Loader修复版（iOS13修复）.md","hash":"c41e640cd53f69ffc217371d54049b59b2d88449","modified":1689933008170},{"_id":"source/_posts/iOS底层之Block.md","hash":"f444d824dfc5e504620f3417e3423473e9449dea","modified":1689930633574},{"_id":"source/_posts/iOS底层之RunLoop.md","hash":"fc0412b2d0e716263af6fec7fe68ab5af490e049","modified":1689930633574},{"_id":"source/_posts/【转载】iOS进程-线程-间是如何通信的.md","hash":"5b3689203285dd6fe3dca60b7aa5483abc44e637","modified":1689930633576},{"_id":"source/_posts/如何利用RunLoop的知识来监测APP卡顿.md","hash":"5e2ecad50ba37130191ca02850d352b952231233","modified":1689930633577},{"_id":"source/archives/index.md","hash":"9c7460be00a42b2f28c674275a07f27cf7169424","modified":1689930633580},{"_id":"source/categories/index.md","hash":"a9578015c86302d49b4af46c87a73b35f886374e","modified":1689930633580},{"_id":"source/images/background_cell.png","hash":"3c8de505c87e0037ccbaf117ab5d90d4463c62d1","modified":1689930633592},{"_id":"source/images/head.png","hash":"c9b79011dde2c62e4fd174c35a49286f6c788383","modified":1689930633592},{"_id":"source/images/alipay.png","hash":"64d603a7f38cea8405ef61dd1f6007a956e49535","modified":1689930633590},{"_id":"source/images/stringFromArray.png","hash":"a80fb929a129b6e998d10d6277bfb1b3567fe1cd","modified":1689930633650},{"_id":"source/images/wechat.jpg","hash":"76361640a7d552f19685b02747622f9ff54d9ee7","modified":1689930633651},{"_id":"source/about/index.md","hash":"026ac2682a94c3df6b56d2cb470d2e3977fa25e3","modified":1689930633579},{"_id":"source/tags/index.md","hash":"461fd87c36695dccef4b1416dac469092ded4a37","modified":1689930633651},{"_id":"source/_posts/iOS底层之RunLoop/RunLoop_0.png","hash":"dc03b7f7ea3f9a9c3076bb6d13afcd98b1d52fb6","modified":1689930633574},{"_id":"source/_posts/iOS底层之RunLoop/RunLoop_3.png","hash":"fcc0b12eae77f5c585a25b783c7c86e8f8347f35","modified":1689930633575},{"_id":"source/_posts/iOS底层之RunLoop/RunLoop_4.png","hash":"6f5b39948e4a0c57683c00a0a90fef5fbf303c04","modified":1689930633575},{"_id":"source/_posts/如何利用RunLoop的知识来监测APP卡顿/图片 1.png","hash":"2f11ab9a0b1329831bc8b80b50a8d033e4ebe361","modified":1689930633579},{"_id":"source/images/jenkins/inject-environment-varibles.png","hash":"a0cb9285c7311f4ae763dd12b1f52b271ed080ee","modified":1689930633593},{"_id":"source/images/pages_tag.png","hash":"3b6fb77957f03771fa3c101f6ba6784e684733a8","modified":1689930633594},{"_id":"source/images/tect_banner.jpg","hash":"26a4b2ad43312f902495c90ce5bd2bec8a8bbc0b","modified":1689930633651},{"_id":"source/_posts/【转载】iOS进程-线程-间是如何通信的/articlex.png","hash":"d52bac7cf88b62fb09c1a1973187d66cc97f29a8","modified":1689930633577},{"_id":"source/_posts/iOS底层之RunLoop/RunLoop_network.png","hash":"ff619c5db6ae912845cb402326e96069768366ac","modified":1689930633576},{"_id":"source/images/background/2.jpg","hash":"617a41460d30bcf2acea971e696e66d9119f4938","modified":1689930633591},{"_id":"source/images/wechatpay.png","hash":"70c186d2176e778ce1f9daacaf90e69d7a11eb1d","modified":1689930633651},{"_id":"source/_posts/如何利用RunLoop的知识来监测APP卡顿/5f51c5e05085badb689f01b1e63e1c7d.png","hash":"2c82df0e7f7fb4244353442c26fe3c25ba2f8eb2","modified":1689930633578},{"_id":"source/_posts/iOS底层之RunLoop/RunLoop_1.png","hash":"74a7af62610b92b8373b38a260815a370d8bfca0","modified":1689930633575},{"_id":"source/images/spider/app.png","hash":"fb0f7ea0bea54fba911066fbaaa87cc461e3b172","modified":1689930633594},{"_id":"source/images/background/city.jpg","hash":"f5e94085efcf0fe50cfe6d46c519a5a67b45124c","modified":1689930633591},{"_id":"source/images/head_1.png","hash":"204ba5a511c36039726e63bb293de9998214c1a0","modified":1689930633593},{"_id":"themes/NexT2/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1689930633698},{"_id":"themes/NexT2/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1689930633668},{"_id":"themes/NexT2/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1689930633668},{"_id":"themes/NexT2/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1689930633693},{"_id":"themes/NexT2/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1689930633693},{"_id":"themes/NexT2/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1689930633693},{"_id":"themes/NexT2/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1689930633697},{"_id":"themes/NexT2/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1689930633697},{"_id":"source/_posts/AutoreleasePool源码分析/双向链表.png","hash":"cd554bb5e353c56a933c44b0be128a165cf86929","modified":1689930633568},{"_id":"themes/NexT2/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1689930633652},{"_id":"themes/NexT2/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1689930633652},{"_id":"themes/NexT2/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1689930633652},{"_id":"themes/NexT2/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1689930633652},{"_id":"themes/NexT2/README.md","hash":"140f4ece6670327a7d33b293947d958de80b44da","modified":1689930633653},{"_id":"themes/NexT2/_config.yml","hash":"55a0b3e0a040b75585b3571fa7f3e10a6d8c97d7","modified":1689934202260},{"_id":"themes/NexT2/.travis.yml","hash":"3d1dc928c4a97933e64379cfde749dedf62f252c","modified":1689930633652},{"_id":"themes/NexT2/bower.json","hash":"23379fec9b4f70bc2611433ac3770445a8ca18d9","modified":1689930633653},{"_id":"themes/NexT2/LICENSE.md","hash":"fc7227c508af3351120181cbf2f9b99dc41f063e","modified":1689930633652},{"_id":"themes/NexT2/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1689930633653},{"_id":"themes/NexT2/gulpfile.coffee","hash":"48d2f9fa88a4210308fc41cc7d3f6d53989f71b7","modified":1689930633658},{"_id":"themes/NexT2/package.json","hash":"d53b751bdf5f4fefa77bb359be44d3b1f1d57acb","modified":1689930633675},{"_id":"themes/NexT2/docs/ALGOLIA-SEARCH.md","hash":"141e989844d0b5ae2e09fb162a280715afb39b0d","modified":1689930633654},{"_id":"themes/NexT2/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1689930633654},{"_id":"themes/NexT2/docs/AUTHORS.md","hash":"7b24be2891167bdedb9284a682c2344ec63e50b5","modified":1689930633654},{"_id":"themes/NexT2/docs/DATA-FILES.md","hash":"8e1962dd3e1b700169b3ae5bba43992f100651ce","modified":1689930633654},{"_id":"themes/NexT2/docs/LICENSE","hash":"fe607fe22fc9308f6434b892a7f2d2c5514b8f0d","modified":1689930633655},{"_id":"themes/NexT2/docs/MATH.md","hash":"0ae4258950de01a457ea8123a8d13ec6db496e53","modified":1689930633655},{"_id":"themes/NexT2/docs/UPDATE-FROM-5.1.X.md","hash":"ad57c168d12ba01cf144a1ea0627b2ffd1847d3e","modified":1689930633655},{"_id":"themes/NexT2/docs/INSTALLATION.md","hash":"2bbdd6c1751b2b42ce9b9335da420c6026a483e9","modified":1689930633654},{"_id":"themes/NexT2/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"120750c03ec30ccaa470b113bbe39f3d423c67f0","modified":1689930633654},{"_id":"themes/NexT2/layout/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1689935028640},{"_id":"themes/NexT2/layout/_layout.swig","hash":"d2e28d2dac80069c636dccf62759e30e5f297ae7","modified":1689935232027},{"_id":"themes/NexT2/layout/archive.swig","hash":"2b6450c6b6d2bcbcd123ad9f59922a5e323d77a5","modified":1689930633674},{"_id":"themes/NexT2/layout/category.swig","hash":"5d955284a42f802a48560b4452c80906a5d1da02","modified":1689930633674},{"_id":"themes/NexT2/layout/post.swig","hash":"318249db246a57e9422875a2457c6acfce974ba5","modified":1689930633674},{"_id":"themes/NexT2/layout/index.swig","hash":"a1be2501ebe47dd5e534caff525c40cb2d032c34","modified":1689930633674},{"_id":"themes/NexT2/layout/page.swig","hash":"79040bae5ec14291441b33eea341a24a7c0e9f93","modified":1689930633674},{"_id":"themes/NexT2/layout/tag.swig","hash":"ba402ce8fd55e80b240e019e8d8c48949b194373","modified":1689930633674},{"_id":"themes/NexT2/layout/schedule.swig","hash":"3e9cba5313bf3b98a38ccb6ef78b56ffa11d66ee","modified":1689930633674},{"_id":"themes/NexT2/languages/de.yml","hash":"fb478c5040a4e58a4c1ad5fb52a91e5983d65a3a","modified":1689930633658},{"_id":"themes/NexT2/languages/default.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1689930633658},{"_id":"themes/NexT2/languages/en.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1689930633658},{"_id":"themes/NexT2/languages/fr.yml","hash":"0162a85ae4175e66882a9ead1249fedb89200467","modified":1689930633658},{"_id":"themes/NexT2/languages/ja.yml","hash":"e331b15b1fda0f2285d25853f834682ab8dc3c39","modified":1689930633659},{"_id":"themes/NexT2/languages/it.yml","hash":"62ef41d0a9a3816939cb4d93a524e6930ab9c517","modified":1689930633659},{"_id":"themes/NexT2/languages/id.yml","hash":"e7fb582e117a0785036dcdbb853a6551263d6aa6","modified":1689930633659},{"_id":"themes/NexT2/languages/nl.yml","hash":"bb9ce8adfa5ee94bc6b5fac6ad24ba4605d180d3","modified":1689930633659},{"_id":"themes/NexT2/languages/pt-BR.yml","hash":"bfc80c8a363fa2e8dde38ea2bc85cd19e15ab653","modified":1689930633659},{"_id":"themes/NexT2/languages/ko.yml","hash":"fae155018ae0efdf68669b2c7dd3f959c2e45cc9","modified":1689930633659},{"_id":"themes/NexT2/languages/pt.yml","hash":"3cb51937d13ff12fcce747f972ccb664840a9ef3","modified":1689930633660},{"_id":"themes/NexT2/languages/ru.yml","hash":"db0644e738d2306ac38567aa183ca3e859a3980f","modified":1689930633660},{"_id":"themes/NexT2/languages/tr.yml","hash":"c5f0c20743b1dd52ccb256050b1397d023e6bcd9","modified":1689930633660},{"_id":"themes/NexT2/languages/vi.yml","hash":"8da921dd8335dd676efce31bf75fdd4af7ce6448","modified":1689930633660},{"_id":"themes/NexT2/languages/zh-CN.yml","hash":"d2e9a2a608e3f625b4880545dcb40dc3578b3543","modified":1689930633660},{"_id":"themes/NexT2/languages/zh-TW.yml","hash":"6e6d2cd8f4244cb1b349b94904cb4770935acefd","modified":1689930633660},{"_id":"themes/NexT2/languages/zh-HK.yml","hash":"7903b96912c605e630fb695534012501b2fad805","modified":1689930633660},{"_id":"themes/NexT2/scripts/helpers.js","hash":"a70bfad3efda76738dab12e28e8b75e3989ee3da","modified":1689930633675},{"_id":"themes/NexT2/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1689930633675},{"_id":"themes/NexT2/scripts/merge-configs.js","hash":"33afe97284d34542015d358a720823feeebef120","modified":1689930633675},{"_id":"themes/NexT2/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1689930633706},{"_id":"themes/NexT2/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1689930633706},{"_id":"themes/NexT2/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1689930633706},{"_id":"themes/NexT2/docs/ru/DATA-FILES.md","hash":"d6d20f60f77a76c77f8e65d0c9adbd79d0274557","modified":1689930633655},{"_id":"themes/NexT2/docs/ru/INSTALLATION.md","hash":"6c5d69e94961c793da156217ecf1179e868d7ba1","modified":1689930633656},{"_id":"themes/NexT2/docs/ru/README.md","hash":"c54e256ed11a84ee38f755d6f35a3e6e29a91dbc","modified":1689930633656},{"_id":"themes/NexT2/docs/ru/UPDATE-FROM-5.1.X.md","hash":"b1dd18d9b890b21718883ea1832e7e02a773104a","modified":1689930633656},{"_id":"themes/NexT2/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"6855402e2ef59aae307e8bd2a990647d3a605eb8","modified":1689930633656},{"_id":"themes/NexT2/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"a45a791b49954331390d548ac34169d573ea5922","modified":1689930633656},{"_id":"themes/NexT2/docs/zh-CN/CONTRIBUTING.md","hash":"bd2c955d9b7b1b45bd74a4536717d547e03fcde3","modified":1689930633657},{"_id":"themes/NexT2/docs/zh-CN/DATA-FILES.md","hash":"f3eec572a7d83542e2710a7404082014aaa1a5e7","modified":1689930633657},{"_id":"themes/NexT2/docs/zh-CN/INSTALLATION.md","hash":"b19a6e0ae96eb7c756fb5b1ba03934c7f9cbb3c3","modified":1689930633657},{"_id":"themes/NexT2/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"24cf2618d164440b047bb9396263de83bee5b993","modified":1689930633657},{"_id":"themes/NexT2/docs/zh-CN/MATH.md","hash":"e03607b608db4aa7d46f6726827c51ac16623339","modified":1689930633657},{"_id":"themes/NexT2/docs/zh-CN/README.md","hash":"aa6808f4f587c1a97205fa9427ba96a366bcb288","modified":1689930633658},{"_id":"themes/NexT2/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"5da70d7fa0c988a66a469b9795d33d471a4a4433","modified":1689930633658},{"_id":"themes/NexT2/layout/_custom/head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1689930633661},{"_id":"themes/NexT2/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1689930633661},{"_id":"themes/NexT2/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1689930633661},{"_id":"themes/NexT2/layout/_macro/my-copyright.swig","hash":"8ab1d75c96b94f76b9962760f1f87fdead753499","modified":1689930633662},{"_id":"themes/NexT2/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1689930633662},{"_id":"themes/NexT2/layout/_macro/post-copyright.swig","hash":"0790ddbc349508d7ece45a9a4391d0a1cd7263cc","modified":1689930633662},{"_id":"themes/NexT2/layout/_macro/post.swig","hash":"4e01b01ed08498ab0b7e5faf1dce867916ee2416","modified":1689930633662},{"_id":"themes/NexT2/layout/_macro/post-related.swig","hash":"08fe30ce8909b920540231e36c97e28cfbce62b6","modified":1689930633662},{"_id":"themes/NexT2/layout/_macro/reward.swig","hash":"bd5778d509c51f4b1d8da3a2bc35462929f08c75","modified":1689930633663},{"_id":"themes/NexT2/layout/_macro/sidebar.swig","hash":"1f3121ef66a4698fd78f34bf2594ef79a407c92c","modified":1689930633663},{"_id":"themes/NexT2/layout/_macro/wechat-subscriber.swig","hash":"a9e1346b83cf99e06bed59a53fc069279751e52a","modified":1689930633663},{"_id":"themes/NexT2/layout/_scripts/boostrap.swig","hash":"0a0129e926c27fffc6e7ef87fe370016bc7a4564","modified":1689930633667},{"_id":"themes/NexT2/layout/_scripts/commons.swig","hash":"6fc63d5da49cb6157b8792f39c7305b55a0d1593","modified":1689930633667},{"_id":"themes/NexT2/layout/_scripts/change_banner_image.swig","hash":"326d11dd0c0b2662bc2f232c4253522fabbe4d3c","modified":1689930633667},{"_id":"themes/NexT2/layout/_scripts/noscript.swig","hash":"ac3ad2c0eccdf16edaa48816d111aaf51200a54b","modified":1689930633667},{"_id":"themes/NexT2/layout/_partials/breadcrumb.swig","hash":"6994d891e064f10607bce23f6e2997db7994010e","modified":1689930633663},{"_id":"themes/NexT2/layout/_scripts/vendors.swig","hash":"e0bdc723d1dc858b41fd66e44e2786e6519f259f","modified":1689930633668},{"_id":"themes/NexT2/layout/_partials/comments.swig","hash":"eafff2d623af8991844f34819a60e37ac11ef245","modified":1689930633663},{"_id":"themes/NexT2/layout/_partials/footer.swig","hash":"06eeca8352a8b48efd303e9c8c146a5b11b02a6f","modified":1689930633664},{"_id":"themes/NexT2/layout/_partials/page-header.swig","hash":"1aaf32bed57b976c4c1913fd801be34d4838cc72","modified":1689930633665},{"_id":"themes/NexT2/layout/_partials/pagination.swig","hash":"dbe321bcf3cf45917cc11a3e3f50d8572bac2c70","modified":1689930633665},{"_id":"themes/NexT2/layout/_third-party/bookmark.swig","hash":"60001c8e08b21bf3a7afaf029839e1455340e95d","modified":1689930633670},{"_id":"themes/NexT2/layout/_third-party/copy-code.swig","hash":"a8ab2035654dd06d94faf11a35750529e922d719","modified":1689930633671},{"_id":"themes/NexT2/layout/_third-party/exturl.swig","hash":"f532ce257fca6108e84b8f35329c53f272c2ce84","modified":1689930633671},{"_id":"themes/NexT2/layout/_third-party/github-banner.swig","hash":"cabd9640dc3027a0b3ac06f5ebce777e50754065","modified":1689930633671},{"_id":"themes/NexT2/layout/_third-party/pangu.swig","hash":"6b75c5fd76ae7cf0a7b04024510bd5221607eab3","modified":1689930633672},{"_id":"themes/NexT2/layout/_third-party/needsharebutton.swig","hash":"927f19160ae14e7030df306fc7114ba777476282","modified":1689930633672},{"_id":"themes/NexT2/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1689930633672},{"_id":"themes/NexT2/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1689930633672},{"_id":"themes/NexT2/layout/_third-party/scroll-cookie.swig","hash":"b0ca46e0d1ff4c08cb0a3a8c1994f20d0260cef9","modified":1689930633672},{"_id":"themes/NexT2/scripts/tags/center-quote.js","hash":"f13430d9d1c9773b390787c2f046bb1f12a79878","modified":1689930633675},{"_id":"themes/NexT2/scripts/tags/button.js","hash":"4b12c376bea894d23cca0f9fcb3d6518b6db279d","modified":1689930633675},{"_id":"themes/NexT2/scripts/tags/exturl.js","hash":"1412ce2ef59fa4137b697a507fd759ff067a2398","modified":1689930633676},{"_id":"themes/NexT2/scripts/tags/full-image.js","hash":"e282bf5a7c70b3d354001e8f66d3bef1a4fbb79e","modified":1689930633676},{"_id":"themes/NexT2/scripts/tags/group-pictures.js","hash":"981e01aaf45a1f0f23ce0796d03134f9e437aaca","modified":1689930633676},{"_id":"themes/NexT2/scripts/tags/include-raw.js","hash":"5db59d56f4f4082382bf1c16722e6c383892b0c5","modified":1689930633676},{"_id":"themes/NexT2/scripts/tags/label.js","hash":"f0ecd3b5773b19a6bd93a819dfe0c49ee418e4de","modified":1689930633676},{"_id":"themes/NexT2/scripts/tags/note.js","hash":"adb945ba93ac487d46b969ca4e59d3681b8f8d1c","modified":1689930633677},{"_id":"themes/NexT2/scripts/tags/tabs.js","hash":"e37761253d68a29593fe9ed2fe403f49b6e971de","modified":1689930633677},{"_id":"themes/NexT2/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1689930633698},{"_id":"themes/NexT2/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1689930633698},{"_id":"themes/NexT2/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1689930633698},{"_id":"themes/NexT2/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1689930633698},{"_id":"themes/NexT2/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1689930633698},{"_id":"themes/NexT2/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1689930633698},{"_id":"themes/NexT2/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1689930633698},{"_id":"themes/NexT2/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1689930633698},{"_id":"themes/NexT2/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1689930633699},{"_id":"themes/NexT2/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1689930633699},{"_id":"themes/NexT2/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1689930633699},{"_id":"themes/NexT2/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1689930633699},{"_id":"themes/NexT2/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1689930633699},{"_id":"themes/NexT2/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1689930633699},{"_id":"themes/NexT2/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1689930633699},{"_id":"themes/NexT2/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1689930633699},{"_id":"themes/NexT2/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1689930633699},{"_id":"themes/NexT2/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1689930633699},{"_id":"themes/NexT2/source/css/main.styl","hash":"c26ca6e7b5bd910b9046d6722c8e00be672890e0","modified":1689930633697},{"_id":"themes/NexT2/layout/_macro/menu/menu-badge.swig","hash":"65c5e585982dae7ae1542cada71858b4ea1f73d6","modified":1689930633661},{"_id":"themes/NexT2/layout/_macro/menu/menu-item.swig","hash":"d1b73c926109145e52605929b75914cc8b60fb89","modified":1689930633661},{"_id":"themes/NexT2/layout/_scripts/pages/post-details.swig","hash":"cc865af4a3cb6d25a0be171b7fc919ade306bb50","modified":1689930633667},{"_id":"themes/NexT2/layout/_scripts/schemes/gemini.swig","hash":"ea03fe9c98ddcfcc0ecfdbe5a2b622f9cde3b3a1","modified":1689930633667},{"_id":"themes/NexT2/layout/_scripts/schemes/pisces.swig","hash":"ea03fe9c98ddcfcc0ecfdbe5a2b622f9cde3b3a1","modified":1689930633668},{"_id":"themes/NexT2/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1689930633664},{"_id":"themes/NexT2/layout/_partials/head/head-unique.swig","hash":"a7e376b087ae77f2e2a61ba6af81cde5af693174","modified":1689930633664},{"_id":"themes/NexT2/layout/_partials/head/head.swig","hash":"ca0db78b3b6b48a6f739d27795b24b68faeb4163","modified":1689930633664},{"_id":"themes/NexT2/layout/_partials/header/brand.swig","hash":"fd780171713aada5eb4f4ffed8e714617c8ae6be","modified":1689930633664},{"_id":"themes/NexT2/layout/_partials/header/index.swig","hash":"2082f5077551123e695e8afec471c9c44b436acb","modified":1689930633665},{"_id":"themes/NexT2/layout/_partials/header/menu.swig","hash":"3db735d0cd2d449edf2674310ac1e7c0043cb357","modified":1689930633665},{"_id":"themes/NexT2/layout/_partials/header/sub-menu.swig","hash":"88b4b6051592d26bff59788acb76346ce4e398c2","modified":1689930633665},{"_id":"themes/NexT2/layout/_partials/search/index.swig","hash":"a33b29ccbdc2248aedff23b04e0627f435824406","modified":1689930633665},{"_id":"themes/NexT2/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1689930633666},{"_id":"themes/NexT2/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1689930633666},{"_id":"themes/NexT2/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1689930633666},{"_id":"themes/NexT2/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1689930633666},{"_id":"themes/NexT2/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1689930633666},{"_id":"themes/NexT2/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1689930633666},{"_id":"themes/NexT2/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1689930633668},{"_id":"themes/NexT2/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1689930633668},{"_id":"themes/NexT2/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1689930633668},{"_id":"themes/NexT2/layout/_third-party/analytics/busuanzi-counter.swig","hash":"07307f1f0e0e9858f2c7143cbdfcb2a9a92149ab","modified":1689930633669},{"_id":"themes/NexT2/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1689930633669},{"_id":"themes/NexT2/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1689930633669},{"_id":"themes/NexT2/layout/_third-party/analytics/firestore.swig","hash":"fae69a0e1a1d42f7bb44e594a29857d94594698b","modified":1689930633669},{"_id":"themes/NexT2/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1689930633669},{"_id":"themes/NexT2/layout/_third-party/analytics/google-analytics.swig","hash":"beb53371c035b62e1a2c7bb76c63afbb595fe6e5","modified":1689930633669},{"_id":"themes/NexT2/layout/_third-party/analytics/lean-analytics.swig","hash":"c28f3f4aa31d7f996d26a97df6cd7ffa9bfd2cec","modified":1689930633669},{"_id":"themes/NexT2/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1689930633670},{"_id":"themes/NexT2/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1689930633670},{"_id":"themes/NexT2/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1689930633670},{"_id":"themes/NexT2/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1689930633670},{"_id":"themes/NexT2/layout/_third-party/comments/disqus.swig","hash":"03ef008bc95e8e83232e5464a6c63d6157d33a5e","modified":1689930633670},{"_id":"themes/NexT2/layout/_third-party/comments/gitment.swig","hash":"fe8177e4698df764e470354b6acde8292a3515e0","modified":1689930633671},{"_id":"themes/NexT2/layout/_third-party/comments/index.swig","hash":"03e83f1311faafb7dddc2899042ed1cacd5c995e","modified":1689930633671},{"_id":"themes/NexT2/layout/_third-party/comments/valine.swig","hash":"34421679cae6581697cd3ab7c3729eb220e3e3f5","modified":1689930633671},{"_id":"themes/NexT2/layout/_third-party/comments/livere.swig","hash":"2c74a96dd314e804d801f8773ac1b2e0a970fce3","modified":1689930633671},{"_id":"themes/NexT2/layout/_third-party/math/index.swig","hash":"a6fc00ec7f5642aabd66aa1cf51c6acc5b10e012","modified":1689930633672},{"_id":"themes/NexT2/layout/_third-party/math/mathjax.swig","hash":"9b9ff4cc6d5474ab03f09835a2be80e0dba9fe89","modified":1689930633672},{"_id":"themes/NexT2/layout/_third-party/math/katex.swig","hash":"97dbc2035bcb5aa7eafb80a4202dc827cce34983","modified":1689930633672},{"_id":"themes/NexT2/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1689930633673},{"_id":"themes/NexT2/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1689930633673},{"_id":"themes/NexT2/layout/_third-party/search/localsearch.swig","hash":"b15e10abe85b4270860a56c970b559baa258b2a8","modified":1689930633673},{"_id":"themes/NexT2/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1689930633674},{"_id":"themes/NexT2/source/css/_custom/custom.styl","hash":"2033df443b91282b353960904d27dcc0c4222c5e","modified":1689930633693},{"_id":"themes/NexT2/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1689930633693},{"_id":"themes/NexT2/source/css/_mixins/Pisces.styl","hash":"2640a54fa63bdd4c547eab7ce2fc1192cf0ccec8","modified":1689930633693},{"_id":"themes/NexT2/source/css/_mixins/base.styl","hash":"59961fb806a39c367fd19ad37268eee112be6729","modified":1689930633693},{"_id":"themes/NexT2/source/css/_variables/Gemini.styl","hash":"e1f6f59ad6e562dfe640ee4ed5d1ac9b6aba4114","modified":1689930633697},{"_id":"themes/NexT2/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1689930633697},{"_id":"themes/NexT2/source/css/_variables/Pisces.styl","hash":"c167eeb6b736f7b021fba98c38c2c21032ee1255","modified":1689930633697},{"_id":"themes/NexT2/source/css/_variables/base.styl","hash":"f9b83d0385529e52ce7ba95ed5ed6b3d4e2419bb","modified":1689930633697},{"_id":"themes/NexT2/source/lib/algolia-instant-search/.git","hash":"a67db77c2ffe6606a14cbd501b7ab0dff9750654","modified":1689930350854},{"_id":"themes/NexT2/source/lib/algolia-instant-search/LICENSE","hash":"b29db4c99aa5b8d574026f68804051ff4b75466e","modified":1689930350973},{"_id":"themes/NexT2/source/lib/algolia-instant-search/README.md","hash":"9fa5175cdb7d3d939fe7174b6d68608ca996c174","modified":1689930350973},{"_id":"themes/NexT2/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1689930350973},{"_id":"themes/NexT2/source/lib/canvas-nest/.git","hash":"ad424fcad729fd6a8fed4fd82154263761b76c9f","modified":1689930361629},{"_id":"themes/NexT2/source/lib/canvas-nest/LICENSE","hash":"b29db4c99aa5b8d574026f68804051ff4b75466e","modified":1689930361751},{"_id":"themes/NexT2/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1689930361751},{"_id":"themes/NexT2/source/lib/canvas-nest/README.md","hash":"bf7819cbb879bb82ec1097513d8f799df8835e0f","modified":1689930361751},{"_id":"themes/NexT2/source/lib/fancybox/.bower.json","hash":"d8bf9cb15d9d91c7ad022ba2954b5b4d326f17f7","modified":1689930367364},{"_id":"themes/NexT2/source/lib/fancybox/.git","hash":"c842a35787ec222441533de14f55bb36f55a7446","modified":1689930367243},{"_id":"themes/NexT2/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1689930367364},{"_id":"themes/NexT2/source/lib/fancybox/LICENSE","hash":"8624bcdae55baeef00cd11d5dfcfa60f68710a02","modified":1689930367364},{"_id":"themes/NexT2/source/lib/fancybox/README.md","hash":"a40db80eb6386b085ff810fd3e302f12e76b8df7","modified":1689930367365},{"_id":"themes/NexT2/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1689930633702},{"_id":"themes/NexT2/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1689930633702},{"_id":"themes/NexT2/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1689930633702},{"_id":"themes/NexT2/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1689930633702},{"_id":"themes/NexT2/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1689930633702},{"_id":"themes/NexT2/source/lib/reading_progress/.git","hash":"fa41c13737737a5ad5e9af469656ed66b0a04811","modified":1689930372463},{"_id":"themes/NexT2/source/lib/reading_progress/.editorconfig","hash":"7d47ecd70ca58d26af4f69ff1b23034edcf4475e","modified":1689930372591},{"_id":"themes/NexT2/source/lib/reading_progress/.gitignore","hash":"09cde1060b4213a7eee528b54560777d2d3756e8","modified":1689930372592},{"_id":"themes/NexT2/source/lib/reading_progress/LICENSE","hash":"b29db4c99aa5b8d574026f68804051ff4b75466e","modified":1689930372592},{"_id":"themes/NexT2/source/lib/reading_progress/package.json","hash":"7bcb3787978a0c445b1bd3dfeca6ae6016c98abc","modified":1689930372592},{"_id":"themes/NexT2/source/lib/reading_progress/README.md","hash":"9b00c4ce1a739c825df4e51977f7525d2c9f6b81","modified":1689930372592},{"_id":"themes/NexT2/source/lib/reading_progress/reading_progress.js","hash":"174678a8e2a24763e3fe8b9c25496fdf6ee0220b","modified":1689930372592},{"_id":"themes/NexT2/source/lib/three/.git","hash":"b0e4dd18600ef048686cbbecb0b091beec4a4453","modified":1689930356596},{"_id":"themes/NexT2/source/lib/three/LICENSE","hash":"b29db4c99aa5b8d574026f68804051ff4b75466e","modified":1689930356717},{"_id":"themes/NexT2/source/lib/reading_progress/reading_progress.min.js","hash":"98af8d99819882904f9b1a9254bebf40602e1843","modified":1689930372592},{"_id":"themes/NexT2/source/lib/three/.gitignore","hash":"e691fe9e685cbd50bcd7e138f4ca3503e7b0eaa4","modified":1689930356717},{"_id":"themes/NexT2/source/lib/three/README.md","hash":"5096005b6bfa0e554b245c6c1ffe10e7edc8130d","modified":1689930356717},{"_id":"themes/NexT2/source/lib/three/canvas_sphere.min.js","hash":"333fed4c256c7081e07c7844c097b7970b45b248","modified":1689930356718},{"_id":"themes/NexT2/source/lib/three/canvas_lines.min.js","hash":"97f0e67570574dc8597c5819970508d4e7f7af25","modified":1689930356718},{"_id":"themes/NexT2/source/lib/three/gulpfile.js","hash":"edd1868be72fde796b0b1f3a7a0316b3c896962a","modified":1689930356718},{"_id":"themes/NexT2/source/lib/three/package.json","hash":"68c5104de7461d425a5dbe521cea0cf00af289c3","modified":1689930356719},{"_id":"themes/NexT2/source/lib/three/three-waves.min.js","hash":"704e860183acbaaf8de1be65fe5c958e8105f4bf","modified":1689930356719},{"_id":"themes/NexT2/source/lib/three/yarn.lock","hash":"9c71c0a7c033fc709c1e683157b1f12037024694","modified":1689930356722},{"_id":"themes/NexT2/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1689930633705},{"_id":"themes/NexT2/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1689930633705},{"_id":"themes/NexT2/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1689930633706},{"_id":"themes/NexT2/source/js/src/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1689930633700},{"_id":"themes/NexT2/source/js/src/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1689930633700},{"_id":"themes/NexT2/source/js/src/bootstrap.js","hash":"1c41508b83cb0c4512e64b4d63afa1be954ce8ef","modified":1689930633700},{"_id":"themes/NexT2/source/js/src/clipboard.min.js","hash":"eb41c0e88206dda6f0fd8dfbbeefdc0829a9d13d","modified":1689930633700},{"_id":"themes/NexT2/source/js/src/copy_code.js","hash":"9921c9fda24c365fa936c725660aac90f8358863","modified":1689930633700},{"_id":"themes/NexT2/source/js/src/custom.js","hash":"e026b7ca3480df9142e7b27bfe85c25deed70705","modified":1689930633700},{"_id":"themes/NexT2/source/js/src/exturl.js","hash":"10f45d0f862fa8eb5d271a7a3fbefd7782813ab6","modified":1689930633700},{"_id":"themes/NexT2/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1689930633700},{"_id":"themes/NexT2/source/js/src/love.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1689930633701},{"_id":"themes/NexT2/source/js/src/motion.js","hash":"86a2f620df85af2d102b7383c71582879c3b403c","modified":1689930633701},{"_id":"themes/NexT2/source/js/src/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1689930633701},{"_id":"themes/NexT2/source/js/src/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1689930633701},{"_id":"themes/NexT2/source/js/src/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1689930633701},{"_id":"themes/NexT2/layout/_third-party/search/algolia-search/assets.swig","hash":"6958a97fde63e03983ec2394a4f8e408860fb42b","modified":1689930633673},{"_id":"themes/NexT2/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1689930633673},{"_id":"themes/NexT2/source/js/src/utils.js","hash":"e437eff1d3781c4a1aec9ff2060565524a37c983","modified":1689930633701},{"_id":"themes/NexT2/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1689930633677},{"_id":"themes/NexT2/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1689930633677},{"_id":"themes/NexT2/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1689930633678},{"_id":"themes/NexT2/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1689930633678},{"_id":"themes/NexT2/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1689930633678},{"_id":"themes/NexT2/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1689930633682},{"_id":"themes/NexT2/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1689930633688},{"_id":"themes/NexT2/source/css/_common/outline/outline.styl","hash":"aebbd86500d819c4532ab290c62b6f432bc2f878","modified":1689930633692},{"_id":"themes/NexT2/source/css/_common/scaffolding/base.styl","hash":"b75256fe3768b1a37b6ff6dd7f9f0ff135a42067","modified":1689930633692},{"_id":"themes/NexT2/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1689930633692},{"_id":"themes/NexT2/source/css/_common/scaffolding/mobile.styl","hash":"efc40a32487e0ac7b94b1ca81bdbdcc4ec8f2924","modified":1689930633692},{"_id":"themes/NexT2/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1689930633692},{"_id":"themes/NexT2/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1689930633692},{"_id":"themes/NexT2/source/css/_common/scaffolding/tables.styl","hash":"02d138ed65060e98f20bc5b1dd59a791222b7156","modified":1689930633692},{"_id":"themes/NexT2/source/css/_schemes/Gemini/index.styl","hash":"fca5320e2644edcd663888863899d1b80352439b","modified":1689930633693},{"_id":"themes/NexT2/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1689930633695},{"_id":"themes/NexT2/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1689930633695},{"_id":"themes/NexT2/source/css/_schemes/Muse/_menu.styl","hash":"35f093fe4c1861661ac1542d6e8ea5a9bbfeb659","modified":1689930633695},{"_id":"themes/NexT2/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1689930633695},{"_id":"themes/NexT2/source/css/_schemes/Muse/index.styl","hash":"d5e8ea6336bc2e237d501ed0d5bbcbbfe296c832","modified":1689930633695},{"_id":"themes/NexT2/source/css/_schemes/Mist/_base.styl","hash":"0bef9f0dc134215bc4d0984ba3a16a1a0b6f87ec","modified":1689930633694},{"_id":"themes/NexT2/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1689930633694},{"_id":"themes/NexT2/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1689930633694},{"_id":"themes/NexT2/source/css/_schemes/Mist/_menu.styl","hash":"f43c821ea272f80703862260b140932fe4aa0e1f","modified":1689930633694},{"_id":"themes/NexT2/source/css/_schemes/Mist/_posts-expanded.styl","hash":"2212511ae14258d93bec57993c0385e5ffbb382b","modified":1689930633694},{"_id":"themes/NexT2/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1689930633694},{"_id":"themes/NexT2/source/css/_schemes/Mist/index.styl","hash":"5e12572b18846250e016a872a738026478ceef37","modified":1689930633694},{"_id":"themes/NexT2/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1689930633696},{"_id":"themes/NexT2/source/css/_schemes/Pisces/_layout.styl","hash":"876b5d99061025cf485a3cac440624ded5734319","modified":1689930633696},{"_id":"themes/NexT2/source/css/_schemes/Pisces/_menu.styl","hash":"05a5abf02e84ba8f639b6f9533418359f0ae4ecb","modified":1689930633696},{"_id":"themes/NexT2/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1689930633696},{"_id":"themes/NexT2/source/css/_schemes/Pisces/_sidebar.styl","hash":"41f9cdafa00e256561c50ae0b97ab7fcd7c1d6a2","modified":1689930633696},{"_id":"themes/NexT2/source/css/_schemes/Pisces/_sub-menu.styl","hash":"ffa870c3fa37a48b01dc6f967e66f5df508d02bf","modified":1689930633696},{"_id":"themes/NexT2/source/css/_schemes/Pisces/index.styl","hash":"5779cc8086b1cfde9bc4f1afdd85223bdc45f0a0","modified":1689930633697},{"_id":"themes/NexT2/source/lib/fancybox/source/jquery.fancybox.css","hash":"a5913612c237bb7443c6006a386edd775201d423","modified":1689930367365},{"_id":"themes/NexT2/source/lib/fancybox/source/jquery.fancybox.min.css","hash":"84adea69673c392c1d34a5a316e8e5960aa348b5","modified":1689930367366},{"_id":"themes/NexT2/source/lib/fancybox/source/jquery.fancybox.min.js","hash":"b85b75426ff7569d54a1f69689895315e80ed85d","modified":1689930367366},{"_id":"themes/NexT2/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1689930633702},{"_id":"themes/NexT2/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1689930633702},{"_id":"themes/NexT2/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1689930633703},{"_id":"themes/NexT2/source/lib/three/lib/CanvasRenderer.js","hash":"cf8e1ce6e884023ad0d692cf30f399862407fb40","modified":1689930356718},{"_id":"themes/NexT2/source/lib/three/lib/Projector.js","hash":"1ad16e96cea2a8a9155bb429c83ef9bdd341ce99","modified":1689930356719},{"_id":"themes/NexT2/source/lib/three/src/canvas_lines.js","hash":"650310ff6783671f8ceccf01f840b20d9c87b491","modified":1689930356719},{"_id":"themes/NexT2/source/lib/three/src/three-waves.js","hash":"e98e442f14920e9fb8691846dca3a2225d403048","modified":1689930356719},{"_id":"themes/NexT2/source/lib/three/src/canvas_sphere.js","hash":"7614790c67d3e79e3390fe688f6b01afad7e3bb1","modified":1689930356719},{"_id":"themes/NexT2/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1689930633704},{"_id":"themes/NexT2/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1689930633705},{"_id":"themes/NexT2/source/css/_common/components/footer/footer.styl","hash":"39dee82d481dd9d44e33658960ec63e47cd0a715","modified":1689930633678},{"_id":"themes/NexT2/source/js/src/schemes/pisces.js","hash":"ab3932fa3637a5e23ae6287e78fbfeb54f2c85d2","modified":1689930633701},{"_id":"themes/NexT2/source/css/_common/components/header/github-banner.styl","hash":"ee37e6c465b9b2a7e39175fccfcbed14f2db039b","modified":1689930633679},{"_id":"themes/NexT2/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1689930633679},{"_id":"themes/NexT2/source/css/_common/components/header/header.styl","hash":"7cc3f36222494c9a1325c5347d7eb9ae53755a32","modified":1689930633679},{"_id":"themes/NexT2/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1689930633679},{"_id":"themes/NexT2/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1689930633680},{"_id":"themes/NexT2/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1689930633680},{"_id":"themes/NexT2/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1689930633680},{"_id":"themes/NexT2/source/css/_common/components/highlight/highlight.styl","hash":"a6dc3c7eb81ef5117c28fa2245fff1adc02d0292","modified":1689930633680},{"_id":"themes/NexT2/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1689930633680},{"_id":"themes/NexT2/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1689930633681},{"_id":"themes/NexT2/source/css/_common/components/pages/breadcrumb.styl","hash":"7dd9a0378ccff3e4a2003f486b1a34e74c20dac6","modified":1689930633681},{"_id":"themes/NexT2/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1689930633681},{"_id":"themes/NexT2/source/css/_common/components/pages/pages.styl","hash":"fb451dc4cc0355b57849c27d3eb110c73562f794","modified":1689930633681},{"_id":"themes/NexT2/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1689930633682},{"_id":"themes/NexT2/source/css/_common/components/post/my-post-copyright.styl","hash":"3496dc2ca5647bbf6a827f991d61849205a5955a","modified":1689930633682},{"_id":"themes/NexT2/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1689930633683},{"_id":"themes/NexT2/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1689930633683},{"_id":"themes/NexT2/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1689930633683},{"_id":"themes/NexT2/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1689930633682},{"_id":"themes/NexT2/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1689930633682},{"_id":"themes/NexT2/source/css/_common/components/post/post-expand.styl","hash":"ca89b167d368eac50a4f808fa53ba67e69cbef94","modified":1689930633683},{"_id":"themes/NexT2/source/css/_common/components/post/post-reading_progress.styl","hash":"f4e9f870baa56eae423a123062f00e24cc780be1","modified":1689930633684},{"_id":"themes/NexT2/source/css/_common/components/post/post-meta.styl","hash":"417f05ff12a2aaca6ceeac8b7e7eb26e9440c4c3","modified":1689930633684},{"_id":"themes/NexT2/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1689930633684},{"_id":"themes/NexT2/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1689930633683},{"_id":"themes/NexT2/source/css/_common/components/post/post-reward.styl","hash":"549a8a0b5301d32acd86a97f17340cdfcd46fb63","modified":1689930633684},{"_id":"themes/NexT2/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1689930633685},{"_id":"themes/NexT2/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1689930633685},{"_id":"themes/NexT2/source/css/_common/components/post/post-title.styl","hash":"fcbbf06b546c366d70b7d2ba5880b0be3ca1e8ea","modified":1689930633685},{"_id":"themes/NexT2/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1689930633685},{"_id":"themes/NexT2/source/css/_common/components/post/post-widgets.styl","hash":"578bb2d5f24cad39205bbafb4c39c7e9962b9fa9","modified":1689930633685},{"_id":"themes/NexT2/source/css/_common/components/post/post.styl","hash":"0d563a4c60ec525916edd9908971dd2dc06450d2","modified":1689930633686},{"_id":"themes/NexT2/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"35c0350096921dd8e2222ec41b6c17a4ea6b44f2","modified":1689930633686},{"_id":"themes/NexT2/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1689930633686},{"_id":"themes/NexT2/source/css/_common/components/sidebar/sidebar-author.styl","hash":"e18b90c97aaff027e795f5a0cb10476a71bf1c3a","modified":1689930633686},{"_id":"themes/NexT2/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1689930633687},{"_id":"themes/NexT2/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1689930633687},{"_id":"themes/NexT2/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1689930633687},{"_id":"themes/NexT2/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1689930633688},{"_id":"themes/NexT2/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"4427ed3250483ed5b7baad74fa93474bd1eda729","modified":1689930633687},{"_id":"themes/NexT2/source/css/_common/components/sidebar/sidebar.styl","hash":"95c3c01224a66b1213115634a7564abde262b0b6","modified":1689930633688},{"_id":"themes/NexT2/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1689930633688},{"_id":"themes/NexT2/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1689930633688},{"_id":"themes/NexT2/source/css/_common/components/tags/full-image.styl","hash":"6ec8ea7b11a146777b6b8da0f71f0cc1dbd129df","modified":1689930633688},{"_id":"themes/NexT2/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1689930633689},{"_id":"themes/NexT2/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1689930633689},{"_id":"themes/NexT2/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1689930633689},{"_id":"themes/NexT2/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1689930633689},{"_id":"themes/NexT2/source/css/_common/components/third-party/algolia-search.styl","hash":"10e9bb3392826a5a8f4cabfc14c6d81645f33fe6","modified":1689930633690},{"_id":"themes/NexT2/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1689930633689},{"_id":"themes/NexT2/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1689930633690},{"_id":"themes/NexT2/source/css/_common/components/tags/tags.styl","hash":"5e340ee2407a4e39cd708794cfcc718a5f398d7b","modified":1689930633690},{"_id":"themes/NexT2/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1689930633691},{"_id":"themes/NexT2/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1689930633690},{"_id":"themes/NexT2/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1689930633691},{"_id":"themes/NexT2/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1689930633691},{"_id":"themes/NexT2/source/css/_common/components/third-party/third-party.styl","hash":"1c18c91ab3c60169ebe654c80c968fd8458786a3","modified":1689930633691},{"_id":"themes/NexT2/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1689930633696},{"_id":"themes/NexT2/source/css/_common/components/third-party/related-posts.styl","hash":"76937db9702053d772f6758d9cea4088c2a6e2a3","modified":1689930633691},{"_id":"themes/NexT2/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1689930633695},{"_id":"themes/NexT2/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1689930633695},{"_id":"themes/NexT2/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1689930633704},{"_id":"themes/NexT2/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1689930633704},{"_id":"themes/NexT2/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1689930633704},{"_id":"themes/NexT2/source/lib/fancybox/source/jquery.fancybox.js","hash":"fec45d19179030b8f43ebd0eabc5467892c14136","modified":1689930367366},{"_id":"themes/NexT2/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"fec45d19179030b8f43ebd0eabc5467892c14136","modified":1689930367367},{"_id":"themes/NexT2/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1689930633703},{"_id":"themes/NexT2/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1689930633705},{"_id":"source/_posts/iOS Reveal2Loader修复版（iOS13修复）/QQ20190225-124715@2x.png","hash":"a2b00fd617b60b85c4205118bc1308039c8575e7","modified":1689930633571},{"_id":"themes/NexT2/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1689930350975},{"_id":"themes/NexT2/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1689930356722},{"_id":"source/_posts/iOS Reveal2Loader修复版（iOS13修复）/QQ20190225-124731@2x.png","hash":"17a5a8f3825b0a57af63f06607bb81345e6087d7","modified":1689930633573},{"_id":"source/images/about_me.jpg","hash":"13d2440509800728685f76d862905c3ceec3ddd5","modified":1689930633589},{"_id":"source/images/spider/server.gif","hash":"527ea346ca2f294e3036b14e8a935c6156602b9c","modified":1689930633650},{"_id":"source/images/spider/mobile.gif","hash":"0f1dd659c098a88673d9189f0d9785788dceace6","modified":1689930633642},{"_id":"public/atom.xml","hash":"4be30b89abf432f75c1e9fcb03fa87b062d01afc","modified":1689936105851},{"_id":"public/search.xml","hash":"f07d6de82e4319223e3bc0c243d5df82b895f7f0","modified":1689936105851},{"_id":"public/baidusitemap.xml","hash":"079a8a1a18aedcf8d72e1d5bb91ed4299e286a39","modified":1689936105851},{"_id":"public/sitemap.xml","hash":"0807148531e94b66e8e918feaca94f400b8f68b5","modified":1689936105851},{"_id":"public/sitemap.txt","hash":"78d3f0ba0abafd34d62522341a9ca0d97e3e58c6","modified":1689936105851},{"_id":"public/404.html","hash":"b4fe6554e9b77a515a2a7b6a9d571930bb4d45ab","modified":1689936105851},{"_id":"public/archives/index.html","hash":"99116e7215f4e246cc0ef575045f6cb95be6ef80","modified":1689936105851},{"_id":"public/categories/index.html","hash":"835b9d4059ec3182f4a2287edba421404993a0a1","modified":1689936105851},{"_id":"public/about/index.html","hash":"5fd10779dec0600c7b490ac41c2d6f81f14d6494","modified":1689936105851},{"_id":"public/tags/index.html","hash":"daaf9e409e33fe2841b1e3a03aee6de3e39e5431","modified":1689936105851},{"_id":"public/2020/09/14/iOS Reveal2Loader修复版（iOS13修复）/index.html","hash":"b363ccf1ab44887635c01f58fd3149de030b11ff","modified":1689936105851},{"_id":"public/2019/09/11/如何利用RunLoop的知识来监测APP卡顿/index.html","hash":"86626932e616a899b65d19cf78fa84a61afd6113","modified":1689936105851},{"_id":"public/2019/03/12/【转载】iOS进程-线程-间是如何通信的/index.html","hash":"7147fdda2521278faee3450935a9ca398436e199","modified":1689936105851},{"_id":"public/2018/06/22/iOS底层之Block/index.html","hash":"89ac2939507245eb0c140fbd91ac7f60338a71c0","modified":1689936105851},{"_id":"public/2018/04/20/iOS多线程编程之GCD-更新swift3-0用法/index.html","hash":"071c938cf2f486a8cda1c8effe181d28381ba1f8","modified":1689936105851},{"_id":"public/2018/03/15/AutoreleasePool源码分析/index.html","hash":"5c24f82b7ac9210a93462b626f88fc7259d0595c","modified":1689936105851},{"_id":"public/2018/04/20/iOS底层之RunLoop/index.html","hash":"28ecdf716e368ea99e4bedaa50446d5f4a11c718","modified":1689936105851},{"_id":"public/2017/04/11/Notification与多线程/index.html","hash":"3e4c58fcc2abb6c8be916621d2a9a5e70cab8529","modified":1689936105851},{"_id":"public/2017/02/24/iOS多线程编程之线程锁/index.html","hash":"20803b3c45f00e15f72a8d6acbc788a91041ab57","modified":1689936105851},{"_id":"public/archives/2017/index.html","hash":"b0cd7af957e5956d68299d755ee469524478da01","modified":1689936105851},{"_id":"public/archives/2017/02/index.html","hash":"3fad21edc924718ffee957b474fc611d93dc28e0","modified":1689936105851},{"_id":"public/archives/2017/04/index.html","hash":"b48aae149563fc4a90e3c2b463fc22d59345c394","modified":1689936105851},{"_id":"public/archives/2018/index.html","hash":"6b7815c1c7e2e201f367ab2707b7c9a5baf7da6c","modified":1689936105851},{"_id":"public/archives/2018/03/index.html","hash":"e64b371174776f719833826fed34b129faa0b651","modified":1689936105851},{"_id":"public/archives/2018/04/index.html","hash":"eadcd4ecfc4d432f7d7e892d28fbb83276f938f9","modified":1689936105851},{"_id":"public/archives/2018/06/index.html","hash":"fadab6ad7af4f0b7b9509344f3b302454a0e1d96","modified":1689936105851},{"_id":"public/archives/2019/index.html","hash":"8eed5f2e0c7b69808f0e6f1d8a6badf6d7ffa157","modified":1689936105851},{"_id":"public/archives/2019/03/index.html","hash":"48ba6843b42301a72afc09c9c6e3b80a5396996e","modified":1689936105851},{"_id":"public/archives/2019/09/index.html","hash":"8cfe1ba57d01d2922d9c952f50db03b2ddd4a743","modified":1689936105851},{"_id":"public/archives/2020/index.html","hash":"55d5aa07a3256f48f96b4a79749842e0489a4233","modified":1689936105851},{"_id":"public/archives/2020/09/index.html","hash":"d08fadbd2569255ca6f44852624371554482f007","modified":1689936105851},{"_id":"public/categories/底层原理/index.html","hash":"e60acafb25209600ec52ea807472a23899e61bfb","modified":1689936105851},{"_id":"public/categories/多线程/index.html","hash":"8ffda21edfa8ebd8e18c06960bb8147325f7d4a7","modified":1689936105851},{"_id":"public/categories/越狱插件/index.html","hash":"29d10620e1be58b407636499cc22704623c3ca00","modified":1689936105851},{"_id":"public/categories/RunLoop/index.html","hash":"f180d49acf58aa0716891122cfaaacb635971882","modified":1689936105851},{"_id":"public/index.html","hash":"54a808d0504f5d0ec76389d90d8cf5f44ff8d2a9","modified":1689936105851},{"_id":"public/tags/Autorelease/index.html","hash":"30da908e65e78b061e7e8b28f866fb71f5de8066","modified":1689936105851},{"_id":"public/tags/RunLoop/index.html","hash":"a66a3ecef34827b89a5c77ecc54b9e2d8a526f0b","modified":1689936105851},{"_id":"public/tags/底层原理/index.html","hash":"fc0e7656612a97a73f1fa4319e00e0ecc422cd67","modified":1689936105851},{"_id":"public/tags/通知/index.html","hash":"4d5d936c2a44c79a79a212d162a1251335a48460","modified":1689936105851},{"_id":"public/tags/多线程/index.html","hash":"96a3c39314bb77bb4ff451e8a1c9aabbeec50658","modified":1689936105851},{"_id":"public/tags/GCD/index.html","hash":"6b5a5e69d044efa3da7d7fab9c58216489ab4a90","modified":1689936105851},{"_id":"public/tags/iOS线程锁/index.html","hash":"bad7ef667e656182b94e4da1c2c160c2862dad13","modified":1689936105851},{"_id":"public/tags/Reveal2Loader/index.html","hash":"46644aaeecd089db1958a38d54a7f2fcd62de7a2","modified":1689936105851},{"_id":"public/tags/越狱插件/index.html","hash":"4929de593a48f3103959a875bce312adc13bee09","modified":1689936105851},{"_id":"public/tags/Block/index.html","hash":"e0780787d0d29245708d527758512363fa64586c","modified":1689936105851},{"_id":"public/tags/转载/index.html","hash":"fd255118cea1c974639a38580de62d23ab6ac707","modified":1689936105851},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1689936105851},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1689936105851},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1689936105851},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1689936105851},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1689936105851},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1689936105851},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1689936105851},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1689936105851},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1689936105851},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1689936105851},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1689936105851},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1689936105851},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1689936105851},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1689936105851},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1689936105851},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1689936105851},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1689936105851},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1689936105851},{"_id":"public/lib/algolia-instant-search/LICENSE","hash":"b29db4c99aa5b8d574026f68804051ff4b75466e","modified":1689936105851},{"_id":"public/lib/fancybox/LICENSE","hash":"8624bcdae55baeef00cd11d5dfcfa60f68710a02","modified":1689936105851},{"_id":"public/lib/canvas-nest/LICENSE","hash":"b29db4c99aa5b8d574026f68804051ff4b75466e","modified":1689936105851},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1689936105851},{"_id":"public/lib/three/LICENSE","hash":"b29db4c99aa5b8d574026f68804051ff4b75466e","modified":1689936105851},{"_id":"public/lib/reading_progress/LICENSE","hash":"b29db4c99aa5b8d574026f68804051ff4b75466e","modified":1689936105851},{"_id":"public/lib/three/yarn.lock","hash":"9c71c0a7c033fc709c1e683157b1f12037024694","modified":1689936105851},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1689936105851},{"_id":"public/CNAME","hash":"e60e8bb34e5b0ae17dd71745f0b9b11ea3a58523","modified":1689936105851},{"_id":"public/robots.txt","hash":"6c4c15384073cab7cd56d978e57156937518e7b1","modified":1689936105851},{"_id":"public/images/background_cell.png","hash":"3c8de505c87e0037ccbaf117ab5d90d4463c62d1","modified":1689936105851},{"_id":"public/images/head.png","hash":"c9b79011dde2c62e4fd174c35a49286f6c788383","modified":1689936105851},{"_id":"public/images/alipay.png","hash":"64d603a7f38cea8405ef61dd1f6007a956e49535","modified":1689936105851},{"_id":"public/images/stringFromArray.png","hash":"a80fb929a129b6e998d10d6277bfb1b3567fe1cd","modified":1689936105851},{"_id":"public/images/wechat.jpg","hash":"76361640a7d552f19685b02747622f9ff54d9ee7","modified":1689936105851},{"_id":"public/images/jenkins/inject-environment-varibles.png","hash":"a0cb9285c7311f4ae763dd12b1f52b271ed080ee","modified":1689936105851},{"_id":"public/2019/09/11/如何利用RunLoop的知识来监测APP卡顿/图片 1.png","hash":"2f11ab9a0b1329831bc8b80b50a8d033e4ebe361","modified":1689936105851},{"_id":"public/2018/04/20/iOS底层之RunLoop/RunLoop_0.png","hash":"dc03b7f7ea3f9a9c3076bb6d13afcd98b1d52fb6","modified":1689936105851},{"_id":"public/2018/04/20/iOS底层之RunLoop/RunLoop_4.png","hash":"6f5b39948e4a0c57683c00a0a90fef5fbf303c04","modified":1689936105851},{"_id":"public/2018/04/20/iOS底层之RunLoop/RunLoop_3.png","hash":"fcc0b12eae77f5c585a25b783c7c86e8f8347f35","modified":1689936105851},{"_id":"public/assets/algolia/algoliasearchLite.min.js","hash":"284416885e4e80e27fa4eae6fc305f4de15b914c","modified":1689936105851},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1689936105851},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1689936105851},{"_id":"public/images/pages_tag.png","hash":"3b6fb77957f03771fa3c101f6ba6784e684733a8","modified":1689936105851},{"_id":"public/images/tect_banner.jpg","hash":"26a4b2ad43312f902495c90ce5bd2bec8a8bbc0b","modified":1689936105851},{"_id":"public/images/background/2.jpg","hash":"617a41460d30bcf2acea971e696e66d9119f4938","modified":1689936105851},{"_id":"public/2019/03/12/【转载】iOS进程-线程-间是如何通信的/articlex.png","hash":"d52bac7cf88b62fb09c1a1973187d66cc97f29a8","modified":1689936105851},{"_id":"public/2018/04/20/iOS底层之RunLoop/RunLoop_network.png","hash":"ff619c5db6ae912845cb402326e96069768366ac","modified":1689936105851},{"_id":"public/assets/algolia/algoliasearchLite.js","hash":"e56ad6b82caf69066de545201014291fc961635e","modified":1689936105851},{"_id":"public/assets/algolia/algoliasearch.min.js","hash":"a3b131a9a47ccc16f4dd8988fabb6d306548db2f","modified":1689936105851},{"_id":"public/lib/algolia-instant-search/README.html","hash":"ba23ca570ed52897a4eb862f7c49fbcc8b3c3be0","modified":1689936105851},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1689936105851},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1689936105851},{"_id":"public/lib/canvas-nest/README.html","hash":"8a3011652a46a9bab7c1ea42eb6c4c4f86bb2265","modified":1689936105851},{"_id":"public/lib/fancybox/README.html","hash":"51b37789137ebf342598033ef18efa29ba75b278","modified":1689936105851},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1689936105851},{"_id":"public/lib/reading_progress/package.json","hash":"e404a0bdf26df62eb89173c6fe5f5824345801c5","modified":1689936105851},{"_id":"public/lib/reading_progress/reading_progress.min.js","hash":"98af8d99819882904f9b1a9254bebf40602e1843","modified":1689936105851},{"_id":"public/lib/three/README.html","hash":"804087692c6c316ef0073c2556419f6d7ccd2007","modified":1689936105851},{"_id":"public/lib/reading_progress/reading_progress.js","hash":"174678a8e2a24763e3fe8b9c25496fdf6ee0220b","modified":1689936105851},{"_id":"public/lib/reading_progress/README.html","hash":"8d1a9a05ab526757472615263c0e3b2698814ce4","modified":1689936105851},{"_id":"public/lib/three/gulpfile.js","hash":"edd1868be72fde796b0b1f3a7a0316b3c896962a","modified":1689936105851},{"_id":"public/lib/three/package.json","hash":"d64e9f4ce441b50e48aa0993e190481223665989","modified":1689936105851},{"_id":"public/js/src/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1689936105851},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1689936105851},{"_id":"public/js/src/bootstrap.js","hash":"1c41508b83cb0c4512e64b4d63afa1be954ce8ef","modified":1689936105851},{"_id":"public/js/src/clipboard.min.js","hash":"eb41c0e88206dda6f0fd8dfbbeefdc0829a9d13d","modified":1689936105851},{"_id":"public/js/src/copy_code.js","hash":"9921c9fda24c365fa936c725660aac90f8358863","modified":1689936105851},{"_id":"public/js/src/custom.js","hash":"e026b7ca3480df9142e7b27bfe85c25deed70705","modified":1689936105851},{"_id":"public/js/src/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1689936105851},{"_id":"public/js/src/exturl.js","hash":"10f45d0f862fa8eb5d271a7a3fbefd7782813ab6","modified":1689936105851},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1689936105851},{"_id":"public/js/src/motion.js","hash":"86a2f620df85af2d102b7383c71582879c3b403c","modified":1689936105851},{"_id":"public/js/src/love.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1689936105851},{"_id":"public/js/src/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1689936105851},{"_id":"public/js/src/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1689936105851},{"_id":"public/js/src/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1689936105851},{"_id":"public/js/src/utils.js","hash":"e437eff1d3781c4a1aec9ff2060565524a37c983","modified":1689936105851},{"_id":"public/lib/fancybox/source/jquery.fancybox.min.css","hash":"84adea69673c392c1d34a5a316e8e5960aa348b5","modified":1689936105851},{"_id":"public/lib/three/src/canvas_lines.js","hash":"650310ff6783671f8ceccf01f840b20d9c87b491","modified":1689936105851},{"_id":"public/lib/three/src/canvas_sphere.js","hash":"7614790c67d3e79e3390fe688f6b01afad7e3bb1","modified":1689936105851},{"_id":"public/lib/three/src/three-waves.js","hash":"e98e442f14920e9fb8691846dca3a2225d403048","modified":1689936105851},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1689936105851},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1689936105851},{"_id":"public/js/src/schemes/pisces.js","hash":"ab3932fa3637a5e23ae6287e78fbfeb54f2c85d2","modified":1689936105851},{"_id":"public/css/main.css","hash":"dce9c55bbbddb6265cd6b6e372a0918badd15621","modified":1689936105851},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"333fed4c256c7081e07c7844c097b7970b45b248","modified":1689936105851},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1689936105851},{"_id":"public/lib/three/canvas_lines.min.js","hash":"97f0e67570574dc8597c5819970508d4e7f7af25","modified":1689936105851},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1689936105851},{"_id":"public/lib/three/three-waves.min.js","hash":"704e860183acbaaf8de1be65fe5c958e8105f4bf","modified":1689936105851},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1689936105851},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1689936105851},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1689936105851},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1689936105851},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"a5913612c237bb7443c6006a386edd775201d423","modified":1689936105851},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"fec45d19179030b8f43ebd0eabc5467892c14136","modified":1689936105851},{"_id":"public/lib/fancybox/source/jquery.fancybox.min.js","hash":"b85b75426ff7569d54a1f69689895315e80ed85d","modified":1689936105851},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1689936105851},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1689936105851},{"_id":"public/lib/three/lib/CanvasRenderer.js","hash":"cf8e1ce6e884023ad0d692cf30f399862407fb40","modified":1689936105851},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"fec45d19179030b8f43ebd0eabc5467892c14136","modified":1689936105851},{"_id":"public/lib/three/lib/Projector.js","hash":"1ad16e96cea2a8a9155bb429c83ef9bdd341ce99","modified":1689936105851},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1689936105851},{"_id":"public/images/wechatpay.png","hash":"70c186d2176e778ce1f9daacaf90e69d7a11eb1d","modified":1689936105851},{"_id":"public/2019/09/11/如何利用RunLoop的知识来监测APP卡顿/5f51c5e05085badb689f01b1e63e1c7d.png","hash":"2c82df0e7f7fb4244353442c26fe3c25ba2f8eb2","modified":1689936105851},{"_id":"public/images/spider/app.png","hash":"fb0f7ea0bea54fba911066fbaaa87cc461e3b172","modified":1689936105851},{"_id":"public/2018/04/20/iOS底层之RunLoop/RunLoop_1.png","hash":"74a7af62610b92b8373b38a260815a370d8bfca0","modified":1689936105851},{"_id":"public/assets/algolia/algoliasearch.js","hash":"6948fcdf071e4983e784e8c458cf201536f77792","modified":1689936105851},{"_id":"public/images/background/city.jpg","hash":"f5e94085efcf0fe50cfe6d46c519a5a67b45124c","modified":1689936105851},{"_id":"public/images/head_1.png","hash":"204ba5a511c36039726e63bb293de9998214c1a0","modified":1689936105851},{"_id":"public/2018/03/15/AutoreleasePool源码分析/双向链表.png","hash":"cd554bb5e353c56a933c44b0be128a165cf86929","modified":1689936105851},{"_id":"public/2020/09/14/iOS Reveal2Loader修复版（iOS13修复）/QQ20190225-124715@2x.png","hash":"a2b00fd617b60b85c4205118bc1308039c8575e7","modified":1689936105851},{"_id":"public/2020/09/14/iOS Reveal2Loader修复版（iOS13修复）/QQ20190225-124731@2x.png","hash":"17a5a8f3825b0a57af63f06607bb81345e6087d7","modified":1689936105851},{"_id":"public/images/about_me.jpg","hash":"13d2440509800728685f76d862905c3ceec3ddd5","modified":1689936105851},{"_id":"public/images/spider/server.gif","hash":"527ea346ca2f294e3036b14e8a935c6156602b9c","modified":1689936105851},{"_id":"public/images/spider/mobile.gif","hash":"0f1dd659c098a88673d9189f0d9785788dceace6","modified":1689936105851}],"Category":[{"name":"底层原理","_id":"clkcgbp570004pfo7bmf10re4"},{"name":"多线程","_id":"clkcgbp5b000cpfo75b7ievdp"},{"name":"越狱插件","_id":"clkcgbp5e000lpfo7czm65f0p"},{"name":"RunLoop","_id":"clkcgbp5j001dpfo7aac0ai67"}],"Data":[],"Page":[{"_content":"<!doctype html>\n<html class=\"theme-next pisces use-motion\" lang=\"zh-Hans\">\n\n<head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\" />\n    <meta http-equiv=\"Cache-Control\" content=\"no-transform\" />\n    <meta http-equiv=\"Cache-Control\" content=\"no-siteapp\" />\n</head>\n\n<body id=\"not_found\">\n    <script type=\"text/javascript\" src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\" charset=\"utf-8\"\n        homePageUrl=\"/\" homePageName=\"返回博客主页\"></script>\n    <script type=\"text/javascript\" src=\"https://qzone.qq.com/gy/404/data.js\" charset=\"utf-8\"></script>\n    <script type=\"text/javascript\" src=\"https://qzone.qq.com/gy/404/page.js\" charset=\"utf-8\"></script>\n</body>\n\n</html>","source":"404.html","raw":"<!doctype html>\n<html class=\"theme-next pisces use-motion\" lang=\"zh-Hans\">\n\n<head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\" />\n    <meta http-equiv=\"Cache-Control\" content=\"no-transform\" />\n    <meta http-equiv=\"Cache-Control\" content=\"no-siteapp\" />\n</head>\n\n<body id=\"not_found\">\n    <script type=\"text/javascript\" src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\" charset=\"utf-8\"\n        homePageUrl=\"/\" homePageName=\"返回博客主页\"></script>\n    <script type=\"text/javascript\" src=\"https://qzone.qq.com/gy/404/data.js\" charset=\"utf-8\"></script>\n    <script type=\"text/javascript\" src=\"https://qzone.qq.com/gy/404/page.js\" charset=\"utf-8\"></script>\n</body>\n\n</html>","date":"2023-07-21T09:10:33.567Z","updated":"2023-07-21T09:10:33.567Z","path":"404.html","title":"","comments":1,"layout":"page","_id":"clkcgbp510000pfo7ga61c9p3","content":"<!doctype html>\n<html class=\"theme-next pisces use-motion\" lang=\"zh-Hans\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\">\n    <meta http-equiv=\"Cache-Control\" content=\"no-transform\">\n    <meta http-equiv=\"Cache-Control\" content=\"no-siteapp\">\n</head>\n\n<body id=\"not_found\">\n    <script type=\"text/javascript\" src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\" charset=\"utf-8\" homepageurl=\"/\" homepagename=\"返回博客主页\"></script>\n    <script type=\"text/javascript\" src=\"https://qzone.qq.com/gy/404/data.js\" charset=\"utf-8\"></script>\n    <script type=\"text/javascript\" src=\"https://qzone.qq.com/gy/404/page.js\" charset=\"utf-8\"></script>\n</body>\n\n</html>","site":{"data":{}},"length":0,"excerpt":"","more":"<!doctype html>\n<html class=\"theme-next pisces use-motion\" lang=\"zh-Hans\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\">\n    <meta http-equiv=\"Cache-Control\" content=\"no-transform\">\n    <meta http-equiv=\"Cache-Control\" content=\"no-siteapp\">\n</head>\n\n<body id=\"not_found\">\n    <script type=\"text/javascript\" src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\" charset=\"utf-8\" homepageurl=\"/\" homepagename=\"返回博客主页\"></script>\n    <script type=\"text/javascript\" src=\"https://qzone.qq.com/gy/404/data.js\" charset=\"utf-8\"></script>\n    <script type=\"text/javascript\" src=\"https://qzone.qq.com/gy/404/page.js\" charset=\"utf-8\"></script>\n</body>\n\n</html>"},{"title":"archives","date":"2019-02-22T08:30:40.000Z","type":"archives","comments":0,"_content":"","source":"archives/index.md","raw":"---\ntitle: archives\ndate: 2019-02-22 16:30:40\ntype: \"archives\"\ncomments: false\n---\n","updated":"2023-07-21T09:10:33.580Z","path":"archives/index.html","layout":"page","_id":"clkcgbp560002pfo7bk5x50v6","content":"","site":{"data":{}},"length":0,"excerpt":"","more":""},{"title":"分类","date":"2019-02-22T08:29:49.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2019-02-22 16:29:49\ntype: \"categories\"\ncomments: false\n---\n","updated":"2023-07-21T09:10:33.580Z","path":"categories/index.html","layout":"page","_id":"clkcgbp580006pfo7grz4d0sz","content":"","site":{"data":{}},"length":0,"excerpt":"","more":""},{"title":"关于我","date":"2019-02-22T08:31:25.000Z","type":"about","comments":0,"_content":"","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2019-02-22 16:31:25\ntype: \"about\"\ncomments: false\n---\n","updated":"2023-07-21T09:10:33.579Z","path":"about/index.html","layout":"page","_id":"clkcgbp590008pfo75tsx8m2f","content":"","site":{"data":{}},"length":0,"excerpt":"","more":""},{"title":"标签","date":"2019-02-22T08:56:34.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2019-02-22 16:56:34\ntype: \"tags\"\ncomments: false\n---\n","updated":"2023-07-21T09:10:33.651Z","path":"tags/index.html","layout":"page","_id":"clkcgbp5a000apfo77l8m12hc","content":"","site":{"data":{}},"length":0,"excerpt":"","more":""}],"Post":[{"title":"AutoreleasePool源码分析","date":"2018-03-15T02:53:48.000Z","top":0,"need_not_copyright":true,"banner_img":null,"_content":"\n> AutoreleasePool（自动释放池）是OC中的一种内存自动回收机制，它可以延迟加入AutoreleasePool中的变量release的时机。在正常情况下，创建的变量会在超出其作用域的时候release，但是如果将变量加入AutoreleasePool，那么release将延迟执行。\n\n<!-- more -->\n\n需要了解AutoreleasePool的工作原理，我们需要知道它的底层到底做了什么事情，那我们就先从汇编代码入手，新建一个命令行工程，创建一个新的对象继承自NSObject：\n\n```\n#import <Foundation/Foundation.h>\n#import \"object.h\"\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        object *oc = [[object alloc] init]];\n    }\n    return 0;\n}\n\n```\n我们利用命令将OC代码重写为c++代码：\n\n```\nxcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m\n```\n\n我们可以大约得到3万2千行的c++代码的cpp文件，但是不要紧，因为最终的核心代码在该cpp的最底部：\n\n```\nint main(int argc, const char * argv[]) {\n    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; \n\n        object *o1 = ((object *(*)(id, SEL))(void *)objc_msgSend)((id)((object *(*)(id, SEL))(void *)objc_msgSend)((id)((object *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"object\"), sel_registerName(\"alloc\")), sel_registerName(\"init\")), sel_registerName(\"autorelease\"));\n    }\n    return 0;\n}\n\n```\n\n中间的代码层是object对象的创建过程，发送objc_msgSend消息创建对象。那其实最核心的代码就在下面这这两句上了\n\n>__AtAutoreleasePool __autoreleasepool; \n\n# __AtAutoreleasePool\n\n我们在cpp文件中搜索__AtAutoreleasePool会找到如下代码,__AtAutoreleasePool具体定义如下：\n\n```\nextern \"C\" __declspec(dllimport) void * objc_autoreleasePoolPush(void);\nextern \"C\" __declspec(dllimport) void objc_autoreleasePoolPop(void *);\n\nstruct __AtAutoreleasePool {\n  __AtAutoreleasePool() { // 构造函数，在创建结构体的时候调用\n      atautoreleasepoolobj = objc_autoreleasePoolPush();\n  }\n  ~__AtAutoreleasePool() { // 析构函数，在结构体销毁的时候调用\n    objc_autoreleasePoolPop(atautoreleasepoolobj);\n  }\n  void * atautoreleasepoolobj;\n};\n```\n上面两个调用，分别是构造函数和析构函数，根据构造函数和析构函数的特点：自动局部变量的构造函数是在程序执行到声明这个对象的位置时调用的，而对应的析构函数是在程序执行到离开这个对象的作用域时调用。苹果实际上是通过声明一个__AtAutoreleasePool类型的局部变量__autoreleasepool实现了@autoreleasepool{},那么实际上单个自动释放池的执行过程就是：\n\n```\nobjc_autoreleasePoolPush() —> [object autorelease] —> objc_autoreleasePoolPop(void *)\n```\n\n\n想了解objc_autoreleasePoolPush和objc_autoreleasePoolPop具体都做了些什么，其实很简单，我们只要到runtime->NSObject.mm的源码中就能窥探它的真是面目了，这里我们分析的runtime源码是objc-750的版本。\n在源码中我们可以发现这样一段代码：\n\n```\nvoid *objc_autoreleasePoolPush(void) {\n    return AutoreleasePoolPage::push();\n}\n\nvoid objc_autoreleasePoolPop(void *ctxt) {\n    AutoreleasePoolPage::pop(ctxt);\n}\n```\n\nobjc_autoreleasePoolPush和objc_autoreleasePoolPop分别是由AutoreleasePoolPage调用了push方法入栈和pop方法出栈，其本质实际上是AutoreleasePoolPage对应的静态方法push和pop的封装。那么问题就显而易见了，如果要知道这个push和pop方法到底做了什么，我们还得从源码里获取到AutoreleasePoolPage相关的内容以及其实现原理。\n\n# AutoreleasePoolPage定义\n\n在runtime源码中对AutoreleasePoolPage的定义是这样的：\n\n```\nclass AutoreleasePoolPage  {\n    // EMPTY_POOL_PLACEHOLDER is stored in TLS when exactly one pool is \n    // pushed and it has never contained any objects. This saves memory \n    // when the top level (i.e. libdispatch) pushes and pops pools but \n    // never uses them.\n#   define EMPTY_POOL_PLACEHOLDER ((id*)1)\n\n#   define POOL_BOUNDARY nil\n    static pthread_key_t const key = AUTORELEASE_POOL_KEY;\n    static uint8_t const SCRIBBLE = 0xA3;  // 0xA3A3A3A3 after releasing\n    static size_t const SIZE = \n#if PROTECT_AUTORELEASEPOOL\n        PAGE_MAX_SIZE;  // must be multiple of vm page size\n#else\n        PAGE_MAX_SIZE;  // size and alignment, power of 2\n#endif\n    static size_t const COUNT = SIZE / sizeof(id);\n\n    magic_t const magic;\n    id *next;\n    pthread_t const thread;\n    AutoreleasePoolPage * const parent;\n    AutoreleasePoolPage *child;\n    uint32_t const depth;\n    uint32_t hiwat;\n}\n```\n去除那些静态成员变量,AutoreleasePoolPage的成员变量的解释如下：\n\n```\nclass AutoreleasePoolPage  {\n    magic_t const magic; //检查校验完整性的变量\n    id *next; //指向新添加到AutoreleasePoolPage的对象\n    pthread_t const thread; //AutoreleasePoolPage当前所在的线程，AutoreleasePool是按线程一一对应的（结构中的thread指针指向当前线程）\n    AutoreleasePoolPage * const parent; //指向上一个AutoreleasePoolPage\n    AutoreleasePoolPage *child; //指向下一个AutoreleasePoolPage\n    uint32_t const depth; //depth 链表的深度，节点个数\n    uint32_t hiwat; //数据容纳的一个上限\n}\n```\n\n这里需要注意的是AutoreleasePoolPage有一个成员变量是PAGE_MAX_SIZE，这个表示一个AutoreleasePoolPage最大内存大小，这个宏其实在上面可以找得到，也就是说一个AutoreleasePoolPage的最大内存大小是PAGE_MAX_SIZE（也就是4096）：\n\n```\n#define I386_PGBYTES        4096        /* bytes per 80386 page */\n#define I386_PGSHIFT        12      /* bitshift for pages */\n\n#define PAGE_SIZE       I386_PGBYTES\n#define PAGE_SHIFT      I386_PGSHIFT\n#define PAGE_MASK       (PAGE_SIZE - 1)\n\n#define PAGE_MAX_SHIFT          PAGE_SHIFT\n#define PAGE_MAX_SIZE           PAGE_SIZE\n#define PAGE_MAX_MASK           PAGE_MASK\n\n#define PAGE_MIN_SHIFT          PAGE_SHIFT\n#define PAGE_MIN_SIZE           PAGE_SIZE\n#define PAGE_MIN_MASK           PAGE_MASK\n```\n# AutoreleasePoolPage工作原理\n\n每个AutoreleasePoolPage对象的内存大小事4096字节，除去AutoreleasePoolPage的成员变量所占用的空间，剩下的空间用来存放Autorelease对象的地址，知道了AutoreleasePoolPage的定义，现在我们回到objc_autoreleasePoolPush这个方法，我们发现了，实际上这个方法是调用了AutoreleasePoolPage的push方法：\n\n```\nstatic inline void *push() {\n    id *dest;\n    if (DebugPoolAllocation) {\n        // Each autorelease pool starts on a new pool page.\n        dest = autoreleaseNewPage(POOL_BOUNDARY);\n    } else {\n        dest = autoreleaseFast(POOL_BOUNDARY);\n    }\n    assert(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);\n    return dest;\n}\n```\n细心的你肯定会发现，在调用push方法的时候autoreleaseFast会将一个POOL_BOUNDARY的对象放在临界点上。POOL_BOUNDARY这个对象属于比较关键的对象，关系到AutoreleasePoolPage的释放过程。\n\n```\nstatic inline id *autoreleaseFast(id obj) {\n    AutoreleasePoolPage *page = hotPage();\n    if (page && !page->full()) {\n        return page->add(obj);\n    } else if (page) {\n        return autoreleaseFullPage(obj, page);\n    } else {\n        return autoreleaseNoPage(obj);\n    }\n}\n```\n\n上述方法分三种情况选择不同的代码执行：\n\n1、有 hotPage 并且当前 page 不满，调用 page->add(obj) 方法将对象添加至 AutoreleasePoolPage 的栈中\n2、有 hotPage 并且当前 page 已满，调用 autoreleaseFullPage 初始化一个新的页，调用 page->add(obj) 方法将对象添加至 AutoreleasePoolPage 的栈中\n3、无 hotPage，调用 autoreleaseNoPage 创建一个 hotPage，调用 page->add(obj) 方法将对象添加至 AutoreleasePoolPage 的栈中\n\n最后的都会调用 page->add(obj) 将对象添加到自动释放池中。而hotPage 可以理解为当前正在使用的 AutoreleasePoolPage。\n\n接下来我们看一看objc_autoreleasePoolPop方法调用pop的实现：\n\n```\nstatic inline void pop(void *token) {\n    AutoreleasePoolPage *page;\n    id *stop;\n\n    if (token == (void*)EMPTY_POOL_PLACEHOLDER) {\n        // Popping the top-level placeholder pool.\n        if (hotPage()) {\n            // Pool was used. Pop its contents normally.\n            // Pool pages remain allocated for re-use as usual.\n            pop(coldPage()->begin());\n        } else {\n            // Pool was never used. Clear the placeholder.\n            setHotPage(nil);\n        }\n        return;\n    }\n\n    page = pageForPointer(token);\n    stop = (id *)token;\n    if (*stop != POOL_BOUNDARY) {\n        if (stop == page->begin()  &&  !page->parent) {\n            // Start of coldest page may correctly not be POOL_BOUNDARY:\n            // 1. top-level pool is popped, leaving the cold page in place\n            // 2. an object is autoreleased with no pool\n        } else {\n            // Error. For bincompat purposes this is not \n            // fatal in executables built with old SDKs.\n            return badPop(token);\n        }\n    }\n\n    if (PrintPoolHiwat) printHiwat();\n\n    page->releaseUntil(stop);\n\n    // memory: delete empty children\n    if (DebugPoolAllocation  &&  page->empty()) {\n        // special case: delete everything during page-per-pool debugging\n        AutoreleasePoolPage *parent = page->parent;\n        page->kill();\n        setHotPage(parent);\n    } else if (DebugMissingPools  &&  page->empty()  &&  !page->parent) {\n        // special case: delete everything for pop(top) \n        // when debugging missing autorelease pools\n        page->kill();\n        setHotPage(nil);\n    } \n    else if (page->child) {\n        // hysteresis: keep one empty child if page is more than half full\n        if (page->lessThanHalfFull()) {\n            page->child->kill();\n        }\n        else if (page->child->child) {\n            page->child->child->kill();\n        }\n    }\n}\n```\n\n顺着源码一步一步找就会发现，autorelease函数和push函数一样，关键代码都是调用autoreleaseFast函数向自动释放池的链表栈中添加一个对象，不过push函数的入栈的是一个边界对象，而autorelease函数入栈的是需要加入autoreleasepool的对象。自动释放池释放是传入 push 返回的边界对象（POOL_BOUNDARY）,autoreleasepool在调用autorelease时逐渐kill存在在autoreleasepool中的对象的地址，直到找到POOL_BOUNDARY对象所在的地址才会停止。\n\n那么这就衍生了一个问题，如果AutoreleasePoolPage在添加需要释放的对象的地址超过了4096的空间或者是说有多个AutoreleasePoolPage的时候它是如何存入需要释放对象的地址，又是如何一层一层的释放的呢？\n\n# AutoreleasePoolPage双向链表\n\n其实AutoreleasePoolPage并没有单独的结构，而是由若干个AutoreleasePoolPage以双向链表的形式组合而成的栈结构在AutoreleasePoolPage的成员变量内部，我们可以清晰的看到有两个成员变量：\n\n```\n AutoreleasePoolPage * const parent; //指向上一个AutoreleasePoolPage\n AutoreleasePoolPage *child; //指向下一个AutoreleasePoolPage\n```\nparent指针和child指针，parent指向的上一个AutoreleasePoolPage的内存空间地址而child则指向下一个AutoreleasePoolPage的内存地址，当一个AutoreleasePoolPage的空间被占满时，会新建一个AutoreleasePoolPage对象，连接链表，后来的autorelease对象在新的page加入。这样无论在添加autorelease对象地址和释放autorelease对象地址的时候都能很准确的找到对应的AutoreleasePoolPage的地址\n![双向链表](双向链表.png)\n\n具体查看AutoreleasePoolPage的工作原理，可以用_objc_autoreleasePoolPrint这个私有函数来查看\n\n# Runloop和AutoreleasePool的关系\n\n我们新建一个空的工程，在viewDidLoad打印[NSRunLoop mainRunLoop]的详细信息，我们会在observers发现两个关于AutoreleasePool的Handler操作_wrapRunLoopWithAutoreleasePoolHandler：\n\n```\nobservers = (\n    \"<CFRunLoopObserver 0x600001f68140 [0x1053f6b68]>{valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x107fe51b1), context = <CFArray 0x600002020330 [0x1053f6b68]>{type = mutable-small, count = 1, values = (\\n\\t0 : <0x7ff476808058>\\n)}}\",\n    \"<CFRunLoopObserver 0x600001f6c1e0 [0x1053f6b68]>{valid = Yes, activities = 0x20, repeats = Yes, order = 0, callout = _UIGestureRecognizerUpdateObserver (0x107bb7473), context = <CFRunLoopObserver context 0x60000056dea0>}\",\n    \"<CFRunLoopObserver 0x600001f68c80 [0x1053f6b68]>{valid = Yes, activities = 0xa0, repeats = Yes, order = 1999000, callout = _beforeCACommitHandler (0x108014dfc), context = <CFRunLoopObserver context 0x7ff475d024b0>}\",\n    \"<CFRunLoopObserver 0x600001f68960 [0x1053f6b68]>{valid = Yes, activities = 0xa0, repeats = Yes, order = 2000000, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv (0x109a136ae), context = <CFRunLoopObserver context 0x0>}\",\n    \"<CFRunLoopObserver 0x600001f68be0 [0x1053f6b68]>{valid = Yes, activities = 0xa0, repeats = Yes, order = 2001000, callout = _afterCACommitHandler (0x108014e75), context = <CFRunLoopObserver context 0x7ff475d024b0>}\",\n    \"<CFRunLoopObserver 0x600001f68b40 [0x1053f6b68]>{valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x107fe51b1), context = <CFArray 0x600002020330 [0x1053f6b68]>{type = mutable-small, count = 1, values = (\\n\\t0 : <0x7ff476808058>\\n)}}\"\n)\n```\n我们查看它的activities，分别是在0x1和0xa0，那这两个分别有代表是什么呢？在runloop 的源码里我们可以找到runloop的相关枚举：\n\n```\ntypedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {\n     kCFRunLoopEntry = (1UL << 0),  // 1\n     kCFRunLoopBeforeTimers = (1UL << 1), // 2\n     kCFRunLoopBeforeSources = (1UL << 2), // 4\n     kCFRunLoopBeforeWaiting = (1UL << 5), // 32\n     kCFRunLoopAfterWaiting = (1UL << 6), // 64\n     kCFRunLoopExit = (1UL << 7), // 128\n     kCFRunLoopAllActivities = 0x0FFFFFFFU\n };\n```\n根据位运算可以的出上述结果：0x1 = 1 等价于kCFRunLoopEntry，0xa0 = 64 + 128 等价于 kCFRunLoopBeforeWaiting | kCFRunLoopExit，意味着runloop会在kCFRunLoopEntry时进行一次push操作，在kCFRunLoopBeforeWaiting进行一次pop操作，然后在进行一次push操作，最后会在kCFRunLoopExit时进行一次pop操作。\n\n也就是说runloop会在即将进行休眠和退出runloop是将AutoreleasePool进行释放。","source":"_posts/AutoreleasePool源码分析.md","raw":"---\ntitle: AutoreleasePool源码分析\ndate: 2018-03-15 10:53:48\ntags: [Autorelease, RunLoop, 底层原理]\ntop: 0\nneed_not_copyright: true\ncategories: 底层原理\nbanner_img:\n---\n\n> AutoreleasePool（自动释放池）是OC中的一种内存自动回收机制，它可以延迟加入AutoreleasePool中的变量release的时机。在正常情况下，创建的变量会在超出其作用域的时候release，但是如果将变量加入AutoreleasePool，那么release将延迟执行。\n\n<!-- more -->\n\n需要了解AutoreleasePool的工作原理，我们需要知道它的底层到底做了什么事情，那我们就先从汇编代码入手，新建一个命令行工程，创建一个新的对象继承自NSObject：\n\n```\n#import <Foundation/Foundation.h>\n#import \"object.h\"\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        object *oc = [[object alloc] init]];\n    }\n    return 0;\n}\n\n```\n我们利用命令将OC代码重写为c++代码：\n\n```\nxcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m\n```\n\n我们可以大约得到3万2千行的c++代码的cpp文件，但是不要紧，因为最终的核心代码在该cpp的最底部：\n\n```\nint main(int argc, const char * argv[]) {\n    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; \n\n        object *o1 = ((object *(*)(id, SEL))(void *)objc_msgSend)((id)((object *(*)(id, SEL))(void *)objc_msgSend)((id)((object *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"object\"), sel_registerName(\"alloc\")), sel_registerName(\"init\")), sel_registerName(\"autorelease\"));\n    }\n    return 0;\n}\n\n```\n\n中间的代码层是object对象的创建过程，发送objc_msgSend消息创建对象。那其实最核心的代码就在下面这这两句上了\n\n>__AtAutoreleasePool __autoreleasepool; \n\n# __AtAutoreleasePool\n\n我们在cpp文件中搜索__AtAutoreleasePool会找到如下代码,__AtAutoreleasePool具体定义如下：\n\n```\nextern \"C\" __declspec(dllimport) void * objc_autoreleasePoolPush(void);\nextern \"C\" __declspec(dllimport) void objc_autoreleasePoolPop(void *);\n\nstruct __AtAutoreleasePool {\n  __AtAutoreleasePool() { // 构造函数，在创建结构体的时候调用\n      atautoreleasepoolobj = objc_autoreleasePoolPush();\n  }\n  ~__AtAutoreleasePool() { // 析构函数，在结构体销毁的时候调用\n    objc_autoreleasePoolPop(atautoreleasepoolobj);\n  }\n  void * atautoreleasepoolobj;\n};\n```\n上面两个调用，分别是构造函数和析构函数，根据构造函数和析构函数的特点：自动局部变量的构造函数是在程序执行到声明这个对象的位置时调用的，而对应的析构函数是在程序执行到离开这个对象的作用域时调用。苹果实际上是通过声明一个__AtAutoreleasePool类型的局部变量__autoreleasepool实现了@autoreleasepool{},那么实际上单个自动释放池的执行过程就是：\n\n```\nobjc_autoreleasePoolPush() —> [object autorelease] —> objc_autoreleasePoolPop(void *)\n```\n\n\n想了解objc_autoreleasePoolPush和objc_autoreleasePoolPop具体都做了些什么，其实很简单，我们只要到runtime->NSObject.mm的源码中就能窥探它的真是面目了，这里我们分析的runtime源码是objc-750的版本。\n在源码中我们可以发现这样一段代码：\n\n```\nvoid *objc_autoreleasePoolPush(void) {\n    return AutoreleasePoolPage::push();\n}\n\nvoid objc_autoreleasePoolPop(void *ctxt) {\n    AutoreleasePoolPage::pop(ctxt);\n}\n```\n\nobjc_autoreleasePoolPush和objc_autoreleasePoolPop分别是由AutoreleasePoolPage调用了push方法入栈和pop方法出栈，其本质实际上是AutoreleasePoolPage对应的静态方法push和pop的封装。那么问题就显而易见了，如果要知道这个push和pop方法到底做了什么，我们还得从源码里获取到AutoreleasePoolPage相关的内容以及其实现原理。\n\n# AutoreleasePoolPage定义\n\n在runtime源码中对AutoreleasePoolPage的定义是这样的：\n\n```\nclass AutoreleasePoolPage  {\n    // EMPTY_POOL_PLACEHOLDER is stored in TLS when exactly one pool is \n    // pushed and it has never contained any objects. This saves memory \n    // when the top level (i.e. libdispatch) pushes and pops pools but \n    // never uses them.\n#   define EMPTY_POOL_PLACEHOLDER ((id*)1)\n\n#   define POOL_BOUNDARY nil\n    static pthread_key_t const key = AUTORELEASE_POOL_KEY;\n    static uint8_t const SCRIBBLE = 0xA3;  // 0xA3A3A3A3 after releasing\n    static size_t const SIZE = \n#if PROTECT_AUTORELEASEPOOL\n        PAGE_MAX_SIZE;  // must be multiple of vm page size\n#else\n        PAGE_MAX_SIZE;  // size and alignment, power of 2\n#endif\n    static size_t const COUNT = SIZE / sizeof(id);\n\n    magic_t const magic;\n    id *next;\n    pthread_t const thread;\n    AutoreleasePoolPage * const parent;\n    AutoreleasePoolPage *child;\n    uint32_t const depth;\n    uint32_t hiwat;\n}\n```\n去除那些静态成员变量,AutoreleasePoolPage的成员变量的解释如下：\n\n```\nclass AutoreleasePoolPage  {\n    magic_t const magic; //检查校验完整性的变量\n    id *next; //指向新添加到AutoreleasePoolPage的对象\n    pthread_t const thread; //AutoreleasePoolPage当前所在的线程，AutoreleasePool是按线程一一对应的（结构中的thread指针指向当前线程）\n    AutoreleasePoolPage * const parent; //指向上一个AutoreleasePoolPage\n    AutoreleasePoolPage *child; //指向下一个AutoreleasePoolPage\n    uint32_t const depth; //depth 链表的深度，节点个数\n    uint32_t hiwat; //数据容纳的一个上限\n}\n```\n\n这里需要注意的是AutoreleasePoolPage有一个成员变量是PAGE_MAX_SIZE，这个表示一个AutoreleasePoolPage最大内存大小，这个宏其实在上面可以找得到，也就是说一个AutoreleasePoolPage的最大内存大小是PAGE_MAX_SIZE（也就是4096）：\n\n```\n#define I386_PGBYTES        4096        /* bytes per 80386 page */\n#define I386_PGSHIFT        12      /* bitshift for pages */\n\n#define PAGE_SIZE       I386_PGBYTES\n#define PAGE_SHIFT      I386_PGSHIFT\n#define PAGE_MASK       (PAGE_SIZE - 1)\n\n#define PAGE_MAX_SHIFT          PAGE_SHIFT\n#define PAGE_MAX_SIZE           PAGE_SIZE\n#define PAGE_MAX_MASK           PAGE_MASK\n\n#define PAGE_MIN_SHIFT          PAGE_SHIFT\n#define PAGE_MIN_SIZE           PAGE_SIZE\n#define PAGE_MIN_MASK           PAGE_MASK\n```\n# AutoreleasePoolPage工作原理\n\n每个AutoreleasePoolPage对象的内存大小事4096字节，除去AutoreleasePoolPage的成员变量所占用的空间，剩下的空间用来存放Autorelease对象的地址，知道了AutoreleasePoolPage的定义，现在我们回到objc_autoreleasePoolPush这个方法，我们发现了，实际上这个方法是调用了AutoreleasePoolPage的push方法：\n\n```\nstatic inline void *push() {\n    id *dest;\n    if (DebugPoolAllocation) {\n        // Each autorelease pool starts on a new pool page.\n        dest = autoreleaseNewPage(POOL_BOUNDARY);\n    } else {\n        dest = autoreleaseFast(POOL_BOUNDARY);\n    }\n    assert(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);\n    return dest;\n}\n```\n细心的你肯定会发现，在调用push方法的时候autoreleaseFast会将一个POOL_BOUNDARY的对象放在临界点上。POOL_BOUNDARY这个对象属于比较关键的对象，关系到AutoreleasePoolPage的释放过程。\n\n```\nstatic inline id *autoreleaseFast(id obj) {\n    AutoreleasePoolPage *page = hotPage();\n    if (page && !page->full()) {\n        return page->add(obj);\n    } else if (page) {\n        return autoreleaseFullPage(obj, page);\n    } else {\n        return autoreleaseNoPage(obj);\n    }\n}\n```\n\n上述方法分三种情况选择不同的代码执行：\n\n1、有 hotPage 并且当前 page 不满，调用 page->add(obj) 方法将对象添加至 AutoreleasePoolPage 的栈中\n2、有 hotPage 并且当前 page 已满，调用 autoreleaseFullPage 初始化一个新的页，调用 page->add(obj) 方法将对象添加至 AutoreleasePoolPage 的栈中\n3、无 hotPage，调用 autoreleaseNoPage 创建一个 hotPage，调用 page->add(obj) 方法将对象添加至 AutoreleasePoolPage 的栈中\n\n最后的都会调用 page->add(obj) 将对象添加到自动释放池中。而hotPage 可以理解为当前正在使用的 AutoreleasePoolPage。\n\n接下来我们看一看objc_autoreleasePoolPop方法调用pop的实现：\n\n```\nstatic inline void pop(void *token) {\n    AutoreleasePoolPage *page;\n    id *stop;\n\n    if (token == (void*)EMPTY_POOL_PLACEHOLDER) {\n        // Popping the top-level placeholder pool.\n        if (hotPage()) {\n            // Pool was used. Pop its contents normally.\n            // Pool pages remain allocated for re-use as usual.\n            pop(coldPage()->begin());\n        } else {\n            // Pool was never used. Clear the placeholder.\n            setHotPage(nil);\n        }\n        return;\n    }\n\n    page = pageForPointer(token);\n    stop = (id *)token;\n    if (*stop != POOL_BOUNDARY) {\n        if (stop == page->begin()  &&  !page->parent) {\n            // Start of coldest page may correctly not be POOL_BOUNDARY:\n            // 1. top-level pool is popped, leaving the cold page in place\n            // 2. an object is autoreleased with no pool\n        } else {\n            // Error. For bincompat purposes this is not \n            // fatal in executables built with old SDKs.\n            return badPop(token);\n        }\n    }\n\n    if (PrintPoolHiwat) printHiwat();\n\n    page->releaseUntil(stop);\n\n    // memory: delete empty children\n    if (DebugPoolAllocation  &&  page->empty()) {\n        // special case: delete everything during page-per-pool debugging\n        AutoreleasePoolPage *parent = page->parent;\n        page->kill();\n        setHotPage(parent);\n    } else if (DebugMissingPools  &&  page->empty()  &&  !page->parent) {\n        // special case: delete everything for pop(top) \n        // when debugging missing autorelease pools\n        page->kill();\n        setHotPage(nil);\n    } \n    else if (page->child) {\n        // hysteresis: keep one empty child if page is more than half full\n        if (page->lessThanHalfFull()) {\n            page->child->kill();\n        }\n        else if (page->child->child) {\n            page->child->child->kill();\n        }\n    }\n}\n```\n\n顺着源码一步一步找就会发现，autorelease函数和push函数一样，关键代码都是调用autoreleaseFast函数向自动释放池的链表栈中添加一个对象，不过push函数的入栈的是一个边界对象，而autorelease函数入栈的是需要加入autoreleasepool的对象。自动释放池释放是传入 push 返回的边界对象（POOL_BOUNDARY）,autoreleasepool在调用autorelease时逐渐kill存在在autoreleasepool中的对象的地址，直到找到POOL_BOUNDARY对象所在的地址才会停止。\n\n那么这就衍生了一个问题，如果AutoreleasePoolPage在添加需要释放的对象的地址超过了4096的空间或者是说有多个AutoreleasePoolPage的时候它是如何存入需要释放对象的地址，又是如何一层一层的释放的呢？\n\n# AutoreleasePoolPage双向链表\n\n其实AutoreleasePoolPage并没有单独的结构，而是由若干个AutoreleasePoolPage以双向链表的形式组合而成的栈结构在AutoreleasePoolPage的成员变量内部，我们可以清晰的看到有两个成员变量：\n\n```\n AutoreleasePoolPage * const parent; //指向上一个AutoreleasePoolPage\n AutoreleasePoolPage *child; //指向下一个AutoreleasePoolPage\n```\nparent指针和child指针，parent指向的上一个AutoreleasePoolPage的内存空间地址而child则指向下一个AutoreleasePoolPage的内存地址，当一个AutoreleasePoolPage的空间被占满时，会新建一个AutoreleasePoolPage对象，连接链表，后来的autorelease对象在新的page加入。这样无论在添加autorelease对象地址和释放autorelease对象地址的时候都能很准确的找到对应的AutoreleasePoolPage的地址\n![双向链表](双向链表.png)\n\n具体查看AutoreleasePoolPage的工作原理，可以用_objc_autoreleasePoolPrint这个私有函数来查看\n\n# Runloop和AutoreleasePool的关系\n\n我们新建一个空的工程，在viewDidLoad打印[NSRunLoop mainRunLoop]的详细信息，我们会在observers发现两个关于AutoreleasePool的Handler操作_wrapRunLoopWithAutoreleasePoolHandler：\n\n```\nobservers = (\n    \"<CFRunLoopObserver 0x600001f68140 [0x1053f6b68]>{valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x107fe51b1), context = <CFArray 0x600002020330 [0x1053f6b68]>{type = mutable-small, count = 1, values = (\\n\\t0 : <0x7ff476808058>\\n)}}\",\n    \"<CFRunLoopObserver 0x600001f6c1e0 [0x1053f6b68]>{valid = Yes, activities = 0x20, repeats = Yes, order = 0, callout = _UIGestureRecognizerUpdateObserver (0x107bb7473), context = <CFRunLoopObserver context 0x60000056dea0>}\",\n    \"<CFRunLoopObserver 0x600001f68c80 [0x1053f6b68]>{valid = Yes, activities = 0xa0, repeats = Yes, order = 1999000, callout = _beforeCACommitHandler (0x108014dfc), context = <CFRunLoopObserver context 0x7ff475d024b0>}\",\n    \"<CFRunLoopObserver 0x600001f68960 [0x1053f6b68]>{valid = Yes, activities = 0xa0, repeats = Yes, order = 2000000, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv (0x109a136ae), context = <CFRunLoopObserver context 0x0>}\",\n    \"<CFRunLoopObserver 0x600001f68be0 [0x1053f6b68]>{valid = Yes, activities = 0xa0, repeats = Yes, order = 2001000, callout = _afterCACommitHandler (0x108014e75), context = <CFRunLoopObserver context 0x7ff475d024b0>}\",\n    \"<CFRunLoopObserver 0x600001f68b40 [0x1053f6b68]>{valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x107fe51b1), context = <CFArray 0x600002020330 [0x1053f6b68]>{type = mutable-small, count = 1, values = (\\n\\t0 : <0x7ff476808058>\\n)}}\"\n)\n```\n我们查看它的activities，分别是在0x1和0xa0，那这两个分别有代表是什么呢？在runloop 的源码里我们可以找到runloop的相关枚举：\n\n```\ntypedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {\n     kCFRunLoopEntry = (1UL << 0),  // 1\n     kCFRunLoopBeforeTimers = (1UL << 1), // 2\n     kCFRunLoopBeforeSources = (1UL << 2), // 4\n     kCFRunLoopBeforeWaiting = (1UL << 5), // 32\n     kCFRunLoopAfterWaiting = (1UL << 6), // 64\n     kCFRunLoopExit = (1UL << 7), // 128\n     kCFRunLoopAllActivities = 0x0FFFFFFFU\n };\n```\n根据位运算可以的出上述结果：0x1 = 1 等价于kCFRunLoopEntry，0xa0 = 64 + 128 等价于 kCFRunLoopBeforeWaiting | kCFRunLoopExit，意味着runloop会在kCFRunLoopEntry时进行一次push操作，在kCFRunLoopBeforeWaiting进行一次pop操作，然后在进行一次push操作，最后会在kCFRunLoopExit时进行一次pop操作。\n\n也就是说runloop会在即将进行休眠和退出runloop是将AutoreleasePool进行释放。","slug":"AutoreleasePool源码分析","published":1,"updated":"2023-07-21T09:10:33.567Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clkcgbp540001pfo73n9edpqx","content":"<blockquote>\n<p>AutoreleasePool（自动释放池）是OC中的一种内存自动回收机制，它可以延迟加入AutoreleasePool中的变量release的时机。在正常情况下，创建的变量会在超出其作用域的时候release，但是如果将变量加入AutoreleasePool，那么release将延迟执行。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<p>需要了解AutoreleasePool的工作原理，我们需要知道它的底层到底做了什么事情，那我们就先从汇编代码入手，新建一个命令行工程，创建一个新的对象继承自NSObject：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">#import &quot;object.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        object *oc = [[object alloc] init]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>我们利用命令将OC代码重写为c++代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m</span><br></pre></td></tr></table></figure>\n\n<p>我们可以大约得到3万2千行的c++代码的cpp文件，但是不要紧，因为最终的核心代码在该cpp的最底部：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class=\"line\"></span><br><span class=\"line\">        object *o1 = ((object *(*)(id, SEL))(void *)objc_msgSend)((id)((object *(*)(id, SEL))(void *)objc_msgSend)((id)((object *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;object&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;)), sel_registerName(&quot;autorelease&quot;));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>中间的代码层是object对象的创建过程，发送objc_msgSend消息创建对象。那其实最核心的代码就在下面这这两句上了</p>\n<blockquote>\n<p>__AtAutoreleasePool __autoreleasepool; </p>\n</blockquote>\n<h1 id=\"AtAutoreleasePool\"><a href=\"#AtAutoreleasePool\" class=\"headerlink\" title=\"__AtAutoreleasePool\"></a>__AtAutoreleasePool</h1><p>我们在cpp文件中搜索__AtAutoreleasePool会找到如下代码,__AtAutoreleasePool具体定义如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extern &quot;C&quot; __declspec(dllimport) void * objc_autoreleasePoolPush(void);</span><br><span class=\"line\">extern &quot;C&quot; __declspec(dllimport) void objc_autoreleasePoolPop(void *);</span><br><span class=\"line\"></span><br><span class=\"line\">struct __AtAutoreleasePool &#123;</span><br><span class=\"line\">  __AtAutoreleasePool() &#123; // 构造函数，在创建结构体的时候调用</span><br><span class=\"line\">      atautoreleasepoolobj = objc_autoreleasePoolPush();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ~__AtAutoreleasePool() &#123; // 析构函数，在结构体销毁的时候调用</span><br><span class=\"line\">    objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  void * atautoreleasepoolobj;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>上面两个调用，分别是构造函数和析构函数，根据构造函数和析构函数的特点：自动局部变量的构造函数是在程序执行到声明这个对象的位置时调用的，而对应的析构函数是在程序执行到离开这个对象的作用域时调用。苹果实际上是通过声明一个__AtAutoreleasePool类型的局部变量__autoreleasepool实现了@autoreleasepool{},那么实际上单个自动释放池的执行过程就是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objc_autoreleasePoolPush() —&gt; [object autorelease] —&gt; objc_autoreleasePoolPop(void *)</span><br></pre></td></tr></table></figure>\n\n\n<p>想了解objc_autoreleasePoolPush和objc_autoreleasePoolPop具体都做了些什么，其实很简单，我们只要到runtime-&gt;NSObject.mm的源码中就能窥探它的真是面目了，这里我们分析的runtime源码是objc-750的版本。<br>在源码中我们可以发现这样一段代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void *objc_autoreleasePoolPush(void) &#123;</span><br><span class=\"line\">    return AutoreleasePoolPage::push();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void objc_autoreleasePoolPop(void *ctxt) &#123;</span><br><span class=\"line\">    AutoreleasePoolPage::pop(ctxt);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>objc_autoreleasePoolPush和objc_autoreleasePoolPop分别是由AutoreleasePoolPage调用了push方法入栈和pop方法出栈，其本质实际上是AutoreleasePoolPage对应的静态方法push和pop的封装。那么问题就显而易见了，如果要知道这个push和pop方法到底做了什么，我们还得从源码里获取到AutoreleasePoolPage相关的内容以及其实现原理。</p>\n<h1 id=\"AutoreleasePoolPage定义\"><a href=\"#AutoreleasePoolPage定义\" class=\"headerlink\" title=\"AutoreleasePoolPage定义\"></a>AutoreleasePoolPage定义</h1><p>在runtime源码中对AutoreleasePoolPage的定义是这样的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class AutoreleasePoolPage  &#123;</span><br><span class=\"line\">    // EMPTY_POOL_PLACEHOLDER is stored in TLS when exactly one pool is </span><br><span class=\"line\">    // pushed and it has never contained any objects. This saves memory </span><br><span class=\"line\">    // when the top level (i.e. libdispatch) pushes and pops pools but </span><br><span class=\"line\">    // never uses them.</span><br><span class=\"line\">#   define EMPTY_POOL_PLACEHOLDER ((id*)1)</span><br><span class=\"line\"></span><br><span class=\"line\">#   define POOL_BOUNDARY nil</span><br><span class=\"line\">    static pthread_key_t const key = AUTORELEASE_POOL_KEY;</span><br><span class=\"line\">    static uint8_t const SCRIBBLE = 0xA3;  // 0xA3A3A3A3 after releasing</span><br><span class=\"line\">    static size_t const SIZE = </span><br><span class=\"line\">#if PROTECT_AUTORELEASEPOOL</span><br><span class=\"line\">        PAGE_MAX_SIZE;  // must be multiple of vm page size</span><br><span class=\"line\">#else</span><br><span class=\"line\">        PAGE_MAX_SIZE;  // size and alignment, power of 2</span><br><span class=\"line\">#endif</span><br><span class=\"line\">    static size_t const COUNT = SIZE / sizeof(id);</span><br><span class=\"line\"></span><br><span class=\"line\">    magic_t const magic;</span><br><span class=\"line\">    id *next;</span><br><span class=\"line\">    pthread_t const thread;</span><br><span class=\"line\">    AutoreleasePoolPage * const parent;</span><br><span class=\"line\">    AutoreleasePoolPage *child;</span><br><span class=\"line\">    uint32_t const depth;</span><br><span class=\"line\">    uint32_t hiwat;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>去除那些静态成员变量,AutoreleasePoolPage的成员变量的解释如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class AutoreleasePoolPage  &#123;</span><br><span class=\"line\">    magic_t const magic; //检查校验完整性的变量</span><br><span class=\"line\">    id *next; //指向新添加到AutoreleasePoolPage的对象</span><br><span class=\"line\">    pthread_t const thread; //AutoreleasePoolPage当前所在的线程，AutoreleasePool是按线程一一对应的（结构中的thread指针指向当前线程）</span><br><span class=\"line\">    AutoreleasePoolPage * const parent; //指向上一个AutoreleasePoolPage</span><br><span class=\"line\">    AutoreleasePoolPage *child; //指向下一个AutoreleasePoolPage</span><br><span class=\"line\">    uint32_t const depth; //depth 链表的深度，节点个数</span><br><span class=\"line\">    uint32_t hiwat; //数据容纳的一个上限</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里需要注意的是AutoreleasePoolPage有一个成员变量是PAGE_MAX_SIZE，这个表示一个AutoreleasePoolPage最大内存大小，这个宏其实在上面可以找得到，也就是说一个AutoreleasePoolPage的最大内存大小是PAGE_MAX_SIZE（也就是4096）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define I386_PGBYTES        4096        /* bytes per 80386 page */</span><br><span class=\"line\">#define I386_PGSHIFT        12      /* bitshift for pages */</span><br><span class=\"line\"></span><br><span class=\"line\">#define PAGE_SIZE       I386_PGBYTES</span><br><span class=\"line\">#define PAGE_SHIFT      I386_PGSHIFT</span><br><span class=\"line\">#define PAGE_MASK       (PAGE_SIZE - 1)</span><br><span class=\"line\"></span><br><span class=\"line\">#define PAGE_MAX_SHIFT          PAGE_SHIFT</span><br><span class=\"line\">#define PAGE_MAX_SIZE           PAGE_SIZE</span><br><span class=\"line\">#define PAGE_MAX_MASK           PAGE_MASK</span><br><span class=\"line\"></span><br><span class=\"line\">#define PAGE_MIN_SHIFT          PAGE_SHIFT</span><br><span class=\"line\">#define PAGE_MIN_SIZE           PAGE_SIZE</span><br><span class=\"line\">#define PAGE_MIN_MASK           PAGE_MASK</span><br></pre></td></tr></table></figure>\n<h1 id=\"AutoreleasePoolPage工作原理\"><a href=\"#AutoreleasePoolPage工作原理\" class=\"headerlink\" title=\"AutoreleasePoolPage工作原理\"></a>AutoreleasePoolPage工作原理</h1><p>每个AutoreleasePoolPage对象的内存大小事4096字节，除去AutoreleasePoolPage的成员变量所占用的空间，剩下的空间用来存放Autorelease对象的地址，知道了AutoreleasePoolPage的定义，现在我们回到objc_autoreleasePoolPush这个方法，我们发现了，实际上这个方法是调用了AutoreleasePoolPage的push方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static inline void *push() &#123;</span><br><span class=\"line\">    id *dest;</span><br><span class=\"line\">    if (DebugPoolAllocation) &#123;</span><br><span class=\"line\">        // Each autorelease pool starts on a new pool page.</span><br><span class=\"line\">        dest = autoreleaseNewPage(POOL_BOUNDARY);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        dest = autoreleaseFast(POOL_BOUNDARY);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    assert(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);</span><br><span class=\"line\">    return dest;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>细心的你肯定会发现，在调用push方法的时候autoreleaseFast会将一个POOL_BOUNDARY的对象放在临界点上。POOL_BOUNDARY这个对象属于比较关键的对象，关系到AutoreleasePoolPage的释放过程。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static inline id *autoreleaseFast(id obj) &#123;</span><br><span class=\"line\">    AutoreleasePoolPage *page = hotPage();</span><br><span class=\"line\">    if (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class=\"line\">        return page-&gt;add(obj);</span><br><span class=\"line\">    &#125; else if (page) &#123;</span><br><span class=\"line\">        return autoreleaseFullPage(obj, page);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        return autoreleaseNoPage(obj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述方法分三种情况选择不同的代码执行：</p>\n<p>1、有 hotPage 并且当前 page 不满，调用 page-&gt;add(obj) 方法将对象添加至 AutoreleasePoolPage 的栈中<br>2、有 hotPage 并且当前 page 已满，调用 autoreleaseFullPage 初始化一个新的页，调用 page-&gt;add(obj) 方法将对象添加至 AutoreleasePoolPage 的栈中<br>3、无 hotPage，调用 autoreleaseNoPage 创建一个 hotPage，调用 page-&gt;add(obj) 方法将对象添加至 AutoreleasePoolPage 的栈中</p>\n<p>最后的都会调用 page-&gt;add(obj) 将对象添加到自动释放池中。而hotPage 可以理解为当前正在使用的 AutoreleasePoolPage。</p>\n<p>接下来我们看一看objc_autoreleasePoolPop方法调用pop的实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static inline void pop(void *token) &#123;</span><br><span class=\"line\">    AutoreleasePoolPage *page;</span><br><span class=\"line\">    id *stop;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (token == (void*)EMPTY_POOL_PLACEHOLDER) &#123;</span><br><span class=\"line\">        // Popping the top-level placeholder pool.</span><br><span class=\"line\">        if (hotPage()) &#123;</span><br><span class=\"line\">            // Pool was used. Pop its contents normally.</span><br><span class=\"line\">            // Pool pages remain allocated for re-use as usual.</span><br><span class=\"line\">            pop(coldPage()-&gt;begin());</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            // Pool was never used. Clear the placeholder.</span><br><span class=\"line\">            setHotPage(nil);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    page = pageForPointer(token);</span><br><span class=\"line\">    stop = (id *)token;</span><br><span class=\"line\">    if (*stop != POOL_BOUNDARY) &#123;</span><br><span class=\"line\">        if (stop == page-&gt;begin()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class=\"line\">            // Start of coldest page may correctly not be POOL_BOUNDARY:</span><br><span class=\"line\">            // 1. top-level pool is popped, leaving the cold page in place</span><br><span class=\"line\">            // 2. an object is autoreleased with no pool</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            // Error. For bincompat purposes this is not </span><br><span class=\"line\">            // fatal in executables built with old SDKs.</span><br><span class=\"line\">            return badPop(token);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (PrintPoolHiwat) printHiwat();</span><br><span class=\"line\"></span><br><span class=\"line\">    page-&gt;releaseUntil(stop);</span><br><span class=\"line\"></span><br><span class=\"line\">    // memory: delete empty children</span><br><span class=\"line\">    if (DebugPoolAllocation  &amp;&amp;  page-&gt;empty()) &#123;</span><br><span class=\"line\">        // special case: delete everything during page-per-pool debugging</span><br><span class=\"line\">        AutoreleasePoolPage *parent = page-&gt;parent;</span><br><span class=\"line\">        page-&gt;kill();</span><br><span class=\"line\">        setHotPage(parent);</span><br><span class=\"line\">    &#125; else if (DebugMissingPools  &amp;&amp;  page-&gt;empty()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class=\"line\">        // special case: delete everything for pop(top) </span><br><span class=\"line\">        // when debugging missing autorelease pools</span><br><span class=\"line\">        page-&gt;kill();</span><br><span class=\"line\">        setHotPage(nil);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    else if (page-&gt;child) &#123;</span><br><span class=\"line\">        // hysteresis: keep one empty child if page is more than half full</span><br><span class=\"line\">        if (page-&gt;lessThanHalfFull()) &#123;</span><br><span class=\"line\">            page-&gt;child-&gt;kill();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else if (page-&gt;child-&gt;child) &#123;</span><br><span class=\"line\">            page-&gt;child-&gt;child-&gt;kill();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>顺着源码一步一步找就会发现，autorelease函数和push函数一样，关键代码都是调用autoreleaseFast函数向自动释放池的链表栈中添加一个对象，不过push函数的入栈的是一个边界对象，而autorelease函数入栈的是需要加入autoreleasepool的对象。自动释放池释放是传入 push 返回的边界对象（POOL_BOUNDARY）,autoreleasepool在调用autorelease时逐渐kill存在在autoreleasepool中的对象的地址，直到找到POOL_BOUNDARY对象所在的地址才会停止。</p>\n<p>那么这就衍生了一个问题，如果AutoreleasePoolPage在添加需要释放的对象的地址超过了4096的空间或者是说有多个AutoreleasePoolPage的时候它是如何存入需要释放对象的地址，又是如何一层一层的释放的呢？</p>\n<h1 id=\"AutoreleasePoolPage双向链表\"><a href=\"#AutoreleasePoolPage双向链表\" class=\"headerlink\" title=\"AutoreleasePoolPage双向链表\"></a>AutoreleasePoolPage双向链表</h1><p>其实AutoreleasePoolPage并没有单独的结构，而是由若干个AutoreleasePoolPage以双向链表的形式组合而成的栈结构在AutoreleasePoolPage的成员变量内部，我们可以清晰的看到有两个成员变量：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AutoreleasePoolPage * const parent; //指向上一个AutoreleasePoolPage</span><br><span class=\"line\">AutoreleasePoolPage *child; //指向下一个AutoreleasePoolPage</span><br></pre></td></tr></table></figure>\n<p>parent指针和child指针，parent指向的上一个AutoreleasePoolPage的内存空间地址而child则指向下一个AutoreleasePoolPage的内存地址，当一个AutoreleasePoolPage的空间被占满时，会新建一个AutoreleasePoolPage对象，连接链表，后来的autorelease对象在新的page加入。这样无论在添加autorelease对象地址和释放autorelease对象地址的时候都能很准确的找到对应的AutoreleasePoolPage的地址<br><img src=\"/2018/03/15/AutoreleasePool%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png\" alt=\"双向链表\"></p>\n<p>具体查看AutoreleasePoolPage的工作原理，可以用_objc_autoreleasePoolPrint这个私有函数来查看</p>\n<h1 id=\"Runloop和AutoreleasePool的关系\"><a href=\"#Runloop和AutoreleasePool的关系\" class=\"headerlink\" title=\"Runloop和AutoreleasePool的关系\"></a>Runloop和AutoreleasePool的关系</h1><p>我们新建一个空的工程，在viewDidLoad打印[NSRunLoop mainRunLoop]的详细信息，我们会在observers发现两个关于AutoreleasePool的Handler操作_wrapRunLoopWithAutoreleasePoolHandler：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">observers = (</span><br><span class=\"line\">    &quot;&lt;CFRunLoopObserver 0x600001f68140 [0x1053f6b68]&gt;&#123;valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x107fe51b1), context = &lt;CFArray 0x600002020330 [0x1053f6b68]&gt;&#123;type = mutable-small, count = 1, values = (\\n\\t0 : &lt;0x7ff476808058&gt;\\n)&#125;&#125;&quot;,</span><br><span class=\"line\">    &quot;&lt;CFRunLoopObserver 0x600001f6c1e0 [0x1053f6b68]&gt;&#123;valid = Yes, activities = 0x20, repeats = Yes, order = 0, callout = _UIGestureRecognizerUpdateObserver (0x107bb7473), context = &lt;CFRunLoopObserver context 0x60000056dea0&gt;&#125;&quot;,</span><br><span class=\"line\">    &quot;&lt;CFRunLoopObserver 0x600001f68c80 [0x1053f6b68]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 1999000, callout = _beforeCACommitHandler (0x108014dfc), context = &lt;CFRunLoopObserver context 0x7ff475d024b0&gt;&#125;&quot;,</span><br><span class=\"line\">    &quot;&lt;CFRunLoopObserver 0x600001f68960 [0x1053f6b68]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2000000, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv (0x109a136ae), context = &lt;CFRunLoopObserver context 0x0&gt;&#125;&quot;,</span><br><span class=\"line\">    &quot;&lt;CFRunLoopObserver 0x600001f68be0 [0x1053f6b68]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2001000, callout = _afterCACommitHandler (0x108014e75), context = &lt;CFRunLoopObserver context 0x7ff475d024b0&gt;&#125;&quot;,</span><br><span class=\"line\">    &quot;&lt;CFRunLoopObserver 0x600001f68b40 [0x1053f6b68]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x107fe51b1), context = &lt;CFArray 0x600002020330 [0x1053f6b68]&gt;&#123;type = mutable-small, count = 1, values = (\\n\\t0 : &lt;0x7ff476808058&gt;\\n)&#125;&#125;&quot;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>我们查看它的activities，分别是在0x1和0xa0，那这两个分别有代表是什么呢？在runloop 的源码里我们可以找到runloop的相关枚举：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class=\"line\">     kCFRunLoopEntry = (1UL &lt;&lt; 0),  // 1</span><br><span class=\"line\">     kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 2</span><br><span class=\"line\">     kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 4</span><br><span class=\"line\">     kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 32</span><br><span class=\"line\">     kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 64</span><br><span class=\"line\">     kCFRunLoopExit = (1UL &lt;&lt; 7), // 128</span><br><span class=\"line\">     kCFRunLoopAllActivities = 0x0FFFFFFFU</span><br><span class=\"line\"> &#125;;</span><br></pre></td></tr></table></figure>\n<p>根据位运算可以的出上述结果：0x1 &#x3D; 1 等价于kCFRunLoopEntry，0xa0 &#x3D; 64 + 128 等价于 kCFRunLoopBeforeWaiting | kCFRunLoopExit，意味着runloop会在kCFRunLoopEntry时进行一次push操作，在kCFRunLoopBeforeWaiting进行一次pop操作，然后在进行一次push操作，最后会在kCFRunLoopExit时进行一次pop操作。</p>\n<p>也就是说runloop会在即将进行休眠和退出runloop是将AutoreleasePool进行释放。</p>\n","site":{"data":{}},"length":10453,"excerpt":"<blockquote>\n<p>AutoreleasePool（自动释放池）是OC中的一种内存自动回收机制，它可以延迟加入AutoreleasePool中的变量release的时机。在正常情况下，创建的变量会在超出其作用域的时候release，但是如果将变量加入AutoreleasePool，那么release将延迟执行。</p>\n</blockquote>","more":"<p>需要了解AutoreleasePool的工作原理，我们需要知道它的底层到底做了什么事情，那我们就先从汇编代码入手，新建一个命令行工程，创建一个新的对象继承自NSObject：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">#import &quot;object.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        object *oc = [[object alloc] init]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>我们利用命令将OC代码重写为c++代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m</span><br></pre></td></tr></table></figure>\n\n<p>我们可以大约得到3万2千行的c++代码的cpp文件，但是不要紧，因为最终的核心代码在该cpp的最底部：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class=\"line\"></span><br><span class=\"line\">        object *o1 = ((object *(*)(id, SEL))(void *)objc_msgSend)((id)((object *(*)(id, SEL))(void *)objc_msgSend)((id)((object *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;object&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;)), sel_registerName(&quot;autorelease&quot;));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>中间的代码层是object对象的创建过程，发送objc_msgSend消息创建对象。那其实最核心的代码就在下面这这两句上了</p>\n<blockquote>\n<p>__AtAutoreleasePool __autoreleasepool; </p>\n</blockquote>\n<h1 id=\"AtAutoreleasePool\"><a href=\"#AtAutoreleasePool\" class=\"headerlink\" title=\"__AtAutoreleasePool\"></a>__AtAutoreleasePool</h1><p>我们在cpp文件中搜索__AtAutoreleasePool会找到如下代码,__AtAutoreleasePool具体定义如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extern &quot;C&quot; __declspec(dllimport) void * objc_autoreleasePoolPush(void);</span><br><span class=\"line\">extern &quot;C&quot; __declspec(dllimport) void objc_autoreleasePoolPop(void *);</span><br><span class=\"line\"></span><br><span class=\"line\">struct __AtAutoreleasePool &#123;</span><br><span class=\"line\">  __AtAutoreleasePool() &#123; // 构造函数，在创建结构体的时候调用</span><br><span class=\"line\">      atautoreleasepoolobj = objc_autoreleasePoolPush();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ~__AtAutoreleasePool() &#123; // 析构函数，在结构体销毁的时候调用</span><br><span class=\"line\">    objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  void * atautoreleasepoolobj;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>上面两个调用，分别是构造函数和析构函数，根据构造函数和析构函数的特点：自动局部变量的构造函数是在程序执行到声明这个对象的位置时调用的，而对应的析构函数是在程序执行到离开这个对象的作用域时调用。苹果实际上是通过声明一个__AtAutoreleasePool类型的局部变量__autoreleasepool实现了@autoreleasepool{},那么实际上单个自动释放池的执行过程就是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objc_autoreleasePoolPush() —&gt; [object autorelease] —&gt; objc_autoreleasePoolPop(void *)</span><br></pre></td></tr></table></figure>\n\n\n<p>想了解objc_autoreleasePoolPush和objc_autoreleasePoolPop具体都做了些什么，其实很简单，我们只要到runtime-&gt;NSObject.mm的源码中就能窥探它的真是面目了，这里我们分析的runtime源码是objc-750的版本。<br>在源码中我们可以发现这样一段代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void *objc_autoreleasePoolPush(void) &#123;</span><br><span class=\"line\">    return AutoreleasePoolPage::push();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void objc_autoreleasePoolPop(void *ctxt) &#123;</span><br><span class=\"line\">    AutoreleasePoolPage::pop(ctxt);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>objc_autoreleasePoolPush和objc_autoreleasePoolPop分别是由AutoreleasePoolPage调用了push方法入栈和pop方法出栈，其本质实际上是AutoreleasePoolPage对应的静态方法push和pop的封装。那么问题就显而易见了，如果要知道这个push和pop方法到底做了什么，我们还得从源码里获取到AutoreleasePoolPage相关的内容以及其实现原理。</p>\n<h1 id=\"AutoreleasePoolPage定义\"><a href=\"#AutoreleasePoolPage定义\" class=\"headerlink\" title=\"AutoreleasePoolPage定义\"></a>AutoreleasePoolPage定义</h1><p>在runtime源码中对AutoreleasePoolPage的定义是这样的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class AutoreleasePoolPage  &#123;</span><br><span class=\"line\">    // EMPTY_POOL_PLACEHOLDER is stored in TLS when exactly one pool is </span><br><span class=\"line\">    // pushed and it has never contained any objects. This saves memory </span><br><span class=\"line\">    // when the top level (i.e. libdispatch) pushes and pops pools but </span><br><span class=\"line\">    // never uses them.</span><br><span class=\"line\">#   define EMPTY_POOL_PLACEHOLDER ((id*)1)</span><br><span class=\"line\"></span><br><span class=\"line\">#   define POOL_BOUNDARY nil</span><br><span class=\"line\">    static pthread_key_t const key = AUTORELEASE_POOL_KEY;</span><br><span class=\"line\">    static uint8_t const SCRIBBLE = 0xA3;  // 0xA3A3A3A3 after releasing</span><br><span class=\"line\">    static size_t const SIZE = </span><br><span class=\"line\">#if PROTECT_AUTORELEASEPOOL</span><br><span class=\"line\">        PAGE_MAX_SIZE;  // must be multiple of vm page size</span><br><span class=\"line\">#else</span><br><span class=\"line\">        PAGE_MAX_SIZE;  // size and alignment, power of 2</span><br><span class=\"line\">#endif</span><br><span class=\"line\">    static size_t const COUNT = SIZE / sizeof(id);</span><br><span class=\"line\"></span><br><span class=\"line\">    magic_t const magic;</span><br><span class=\"line\">    id *next;</span><br><span class=\"line\">    pthread_t const thread;</span><br><span class=\"line\">    AutoreleasePoolPage * const parent;</span><br><span class=\"line\">    AutoreleasePoolPage *child;</span><br><span class=\"line\">    uint32_t const depth;</span><br><span class=\"line\">    uint32_t hiwat;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>去除那些静态成员变量,AutoreleasePoolPage的成员变量的解释如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class AutoreleasePoolPage  &#123;</span><br><span class=\"line\">    magic_t const magic; //检查校验完整性的变量</span><br><span class=\"line\">    id *next; //指向新添加到AutoreleasePoolPage的对象</span><br><span class=\"line\">    pthread_t const thread; //AutoreleasePoolPage当前所在的线程，AutoreleasePool是按线程一一对应的（结构中的thread指针指向当前线程）</span><br><span class=\"line\">    AutoreleasePoolPage * const parent; //指向上一个AutoreleasePoolPage</span><br><span class=\"line\">    AutoreleasePoolPage *child; //指向下一个AutoreleasePoolPage</span><br><span class=\"line\">    uint32_t const depth; //depth 链表的深度，节点个数</span><br><span class=\"line\">    uint32_t hiwat; //数据容纳的一个上限</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里需要注意的是AutoreleasePoolPage有一个成员变量是PAGE_MAX_SIZE，这个表示一个AutoreleasePoolPage最大内存大小，这个宏其实在上面可以找得到，也就是说一个AutoreleasePoolPage的最大内存大小是PAGE_MAX_SIZE（也就是4096）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define I386_PGBYTES        4096        /* bytes per 80386 page */</span><br><span class=\"line\">#define I386_PGSHIFT        12      /* bitshift for pages */</span><br><span class=\"line\"></span><br><span class=\"line\">#define PAGE_SIZE       I386_PGBYTES</span><br><span class=\"line\">#define PAGE_SHIFT      I386_PGSHIFT</span><br><span class=\"line\">#define PAGE_MASK       (PAGE_SIZE - 1)</span><br><span class=\"line\"></span><br><span class=\"line\">#define PAGE_MAX_SHIFT          PAGE_SHIFT</span><br><span class=\"line\">#define PAGE_MAX_SIZE           PAGE_SIZE</span><br><span class=\"line\">#define PAGE_MAX_MASK           PAGE_MASK</span><br><span class=\"line\"></span><br><span class=\"line\">#define PAGE_MIN_SHIFT          PAGE_SHIFT</span><br><span class=\"line\">#define PAGE_MIN_SIZE           PAGE_SIZE</span><br><span class=\"line\">#define PAGE_MIN_MASK           PAGE_MASK</span><br></pre></td></tr></table></figure>\n<h1 id=\"AutoreleasePoolPage工作原理\"><a href=\"#AutoreleasePoolPage工作原理\" class=\"headerlink\" title=\"AutoreleasePoolPage工作原理\"></a>AutoreleasePoolPage工作原理</h1><p>每个AutoreleasePoolPage对象的内存大小事4096字节，除去AutoreleasePoolPage的成员变量所占用的空间，剩下的空间用来存放Autorelease对象的地址，知道了AutoreleasePoolPage的定义，现在我们回到objc_autoreleasePoolPush这个方法，我们发现了，实际上这个方法是调用了AutoreleasePoolPage的push方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static inline void *push() &#123;</span><br><span class=\"line\">    id *dest;</span><br><span class=\"line\">    if (DebugPoolAllocation) &#123;</span><br><span class=\"line\">        // Each autorelease pool starts on a new pool page.</span><br><span class=\"line\">        dest = autoreleaseNewPage(POOL_BOUNDARY);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        dest = autoreleaseFast(POOL_BOUNDARY);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    assert(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);</span><br><span class=\"line\">    return dest;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>细心的你肯定会发现，在调用push方法的时候autoreleaseFast会将一个POOL_BOUNDARY的对象放在临界点上。POOL_BOUNDARY这个对象属于比较关键的对象，关系到AutoreleasePoolPage的释放过程。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static inline id *autoreleaseFast(id obj) &#123;</span><br><span class=\"line\">    AutoreleasePoolPage *page = hotPage();</span><br><span class=\"line\">    if (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class=\"line\">        return page-&gt;add(obj);</span><br><span class=\"line\">    &#125; else if (page) &#123;</span><br><span class=\"line\">        return autoreleaseFullPage(obj, page);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        return autoreleaseNoPage(obj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述方法分三种情况选择不同的代码执行：</p>\n<p>1、有 hotPage 并且当前 page 不满，调用 page-&gt;add(obj) 方法将对象添加至 AutoreleasePoolPage 的栈中<br>2、有 hotPage 并且当前 page 已满，调用 autoreleaseFullPage 初始化一个新的页，调用 page-&gt;add(obj) 方法将对象添加至 AutoreleasePoolPage 的栈中<br>3、无 hotPage，调用 autoreleaseNoPage 创建一个 hotPage，调用 page-&gt;add(obj) 方法将对象添加至 AutoreleasePoolPage 的栈中</p>\n<p>最后的都会调用 page-&gt;add(obj) 将对象添加到自动释放池中。而hotPage 可以理解为当前正在使用的 AutoreleasePoolPage。</p>\n<p>接下来我们看一看objc_autoreleasePoolPop方法调用pop的实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static inline void pop(void *token) &#123;</span><br><span class=\"line\">    AutoreleasePoolPage *page;</span><br><span class=\"line\">    id *stop;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (token == (void*)EMPTY_POOL_PLACEHOLDER) &#123;</span><br><span class=\"line\">        // Popping the top-level placeholder pool.</span><br><span class=\"line\">        if (hotPage()) &#123;</span><br><span class=\"line\">            // Pool was used. Pop its contents normally.</span><br><span class=\"line\">            // Pool pages remain allocated for re-use as usual.</span><br><span class=\"line\">            pop(coldPage()-&gt;begin());</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            // Pool was never used. Clear the placeholder.</span><br><span class=\"line\">            setHotPage(nil);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    page = pageForPointer(token);</span><br><span class=\"line\">    stop = (id *)token;</span><br><span class=\"line\">    if (*stop != POOL_BOUNDARY) &#123;</span><br><span class=\"line\">        if (stop == page-&gt;begin()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class=\"line\">            // Start of coldest page may correctly not be POOL_BOUNDARY:</span><br><span class=\"line\">            // 1. top-level pool is popped, leaving the cold page in place</span><br><span class=\"line\">            // 2. an object is autoreleased with no pool</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            // Error. For bincompat purposes this is not </span><br><span class=\"line\">            // fatal in executables built with old SDKs.</span><br><span class=\"line\">            return badPop(token);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (PrintPoolHiwat) printHiwat();</span><br><span class=\"line\"></span><br><span class=\"line\">    page-&gt;releaseUntil(stop);</span><br><span class=\"line\"></span><br><span class=\"line\">    // memory: delete empty children</span><br><span class=\"line\">    if (DebugPoolAllocation  &amp;&amp;  page-&gt;empty()) &#123;</span><br><span class=\"line\">        // special case: delete everything during page-per-pool debugging</span><br><span class=\"line\">        AutoreleasePoolPage *parent = page-&gt;parent;</span><br><span class=\"line\">        page-&gt;kill();</span><br><span class=\"line\">        setHotPage(parent);</span><br><span class=\"line\">    &#125; else if (DebugMissingPools  &amp;&amp;  page-&gt;empty()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class=\"line\">        // special case: delete everything for pop(top) </span><br><span class=\"line\">        // when debugging missing autorelease pools</span><br><span class=\"line\">        page-&gt;kill();</span><br><span class=\"line\">        setHotPage(nil);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    else if (page-&gt;child) &#123;</span><br><span class=\"line\">        // hysteresis: keep one empty child if page is more than half full</span><br><span class=\"line\">        if (page-&gt;lessThanHalfFull()) &#123;</span><br><span class=\"line\">            page-&gt;child-&gt;kill();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else if (page-&gt;child-&gt;child) &#123;</span><br><span class=\"line\">            page-&gt;child-&gt;child-&gt;kill();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>顺着源码一步一步找就会发现，autorelease函数和push函数一样，关键代码都是调用autoreleaseFast函数向自动释放池的链表栈中添加一个对象，不过push函数的入栈的是一个边界对象，而autorelease函数入栈的是需要加入autoreleasepool的对象。自动释放池释放是传入 push 返回的边界对象（POOL_BOUNDARY）,autoreleasepool在调用autorelease时逐渐kill存在在autoreleasepool中的对象的地址，直到找到POOL_BOUNDARY对象所在的地址才会停止。</p>\n<p>那么这就衍生了一个问题，如果AutoreleasePoolPage在添加需要释放的对象的地址超过了4096的空间或者是说有多个AutoreleasePoolPage的时候它是如何存入需要释放对象的地址，又是如何一层一层的释放的呢？</p>\n<h1 id=\"AutoreleasePoolPage双向链表\"><a href=\"#AutoreleasePoolPage双向链表\" class=\"headerlink\" title=\"AutoreleasePoolPage双向链表\"></a>AutoreleasePoolPage双向链表</h1><p>其实AutoreleasePoolPage并没有单独的结构，而是由若干个AutoreleasePoolPage以双向链表的形式组合而成的栈结构在AutoreleasePoolPage的成员变量内部，我们可以清晰的看到有两个成员变量：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AutoreleasePoolPage * const parent; //指向上一个AutoreleasePoolPage</span><br><span class=\"line\">AutoreleasePoolPage *child; //指向下一个AutoreleasePoolPage</span><br></pre></td></tr></table></figure>\n<p>parent指针和child指针，parent指向的上一个AutoreleasePoolPage的内存空间地址而child则指向下一个AutoreleasePoolPage的内存地址，当一个AutoreleasePoolPage的空间被占满时，会新建一个AutoreleasePoolPage对象，连接链表，后来的autorelease对象在新的page加入。这样无论在添加autorelease对象地址和释放autorelease对象地址的时候都能很准确的找到对应的AutoreleasePoolPage的地址<br><img src=\"/2018/03/15/AutoreleasePool%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png\" alt=\"双向链表\"></p>\n<p>具体查看AutoreleasePoolPage的工作原理，可以用_objc_autoreleasePoolPrint这个私有函数来查看</p>\n<h1 id=\"Runloop和AutoreleasePool的关系\"><a href=\"#Runloop和AutoreleasePool的关系\" class=\"headerlink\" title=\"Runloop和AutoreleasePool的关系\"></a>Runloop和AutoreleasePool的关系</h1><p>我们新建一个空的工程，在viewDidLoad打印[NSRunLoop mainRunLoop]的详细信息，我们会在observers发现两个关于AutoreleasePool的Handler操作_wrapRunLoopWithAutoreleasePoolHandler：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">observers = (</span><br><span class=\"line\">    &quot;&lt;CFRunLoopObserver 0x600001f68140 [0x1053f6b68]&gt;&#123;valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x107fe51b1), context = &lt;CFArray 0x600002020330 [0x1053f6b68]&gt;&#123;type = mutable-small, count = 1, values = (\\n\\t0 : &lt;0x7ff476808058&gt;\\n)&#125;&#125;&quot;,</span><br><span class=\"line\">    &quot;&lt;CFRunLoopObserver 0x600001f6c1e0 [0x1053f6b68]&gt;&#123;valid = Yes, activities = 0x20, repeats = Yes, order = 0, callout = _UIGestureRecognizerUpdateObserver (0x107bb7473), context = &lt;CFRunLoopObserver context 0x60000056dea0&gt;&#125;&quot;,</span><br><span class=\"line\">    &quot;&lt;CFRunLoopObserver 0x600001f68c80 [0x1053f6b68]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 1999000, callout = _beforeCACommitHandler (0x108014dfc), context = &lt;CFRunLoopObserver context 0x7ff475d024b0&gt;&#125;&quot;,</span><br><span class=\"line\">    &quot;&lt;CFRunLoopObserver 0x600001f68960 [0x1053f6b68]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2000000, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv (0x109a136ae), context = &lt;CFRunLoopObserver context 0x0&gt;&#125;&quot;,</span><br><span class=\"line\">    &quot;&lt;CFRunLoopObserver 0x600001f68be0 [0x1053f6b68]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2001000, callout = _afterCACommitHandler (0x108014e75), context = &lt;CFRunLoopObserver context 0x7ff475d024b0&gt;&#125;&quot;,</span><br><span class=\"line\">    &quot;&lt;CFRunLoopObserver 0x600001f68b40 [0x1053f6b68]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x107fe51b1), context = &lt;CFArray 0x600002020330 [0x1053f6b68]&gt;&#123;type = mutable-small, count = 1, values = (\\n\\t0 : &lt;0x7ff476808058&gt;\\n)&#125;&#125;&quot;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>我们查看它的activities，分别是在0x1和0xa0，那这两个分别有代表是什么呢？在runloop 的源码里我们可以找到runloop的相关枚举：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class=\"line\">     kCFRunLoopEntry = (1UL &lt;&lt; 0),  // 1</span><br><span class=\"line\">     kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 2</span><br><span class=\"line\">     kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 4</span><br><span class=\"line\">     kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 32</span><br><span class=\"line\">     kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 64</span><br><span class=\"line\">     kCFRunLoopExit = (1UL &lt;&lt; 7), // 128</span><br><span class=\"line\">     kCFRunLoopAllActivities = 0x0FFFFFFFU</span><br><span class=\"line\"> &#125;;</span><br></pre></td></tr></table></figure>\n<p>根据位运算可以的出上述结果：0x1 &#x3D; 1 等价于kCFRunLoopEntry，0xa0 &#x3D; 64 + 128 等价于 kCFRunLoopBeforeWaiting | kCFRunLoopExit，意味着runloop会在kCFRunLoopEntry时进行一次push操作，在kCFRunLoopBeforeWaiting进行一次pop操作，然后在进行一次push操作，最后会在kCFRunLoopExit时进行一次pop操作。</p>\n<p>也就是说runloop会在即将进行休眠和退出runloop是将AutoreleasePool进行释放。</p>"},{"title":"Notification与多线程","top":0,"need_not_copyright":true,"date":"2017-04-11T09:38:52.000Z","banner_img":null,"_content":"\n> 前几天与同事讨论到Notification在多线程下的转发问题，所以就此整理一下。\n\n<!-- more -->\n\n# Notification与多线程\n\n先来看看官方的文档，是这样写的：\n\nIn a multithreaded application, notifications are always delivered in the thread in which the notification was posted, which may not be the same thread in which an observer registered itself.\n\n翻译过来是：\n\n在多线程应用中，Notification在哪个线程中post，就在哪个线程中被转发，而不一定是在注册观察者的那个线程中。\n\n也就是说，Notification的发送与接收处理都是在同一个线程中。为了说明这一点，我们先来看一个示例：\n\n## Notification的发送与处理\n\n```\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    NSLog(@\"current thread = %@\", [NSThread currentThread]);\n\n    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:TEST_NOTIFICATION object:nil];\n\n    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n\n        [[NSNotificationCenter defaultCenter] postNotificationName:TEST_NOTIFICATION object:nil userInfo:nil];\n    });\n}\n\n- (void)handleNotification:(NSNotification *)notification\n{\n    NSLog(@\"current thread = %@\", [NSThread currentThread]);\n\n    NSLog(@\"test notification\");\n}\n\n@end\n```\n\n其输出结果如下：\n\n```\n2015-03-11 22:05:12.856 test[865:45102] current thread = <NSThread: 0x7fbb23412f30>{number = 1, name = main}\n2015-03-11 22:05:12.857 test[865:45174] current thread = <NSThread: 0x7fbb23552370>{number = 2, name = (null)}\n2015-03-11 22:05:12.857 test[865:45174] test notification\n```\n\n\n\n可以看到，虽然我们在主线程中注册了通知的观察者，但在全局队列中post的Notification，并不是在主线程处理的。所以，这时候就需要注意，如果我们想在回调中处理与UI相关的操作，需要确保是在主线程中执行回调。\n\n这时，就有一个问题了，如果我们的Notification是在二级线程中post的，如何能在主线程中对这个Notification进行处理呢？或者换个提法，如果我们希望一个Notification的post线程与转发线程不是同一个线程，应该怎么办呢？我们看看官方文档是怎么说的：\n\nFor example, if an object running in a background thread is listening for notifications from the user interface, such as a window closing, you would like to receive the notifications in the background thread instead of the main thread. In these cases, you must capture the notifications as they are delivered on the default thread and redirect them to the appropriate thread.\n\n这里讲到了“重定向”，就是我们在Notification所在的默认线程中捕获这些分发的通知，然后将其重定向到指定的线程中。\n\n一种重定向的实现思路是自定义一个通知队列\\(注意，不是NSNotificationQueue对象，而是一个数组\\)，让这个队列去维护那些我们需要重定向的Notification。我们仍然是像平常一样去注册一个通知的观察者，当Notification来了时，先看看post这个Notification的线程是不是我们所期望的线程，如果不是，则将这个Notification存储到我们的队列中，并发送一个信号\\(signal\\)到期望的线程中，来告诉这个线程需要处理一个Notification。指定的线程在收到信号后，将Notification从队列中移除，并进行处理。\n\n官方文档已经给出了示例代码，在此借用一下，以测试实际结果：\n\n## 在不同线程中post和转发一个Notification\n\n```\n#import \"ViewController.h\"\n\n@interface ViewController ()<NSMachPortDelegate>\n@property (nonatomic ,strong) NSMachPort *machPort;\n@property (nonatomic ,strong) NSThread *thread;\n@property (nonatomic ,strong) NSLock *lock;\n@property (nonatomic ,strong) NSMutableArray *notifiQueue;//通知队列\n@end\n\n@implementation ViewController\n\nstatic void Callback(CFNotificationCenterRef center,\n                     void *observer,\n                     CFStringRef name,\n                     const void *object,\n                     CFDictionaryRef userInfo)\n{\n    NSLog(@\"CFNotificationCenterRef====%@====%@\",[NSThread currentThread],name);\n}\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    self.notifiQueue = @[].mutableCopy;\n    self.thread = [NSThread currentThread];\n    self.lock = [[NSLock alloc] init];\n    self.machPort = [[NSMachPort alloc] init];\n    self.machPort.delegate = self;\n    \n    // 往当前线程的run loop添加端口源\n    // 当Mach消息到达而接收线程的runloop没有运行时，则内核会保存这条消息，直到下一次进入runloop\n    [[NSRunLoop currentRunLoop] addPort:self.machPort forMode:(__bridge NSString *)kCFRunLoopCommonModes];\n    \n    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(processNotification:) name:@\"TestNotification\" object:nil];\n    \n    //CFNotificationCenterRef:通过CFNotificationCenterRef发送出来的通知无论是在子线程还是主线程最终都会h转发到主线程中\n    CFNotificationCenterRef center = CFNotificationCenterGetDarwinNotifyCenter();\n\n    CFNotificationSuspensionBehavior behavior = CFNotificationSuspensionBehaviorDeliverImmediately;\n\n    CFNotificationCenterAddObserver(center,\n                                    NULL,\n                                    Callback,\n                                    CFSTR(\"notification.identifier\"),\n                                    NULL,\n                                    behavior);\n    //NSNotificationCenter:子线程发出的通知依旧在子线程\n    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(doSome:) name:@\"notification.identifier\" object:nil];\n}\n\n- (void)doSome:(NSNotification *)notifi {\n    NSLog(@\"NSNotificationCenter====%@====%@\",[NSThread currentThread],notifi.name);\n}\n\n- (void)processNotification:(NSNotification *)notifi {\n    if ([NSThread currentThread] != self.thread) {\n        NSLog(@\"NSMachPort if====%@====%@\",[NSThread currentThread],notifi.name);\n        [self.lock lock];\n        [self.notifiQueue addObject:notifi];\n        [self.lock unlock];\n        //通过MachPort转发子线程通知到主线程\n        [self.machPort sendBeforeDate:[NSDate date]\n                                   components:nil\n                                         from:nil\n                                     reserved:0];\n    } else {\n        NSLog(@\"NSMachPort else====%@====%@\", [NSThread currentThread],notifi.name);\n    }\n}\n\n// MARK: - NSMachPortDelegate\n\n- (void)handleMachMessage:(void *)msg {\n    [self.lock lock];\n    NSLog(@\"self.notifiQueue ==== %@\",self.notifiQueue);\n    while ([self.notifiQueue count]) {\n        NSNotification *notification = [self.notifiQueue objectAtIndex:0];\n        [self.notifiQueue removeObjectAtIndex:0];\n        [self.lock unlock];\n        [self processNotification:notification];\n        [self.lock lock];\n    };\n    [self.lock unlock];\n}\n\n@end\n\n// 其它地方\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n        void *Object;\n        CFDictionaryRef userInfo;\n        CFNotificationCenterRef center = CFNotificationCenterGetDarwinNotifyCenter();\n        CFNotificationCenterPostNotification(center,\n                                             CFSTR(\"notification.identifier\"),\n                                             Object,\n                                             userInfo,\n                                             true);\n        NSLog(@\"CFNotificationCenterRef====%@====%p\",[NSThread currentThread],Object);\n        [[NSNotificationCenter defaultCenter] postNotificationName:@\"notification.identifier\" object:nil];\n        [[NSNotificationCenter defaultCenter] postNotificationName:@\"TestNotification\" object:nil];\n        NSLog(@\"NSNotificationCenter====%@\",[NSThread currentThread]);\n    });\n```\n\n\n\n上面的代码就是我们通常所做的事情：添加一个通知监听者，定义一个回调，并在所属对象释放时移除监听者；然后在程序的某个地方post一个通知。简单明了，如果这一切都是发生在一个线程里面，或者至少dealloc方法是在-postNotificationName:的线程中运行的\\(注意：NSNotification的post和转发是同步的\\)，那么都OK，没有线程安全问题。但如果dealloc方法和-postNotificationName:方法不在同一个线程中运行时，会出现什么问题呢？\n\n我们再改造一下上面的代码：\n\n\n\n## NSNotificationCenter引发的线程安全问题\n\n\n\n```\n#pragma mark - Poster\n\t\n@interface Poster : NSObject\n\t\n@end\n\t\n@implementation Poster\n\t\n- (instancetype)init\n{\n    self = [super init];\n    \n    if (self)\n    {\n        [self performSelectorInBackground:@selector(postNotification) withObject:nil];\n    }\n    \n    return self;\n}\n\t\n- (void)postNotification\n{\n    [[NSNotificationCenter defaultCenter] postNotificationName:TEST_NOTIFICATION object:nil];\n}\n\t\n@end\n\t\n#pragma mark - Observer\n\t\n@interface Observer : NSObject\n{\n    Poster  *_poster;\n}\n\t\n@property (nonatomic, assign) NSInteger i;\n\t\n@end\n\t\n@implementation Observer\n\t\n- (instancetype)init\n{\n    self = [super init];\n    \n    if (self)\n    {\n        _poster = [[Poster alloc] init];\n        \n        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:TEST_NOTIFICATION object:nil];\n    }\n    \n    return self;\n}\n\t\n- (void)handleNotification:(NSNotification *)notification\n{\n    NSLog(@\"handle notification begin\");\n    sleep(1);\n    NSLog(@\"handle notification end\");\n    \n    self.i = 10;\n}\n\t\n- (void)dealloc\n{\n    [[NSNotificationCenter defaultCenter] removeObserver:self];\n    \n    NSLog(@\"Observer dealloc\");\n}\n\t\n@end\n\t\n#pragma mark - ViewController\n\t\n@implementation ViewController\n\t\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    __autoreleasing Observer *observer = [[Observer alloc] init];\n}\n\t\n@end\n```\n\n\n\n这段代码是在主线程添加了一个TEST\\_NOTIFICATION通知的监听者，并在主线程中将其移除，而我们的NSNotification是在后台线程中post的。在通知处理函数中，我们让回调所在的线程睡眠1秒钟，然后再去设置属性i值。这时会发生什么呢？我们先来看看输出结果：\n\n```\n2015-03-14 00:31:41.286 SKTest[932:88791] handle notification begin\n2015-03-14 00:31:41.291 SKTest[932:88713] Observer dealloc\n2015-03-14 00:31:42.361 SKTest[932:88791] handle notification end\n(lldb) \n\t\n// 程序在self.i = 10处抛出了\"Thread 6: EXC_BAD_ACCESS(code=EXC_I386_GPFLT)\"\n```\n\n经典的内存错误，程序崩溃了。其实从输出结果中，我们就可以看到到底是发生了什么事。我们简要描述一下：\n\n1. 当我们注册一个观察者是，通知中心会持有观察者的一个弱引用，来确保观察者是可用的。\n2. 主线程调用dealloc操作会让Observer对象的引用计数减为0，这时对象会被释放掉。\n3. 后台线程发送一个通知，如果此时Observer还未被释放，则会向其转发消息，并执行回调方法。而如果在回调执行的过程中对象被释放了，就会出现上面的问题。\n\n当然，上面这个例子是故意而为之，但不排除在实际编码中会遇到类似的问题。虽然NSNotificationCenter是线程安全的，但并不意味着我们在使用时就可以保证线程安全的，如果稍不注意，还是会出现线程问题。\n\n那我们该怎么做呢？这里有一些好的建议：\n\n1. 尽量在一个线程中处理通知相关的操作，大部分情况下，这样做都能确保通知的正常工作。不过，我们无法确定到底会在哪个线程中调用dealloc方法，所以这一点还是比较困难。\n2. 注册监听都时，使用基于block的API。这样我们在block还要继续调用self的属性或方法，就可以通过weak-strong的方式来处理。具体大家可以改造下上面的代码试试是什么效果。\n3. 使用带有安全生命周期的对象，这一点对象单例对象来说再合适不过了，在应用的整个生命周期都不会被释放。\n4. 使用代理。\n\n# 小结\n\nNSNotificationCenter虽然是线程安全的，但不要被这个事实所误导。在涉及到多线程时，我们还是需要多加小心，避免出现上面的线程问题。想进一步了解的话，可以查看[Observers and Thread Safety](http://inessential.com/2013/12/20/observers_and_thread_safety)。\n\n","source":"_posts/Notification与多线程.md","raw":"---\ntitle: Notification与多线程\ntags: [通知, 多线程]\ntop: 0\nneed_not_copyright: true\ndate: 2017-04-11 17:38:52\ncategories: 多线程\nbanner_img:\n---\n\n> 前几天与同事讨论到Notification在多线程下的转发问题，所以就此整理一下。\n\n<!-- more -->\n\n# Notification与多线程\n\n先来看看官方的文档，是这样写的：\n\nIn a multithreaded application, notifications are always delivered in the thread in which the notification was posted, which may not be the same thread in which an observer registered itself.\n\n翻译过来是：\n\n在多线程应用中，Notification在哪个线程中post，就在哪个线程中被转发，而不一定是在注册观察者的那个线程中。\n\n也就是说，Notification的发送与接收处理都是在同一个线程中。为了说明这一点，我们先来看一个示例：\n\n## Notification的发送与处理\n\n```\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    NSLog(@\"current thread = %@\", [NSThread currentThread]);\n\n    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:TEST_NOTIFICATION object:nil];\n\n    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n\n        [[NSNotificationCenter defaultCenter] postNotificationName:TEST_NOTIFICATION object:nil userInfo:nil];\n    });\n}\n\n- (void)handleNotification:(NSNotification *)notification\n{\n    NSLog(@\"current thread = %@\", [NSThread currentThread]);\n\n    NSLog(@\"test notification\");\n}\n\n@end\n```\n\n其输出结果如下：\n\n```\n2015-03-11 22:05:12.856 test[865:45102] current thread = <NSThread: 0x7fbb23412f30>{number = 1, name = main}\n2015-03-11 22:05:12.857 test[865:45174] current thread = <NSThread: 0x7fbb23552370>{number = 2, name = (null)}\n2015-03-11 22:05:12.857 test[865:45174] test notification\n```\n\n\n\n可以看到，虽然我们在主线程中注册了通知的观察者，但在全局队列中post的Notification，并不是在主线程处理的。所以，这时候就需要注意，如果我们想在回调中处理与UI相关的操作，需要确保是在主线程中执行回调。\n\n这时，就有一个问题了，如果我们的Notification是在二级线程中post的，如何能在主线程中对这个Notification进行处理呢？或者换个提法，如果我们希望一个Notification的post线程与转发线程不是同一个线程，应该怎么办呢？我们看看官方文档是怎么说的：\n\nFor example, if an object running in a background thread is listening for notifications from the user interface, such as a window closing, you would like to receive the notifications in the background thread instead of the main thread. In these cases, you must capture the notifications as they are delivered on the default thread and redirect them to the appropriate thread.\n\n这里讲到了“重定向”，就是我们在Notification所在的默认线程中捕获这些分发的通知，然后将其重定向到指定的线程中。\n\n一种重定向的实现思路是自定义一个通知队列\\(注意，不是NSNotificationQueue对象，而是一个数组\\)，让这个队列去维护那些我们需要重定向的Notification。我们仍然是像平常一样去注册一个通知的观察者，当Notification来了时，先看看post这个Notification的线程是不是我们所期望的线程，如果不是，则将这个Notification存储到我们的队列中，并发送一个信号\\(signal\\)到期望的线程中，来告诉这个线程需要处理一个Notification。指定的线程在收到信号后，将Notification从队列中移除，并进行处理。\n\n官方文档已经给出了示例代码，在此借用一下，以测试实际结果：\n\n## 在不同线程中post和转发一个Notification\n\n```\n#import \"ViewController.h\"\n\n@interface ViewController ()<NSMachPortDelegate>\n@property (nonatomic ,strong) NSMachPort *machPort;\n@property (nonatomic ,strong) NSThread *thread;\n@property (nonatomic ,strong) NSLock *lock;\n@property (nonatomic ,strong) NSMutableArray *notifiQueue;//通知队列\n@end\n\n@implementation ViewController\n\nstatic void Callback(CFNotificationCenterRef center,\n                     void *observer,\n                     CFStringRef name,\n                     const void *object,\n                     CFDictionaryRef userInfo)\n{\n    NSLog(@\"CFNotificationCenterRef====%@====%@\",[NSThread currentThread],name);\n}\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    self.notifiQueue = @[].mutableCopy;\n    self.thread = [NSThread currentThread];\n    self.lock = [[NSLock alloc] init];\n    self.machPort = [[NSMachPort alloc] init];\n    self.machPort.delegate = self;\n    \n    // 往当前线程的run loop添加端口源\n    // 当Mach消息到达而接收线程的runloop没有运行时，则内核会保存这条消息，直到下一次进入runloop\n    [[NSRunLoop currentRunLoop] addPort:self.machPort forMode:(__bridge NSString *)kCFRunLoopCommonModes];\n    \n    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(processNotification:) name:@\"TestNotification\" object:nil];\n    \n    //CFNotificationCenterRef:通过CFNotificationCenterRef发送出来的通知无论是在子线程还是主线程最终都会h转发到主线程中\n    CFNotificationCenterRef center = CFNotificationCenterGetDarwinNotifyCenter();\n\n    CFNotificationSuspensionBehavior behavior = CFNotificationSuspensionBehaviorDeliverImmediately;\n\n    CFNotificationCenterAddObserver(center,\n                                    NULL,\n                                    Callback,\n                                    CFSTR(\"notification.identifier\"),\n                                    NULL,\n                                    behavior);\n    //NSNotificationCenter:子线程发出的通知依旧在子线程\n    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(doSome:) name:@\"notification.identifier\" object:nil];\n}\n\n- (void)doSome:(NSNotification *)notifi {\n    NSLog(@\"NSNotificationCenter====%@====%@\",[NSThread currentThread],notifi.name);\n}\n\n- (void)processNotification:(NSNotification *)notifi {\n    if ([NSThread currentThread] != self.thread) {\n        NSLog(@\"NSMachPort if====%@====%@\",[NSThread currentThread],notifi.name);\n        [self.lock lock];\n        [self.notifiQueue addObject:notifi];\n        [self.lock unlock];\n        //通过MachPort转发子线程通知到主线程\n        [self.machPort sendBeforeDate:[NSDate date]\n                                   components:nil\n                                         from:nil\n                                     reserved:0];\n    } else {\n        NSLog(@\"NSMachPort else====%@====%@\", [NSThread currentThread],notifi.name);\n    }\n}\n\n// MARK: - NSMachPortDelegate\n\n- (void)handleMachMessage:(void *)msg {\n    [self.lock lock];\n    NSLog(@\"self.notifiQueue ==== %@\",self.notifiQueue);\n    while ([self.notifiQueue count]) {\n        NSNotification *notification = [self.notifiQueue objectAtIndex:0];\n        [self.notifiQueue removeObjectAtIndex:0];\n        [self.lock unlock];\n        [self processNotification:notification];\n        [self.lock lock];\n    };\n    [self.lock unlock];\n}\n\n@end\n\n// 其它地方\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n        void *Object;\n        CFDictionaryRef userInfo;\n        CFNotificationCenterRef center = CFNotificationCenterGetDarwinNotifyCenter();\n        CFNotificationCenterPostNotification(center,\n                                             CFSTR(\"notification.identifier\"),\n                                             Object,\n                                             userInfo,\n                                             true);\n        NSLog(@\"CFNotificationCenterRef====%@====%p\",[NSThread currentThread],Object);\n        [[NSNotificationCenter defaultCenter] postNotificationName:@\"notification.identifier\" object:nil];\n        [[NSNotificationCenter defaultCenter] postNotificationName:@\"TestNotification\" object:nil];\n        NSLog(@\"NSNotificationCenter====%@\",[NSThread currentThread]);\n    });\n```\n\n\n\n上面的代码就是我们通常所做的事情：添加一个通知监听者，定义一个回调，并在所属对象释放时移除监听者；然后在程序的某个地方post一个通知。简单明了，如果这一切都是发生在一个线程里面，或者至少dealloc方法是在-postNotificationName:的线程中运行的\\(注意：NSNotification的post和转发是同步的\\)，那么都OK，没有线程安全问题。但如果dealloc方法和-postNotificationName:方法不在同一个线程中运行时，会出现什么问题呢？\n\n我们再改造一下上面的代码：\n\n\n\n## NSNotificationCenter引发的线程安全问题\n\n\n\n```\n#pragma mark - Poster\n\t\n@interface Poster : NSObject\n\t\n@end\n\t\n@implementation Poster\n\t\n- (instancetype)init\n{\n    self = [super init];\n    \n    if (self)\n    {\n        [self performSelectorInBackground:@selector(postNotification) withObject:nil];\n    }\n    \n    return self;\n}\n\t\n- (void)postNotification\n{\n    [[NSNotificationCenter defaultCenter] postNotificationName:TEST_NOTIFICATION object:nil];\n}\n\t\n@end\n\t\n#pragma mark - Observer\n\t\n@interface Observer : NSObject\n{\n    Poster  *_poster;\n}\n\t\n@property (nonatomic, assign) NSInteger i;\n\t\n@end\n\t\n@implementation Observer\n\t\n- (instancetype)init\n{\n    self = [super init];\n    \n    if (self)\n    {\n        _poster = [[Poster alloc] init];\n        \n        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:TEST_NOTIFICATION object:nil];\n    }\n    \n    return self;\n}\n\t\n- (void)handleNotification:(NSNotification *)notification\n{\n    NSLog(@\"handle notification begin\");\n    sleep(1);\n    NSLog(@\"handle notification end\");\n    \n    self.i = 10;\n}\n\t\n- (void)dealloc\n{\n    [[NSNotificationCenter defaultCenter] removeObserver:self];\n    \n    NSLog(@\"Observer dealloc\");\n}\n\t\n@end\n\t\n#pragma mark - ViewController\n\t\n@implementation ViewController\n\t\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    __autoreleasing Observer *observer = [[Observer alloc] init];\n}\n\t\n@end\n```\n\n\n\n这段代码是在主线程添加了一个TEST\\_NOTIFICATION通知的监听者，并在主线程中将其移除，而我们的NSNotification是在后台线程中post的。在通知处理函数中，我们让回调所在的线程睡眠1秒钟，然后再去设置属性i值。这时会发生什么呢？我们先来看看输出结果：\n\n```\n2015-03-14 00:31:41.286 SKTest[932:88791] handle notification begin\n2015-03-14 00:31:41.291 SKTest[932:88713] Observer dealloc\n2015-03-14 00:31:42.361 SKTest[932:88791] handle notification end\n(lldb) \n\t\n// 程序在self.i = 10处抛出了\"Thread 6: EXC_BAD_ACCESS(code=EXC_I386_GPFLT)\"\n```\n\n经典的内存错误，程序崩溃了。其实从输出结果中，我们就可以看到到底是发生了什么事。我们简要描述一下：\n\n1. 当我们注册一个观察者是，通知中心会持有观察者的一个弱引用，来确保观察者是可用的。\n2. 主线程调用dealloc操作会让Observer对象的引用计数减为0，这时对象会被释放掉。\n3. 后台线程发送一个通知，如果此时Observer还未被释放，则会向其转发消息，并执行回调方法。而如果在回调执行的过程中对象被释放了，就会出现上面的问题。\n\n当然，上面这个例子是故意而为之，但不排除在实际编码中会遇到类似的问题。虽然NSNotificationCenter是线程安全的，但并不意味着我们在使用时就可以保证线程安全的，如果稍不注意，还是会出现线程问题。\n\n那我们该怎么做呢？这里有一些好的建议：\n\n1. 尽量在一个线程中处理通知相关的操作，大部分情况下，这样做都能确保通知的正常工作。不过，我们无法确定到底会在哪个线程中调用dealloc方法，所以这一点还是比较困难。\n2. 注册监听都时，使用基于block的API。这样我们在block还要继续调用self的属性或方法，就可以通过weak-strong的方式来处理。具体大家可以改造下上面的代码试试是什么效果。\n3. 使用带有安全生命周期的对象，这一点对象单例对象来说再合适不过了，在应用的整个生命周期都不会被释放。\n4. 使用代理。\n\n# 小结\n\nNSNotificationCenter虽然是线程安全的，但不要被这个事实所误导。在涉及到多线程时，我们还是需要多加小心，避免出现上面的线程问题。想进一步了解的话，可以查看[Observers and Thread Safety](http://inessential.com/2013/12/20/observers_and_thread_safety)。\n\n","slug":"Notification与多线程","published":1,"updated":"2023-07-21T09:10:33.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clkcgbp560003pfo73vgwe1bl","content":"<blockquote>\n<p>前几天与同事讨论到Notification在多线程下的转发问题，所以就此整理一下。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h1 id=\"Notification与多线程\"><a href=\"#Notification与多线程\" class=\"headerlink\" title=\"Notification与多线程\"></a>Notification与多线程</h1><p>先来看看官方的文档，是这样写的：</p>\n<p>In a multithreaded application, notifications are always delivered in the thread in which the notification was posted, which may not be the same thread in which an observer registered itself.</p>\n<p>翻译过来是：</p>\n<p>在多线程应用中，Notification在哪个线程中post，就在哪个线程中被转发，而不一定是在注册观察者的那个线程中。</p>\n<p>也就是说，Notification的发送与接收处理都是在同一个线程中。为了说明这一点，我们先来看一个示例：</p>\n<h2 id=\"Notification的发送与处理\"><a href=\"#Notification的发送与处理\" class=\"headerlink\" title=\"Notification的发送与处理\"></a>Notification的发送与处理</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation ViewController</span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;current thread = %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:TEST_NOTIFICATION object:nil];</span><br><span class=\"line\"></span><br><span class=\"line\">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        [[NSNotificationCenter defaultCenter] postNotificationName:TEST_NOTIFICATION object:nil userInfo:nil];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)handleNotification:(NSNotification *)notification</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;current thread = %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;test notification&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<p>其输出结果如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2015-03-11 22:05:12.856 test[865:45102] current thread = &lt;NSThread: 0x7fbb23412f30&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2015-03-11 22:05:12.857 test[865:45174] current thread = &lt;NSThread: 0x7fbb23552370&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">2015-03-11 22:05:12.857 test[865:45174] test notification</span><br></pre></td></tr></table></figure>\n\n\n\n<p>可以看到，虽然我们在主线程中注册了通知的观察者，但在全局队列中post的Notification，并不是在主线程处理的。所以，这时候就需要注意，如果我们想在回调中处理与UI相关的操作，需要确保是在主线程中执行回调。</p>\n<p>这时，就有一个问题了，如果我们的Notification是在二级线程中post的，如何能在主线程中对这个Notification进行处理呢？或者换个提法，如果我们希望一个Notification的post线程与转发线程不是同一个线程，应该怎么办呢？我们看看官方文档是怎么说的：</p>\n<p>For example, if an object running in a background thread is listening for notifications from the user interface, such as a window closing, you would like to receive the notifications in the background thread instead of the main thread. In these cases, you must capture the notifications as they are delivered on the default thread and redirect them to the appropriate thread.</p>\n<p>这里讲到了“重定向”，就是我们在Notification所在的默认线程中捕获这些分发的通知，然后将其重定向到指定的线程中。</p>\n<p>一种重定向的实现思路是自定义一个通知队列(注意，不是NSNotificationQueue对象，而是一个数组)，让这个队列去维护那些我们需要重定向的Notification。我们仍然是像平常一样去注册一个通知的观察者，当Notification来了时，先看看post这个Notification的线程是不是我们所期望的线程，如果不是，则将这个Notification存储到我们的队列中，并发送一个信号(signal)到期望的线程中，来告诉这个线程需要处理一个Notification。指定的线程在收到信号后，将Notification从队列中移除，并进行处理。</p>\n<p>官方文档已经给出了示例代码，在此借用一下，以测试实际结果：</p>\n<h2 id=\"在不同线程中post和转发一个Notification\"><a href=\"#在不同线程中post和转发一个Notification\" class=\"headerlink\" title=\"在不同线程中post和转发一个Notification\"></a>在不同线程中post和转发一个Notification</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;ViewController.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface ViewController ()&lt;NSMachPortDelegate&gt;</span><br><span class=\"line\">@property (nonatomic ,strong) NSMachPort *machPort;</span><br><span class=\"line\">@property (nonatomic ,strong) NSThread *thread;</span><br><span class=\"line\">@property (nonatomic ,strong) NSLock *lock;</span><br><span class=\"line\">@property (nonatomic ,strong) NSMutableArray *notifiQueue;//通知队列</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation ViewController</span><br><span class=\"line\"></span><br><span class=\"line\">static void Callback(CFNotificationCenterRef center,</span><br><span class=\"line\">                     void *observer,</span><br><span class=\"line\">                     CFStringRef name,</span><br><span class=\"line\">                     const void *object,</span><br><span class=\"line\">                     CFDictionaryRef userInfo)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;CFNotificationCenterRef====%@====%@&quot;,[NSThread currentThread],name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    self.notifiQueue = @[].mutableCopy;</span><br><span class=\"line\">    self.thread = [NSThread currentThread];</span><br><span class=\"line\">    self.lock = [[NSLock alloc] init];</span><br><span class=\"line\">    self.machPort = [[NSMachPort alloc] init];</span><br><span class=\"line\">    self.machPort.delegate = self;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 往当前线程的run loop添加端口源</span><br><span class=\"line\">    // 当Mach消息到达而接收线程的runloop没有运行时，则内核会保存这条消息，直到下一次进入runloop</span><br><span class=\"line\">    [[NSRunLoop currentRunLoop] addPort:self.machPort forMode:(__bridge NSString *)kCFRunLoopCommonModes];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(processNotification:) name:@&quot;TestNotification&quot; object:nil];</span><br><span class=\"line\">    </span><br><span class=\"line\">    //CFNotificationCenterRef:通过CFNotificationCenterRef发送出来的通知无论是在子线程还是主线程最终都会h转发到主线程中</span><br><span class=\"line\">    CFNotificationCenterRef center = CFNotificationCenterGetDarwinNotifyCenter();</span><br><span class=\"line\"></span><br><span class=\"line\">    CFNotificationSuspensionBehavior behavior = CFNotificationSuspensionBehaviorDeliverImmediately;</span><br><span class=\"line\"></span><br><span class=\"line\">    CFNotificationCenterAddObserver(center,</span><br><span class=\"line\">                                    NULL,</span><br><span class=\"line\">                                    Callback,</span><br><span class=\"line\">                                    CFSTR(&quot;notification.identifier&quot;),</span><br><span class=\"line\">                                    NULL,</span><br><span class=\"line\">                                    behavior);</span><br><span class=\"line\">    //NSNotificationCenter:子线程发出的通知依旧在子线程</span><br><span class=\"line\">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(doSome:) name:@&quot;notification.identifier&quot; object:nil];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)doSome:(NSNotification *)notifi &#123;</span><br><span class=\"line\">    NSLog(@&quot;NSNotificationCenter====%@====%@&quot;,[NSThread currentThread],notifi.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)processNotification:(NSNotification *)notifi &#123;</span><br><span class=\"line\">    if ([NSThread currentThread] != self.thread) &#123;</span><br><span class=\"line\">        NSLog(@&quot;NSMachPort if====%@====%@&quot;,[NSThread currentThread],notifi.name);</span><br><span class=\"line\">        [self.lock lock];</span><br><span class=\"line\">        [self.notifiQueue addObject:notifi];</span><br><span class=\"line\">        [self.lock unlock];</span><br><span class=\"line\">        //通过MachPort转发子线程通知到主线程</span><br><span class=\"line\">        [self.machPort sendBeforeDate:[NSDate date]</span><br><span class=\"line\">                                   components:nil</span><br><span class=\"line\">                                         from:nil</span><br><span class=\"line\">                                     reserved:0];</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        NSLog(@&quot;NSMachPort else====%@====%@&quot;, [NSThread currentThread],notifi.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// MARK: - NSMachPortDelegate</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)handleMachMessage:(void *)msg &#123;</span><br><span class=\"line\">    [self.lock lock];</span><br><span class=\"line\">    NSLog(@&quot;self.notifiQueue ==== %@&quot;,self.notifiQueue);</span><br><span class=\"line\">    while ([self.notifiQueue count]) &#123;</span><br><span class=\"line\">        NSNotification *notification = [self.notifiQueue objectAtIndex:0];</span><br><span class=\"line\">        [self.notifiQueue removeObjectAtIndex:0];</span><br><span class=\"line\">        [self.lock unlock];</span><br><span class=\"line\">        [self processNotification:notification];</span><br><span class=\"line\">        [self.lock lock];</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    [self.lock unlock];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">// 其它地方</span><br><span class=\"line\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class=\"line\">        void *Object;</span><br><span class=\"line\">        CFDictionaryRef userInfo;</span><br><span class=\"line\">        CFNotificationCenterRef center = CFNotificationCenterGetDarwinNotifyCenter();</span><br><span class=\"line\">        CFNotificationCenterPostNotification(center,</span><br><span class=\"line\">                                             CFSTR(&quot;notification.identifier&quot;),</span><br><span class=\"line\">                                             Object,</span><br><span class=\"line\">                                             userInfo,</span><br><span class=\"line\">                                             true);</span><br><span class=\"line\">        NSLog(@&quot;CFNotificationCenterRef====%@====%p&quot;,[NSThread currentThread],Object);</span><br><span class=\"line\">        [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;notification.identifier&quot; object:nil];</span><br><span class=\"line\">        [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;TestNotification&quot; object:nil];</span><br><span class=\"line\">        NSLog(@&quot;NSNotificationCenter====%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>上面的代码就是我们通常所做的事情：添加一个通知监听者，定义一个回调，并在所属对象释放时移除监听者；然后在程序的某个地方post一个通知。简单明了，如果这一切都是发生在一个线程里面，或者至少dealloc方法是在-postNotificationName:的线程中运行的(注意：NSNotification的post和转发是同步的)，那么都OK，没有线程安全问题。但如果dealloc方法和-postNotificationName:方法不在同一个线程中运行时，会出现什么问题呢？</p>\n<p>我们再改造一下上面的代码：</p>\n<h2 id=\"NSNotificationCenter引发的线程安全问题\"><a href=\"#NSNotificationCenter引发的线程安全问题\" class=\"headerlink\" title=\"NSNotificationCenter引发的线程安全问题\"></a>NSNotificationCenter引发的线程安全问题</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#pragma mark - Poster</span><br><span class=\"line\">\t</span><br><span class=\"line\">@interface Poster : NSObject</span><br><span class=\"line\">\t</span><br><span class=\"line\">@end</span><br><span class=\"line\">\t</span><br><span class=\"line\">@implementation Poster</span><br><span class=\"line\">\t</span><br><span class=\"line\">- (instancetype)init</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    self = [super init];</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (self)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        [self performSelectorInBackground:@selector(postNotification) withObject:nil];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">- (void)postNotification</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [[NSNotificationCenter defaultCenter] postNotificationName:TEST_NOTIFICATION object:nil];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">@end</span><br><span class=\"line\">\t</span><br><span class=\"line\">#pragma mark - Observer</span><br><span class=\"line\">\t</span><br><span class=\"line\">@interface Observer : NSObject</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Poster  *_poster;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">@property (nonatomic, assign) NSInteger i;</span><br><span class=\"line\">\t</span><br><span class=\"line\">@end</span><br><span class=\"line\">\t</span><br><span class=\"line\">@implementation Observer</span><br><span class=\"line\">\t</span><br><span class=\"line\">- (instancetype)init</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    self = [super init];</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (self)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _poster = [[Poster alloc] init];</span><br><span class=\"line\">        </span><br><span class=\"line\">        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:TEST_NOTIFICATION object:nil];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">- (void)handleNotification:(NSNotification *)notification</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;handle notification begin&quot;);</span><br><span class=\"line\">    sleep(1);</span><br><span class=\"line\">    NSLog(@&quot;handle notification end&quot;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    self.i = 10;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">- (void)dealloc</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [[NSNotificationCenter defaultCenter] removeObserver:self];</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;Observer dealloc&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">@end</span><br><span class=\"line\">\t</span><br><span class=\"line\">#pragma mark - ViewController</span><br><span class=\"line\">\t</span><br><span class=\"line\">@implementation ViewController</span><br><span class=\"line\">\t</span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    __autoreleasing Observer *observer = [[Observer alloc] init];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n\n\n<p>这段代码是在主线程添加了一个TEST_NOTIFICATION通知的监听者，并在主线程中将其移除，而我们的NSNotification是在后台线程中post的。在通知处理函数中，我们让回调所在的线程睡眠1秒钟，然后再去设置属性i值。这时会发生什么呢？我们先来看看输出结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2015-03-14 00:31:41.286 SKTest[932:88791] handle notification begin</span><br><span class=\"line\">2015-03-14 00:31:41.291 SKTest[932:88713] Observer dealloc</span><br><span class=\"line\">2015-03-14 00:31:42.361 SKTest[932:88791] handle notification end</span><br><span class=\"line\">(lldb) </span><br><span class=\"line\">\t</span><br><span class=\"line\">// 程序在self.i = 10处抛出了&quot;Thread 6: EXC_BAD_ACCESS(code=EXC_I386_GPFLT)&quot;</span><br></pre></td></tr></table></figure>\n\n<p>经典的内存错误，程序崩溃了。其实从输出结果中，我们就可以看到到底是发生了什么事。我们简要描述一下：</p>\n<ol>\n<li>当我们注册一个观察者是，通知中心会持有观察者的一个弱引用，来确保观察者是可用的。</li>\n<li>主线程调用dealloc操作会让Observer对象的引用计数减为0，这时对象会被释放掉。</li>\n<li>后台线程发送一个通知，如果此时Observer还未被释放，则会向其转发消息，并执行回调方法。而如果在回调执行的过程中对象被释放了，就会出现上面的问题。</li>\n</ol>\n<p>当然，上面这个例子是故意而为之，但不排除在实际编码中会遇到类似的问题。虽然NSNotificationCenter是线程安全的，但并不意味着我们在使用时就可以保证线程安全的，如果稍不注意，还是会出现线程问题。</p>\n<p>那我们该怎么做呢？这里有一些好的建议：</p>\n<ol>\n<li>尽量在一个线程中处理通知相关的操作，大部分情况下，这样做都能确保通知的正常工作。不过，我们无法确定到底会在哪个线程中调用dealloc方法，所以这一点还是比较困难。</li>\n<li>注册监听都时，使用基于block的API。这样我们在block还要继续调用self的属性或方法，就可以通过weak-strong的方式来处理。具体大家可以改造下上面的代码试试是什么效果。</li>\n<li>使用带有安全生命周期的对象，这一点对象单例对象来说再合适不过了，在应用的整个生命周期都不会被释放。</li>\n<li>使用代理。</li>\n</ol>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>NSNotificationCenter虽然是线程安全的，但不要被这个事实所误导。在涉及到多线程时，我们还是需要多加小心，避免出现上面的线程问题。想进一步了解的话，可以查看<a href=\"http://inessential.com/2013/12/20/observers_and_thread_safety\">Observers and Thread Safety</a>。</p>\n","site":{"data":{}},"length":8399,"excerpt":"<blockquote>\n<p>前几天与同事讨论到Notification在多线程下的转发问题，所以就此整理一下。</p>\n</blockquote>","more":"<h1 id=\"Notification与多线程\"><a href=\"#Notification与多线程\" class=\"headerlink\" title=\"Notification与多线程\"></a>Notification与多线程</h1><p>先来看看官方的文档，是这样写的：</p>\n<p>In a multithreaded application, notifications are always delivered in the thread in which the notification was posted, which may not be the same thread in which an observer registered itself.</p>\n<p>翻译过来是：</p>\n<p>在多线程应用中，Notification在哪个线程中post，就在哪个线程中被转发，而不一定是在注册观察者的那个线程中。</p>\n<p>也就是说，Notification的发送与接收处理都是在同一个线程中。为了说明这一点，我们先来看一个示例：</p>\n<h2 id=\"Notification的发送与处理\"><a href=\"#Notification的发送与处理\" class=\"headerlink\" title=\"Notification的发送与处理\"></a>Notification的发送与处理</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation ViewController</span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;current thread = %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:TEST_NOTIFICATION object:nil];</span><br><span class=\"line\"></span><br><span class=\"line\">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        [[NSNotificationCenter defaultCenter] postNotificationName:TEST_NOTIFICATION object:nil userInfo:nil];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)handleNotification:(NSNotification *)notification</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;current thread = %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;test notification&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<p>其输出结果如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2015-03-11 22:05:12.856 test[865:45102] current thread = &lt;NSThread: 0x7fbb23412f30&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2015-03-11 22:05:12.857 test[865:45174] current thread = &lt;NSThread: 0x7fbb23552370&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">2015-03-11 22:05:12.857 test[865:45174] test notification</span><br></pre></td></tr></table></figure>\n\n\n\n<p>可以看到，虽然我们在主线程中注册了通知的观察者，但在全局队列中post的Notification，并不是在主线程处理的。所以，这时候就需要注意，如果我们想在回调中处理与UI相关的操作，需要确保是在主线程中执行回调。</p>\n<p>这时，就有一个问题了，如果我们的Notification是在二级线程中post的，如何能在主线程中对这个Notification进行处理呢？或者换个提法，如果我们希望一个Notification的post线程与转发线程不是同一个线程，应该怎么办呢？我们看看官方文档是怎么说的：</p>\n<p>For example, if an object running in a background thread is listening for notifications from the user interface, such as a window closing, you would like to receive the notifications in the background thread instead of the main thread. In these cases, you must capture the notifications as they are delivered on the default thread and redirect them to the appropriate thread.</p>\n<p>这里讲到了“重定向”，就是我们在Notification所在的默认线程中捕获这些分发的通知，然后将其重定向到指定的线程中。</p>\n<p>一种重定向的实现思路是自定义一个通知队列(注意，不是NSNotificationQueue对象，而是一个数组)，让这个队列去维护那些我们需要重定向的Notification。我们仍然是像平常一样去注册一个通知的观察者，当Notification来了时，先看看post这个Notification的线程是不是我们所期望的线程，如果不是，则将这个Notification存储到我们的队列中，并发送一个信号(signal)到期望的线程中，来告诉这个线程需要处理一个Notification。指定的线程在收到信号后，将Notification从队列中移除，并进行处理。</p>\n<p>官方文档已经给出了示例代码，在此借用一下，以测试实际结果：</p>\n<h2 id=\"在不同线程中post和转发一个Notification\"><a href=\"#在不同线程中post和转发一个Notification\" class=\"headerlink\" title=\"在不同线程中post和转发一个Notification\"></a>在不同线程中post和转发一个Notification</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;ViewController.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface ViewController ()&lt;NSMachPortDelegate&gt;</span><br><span class=\"line\">@property (nonatomic ,strong) NSMachPort *machPort;</span><br><span class=\"line\">@property (nonatomic ,strong) NSThread *thread;</span><br><span class=\"line\">@property (nonatomic ,strong) NSLock *lock;</span><br><span class=\"line\">@property (nonatomic ,strong) NSMutableArray *notifiQueue;//通知队列</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation ViewController</span><br><span class=\"line\"></span><br><span class=\"line\">static void Callback(CFNotificationCenterRef center,</span><br><span class=\"line\">                     void *observer,</span><br><span class=\"line\">                     CFStringRef name,</span><br><span class=\"line\">                     const void *object,</span><br><span class=\"line\">                     CFDictionaryRef userInfo)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;CFNotificationCenterRef====%@====%@&quot;,[NSThread currentThread],name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    self.notifiQueue = @[].mutableCopy;</span><br><span class=\"line\">    self.thread = [NSThread currentThread];</span><br><span class=\"line\">    self.lock = [[NSLock alloc] init];</span><br><span class=\"line\">    self.machPort = [[NSMachPort alloc] init];</span><br><span class=\"line\">    self.machPort.delegate = self;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 往当前线程的run loop添加端口源</span><br><span class=\"line\">    // 当Mach消息到达而接收线程的runloop没有运行时，则内核会保存这条消息，直到下一次进入runloop</span><br><span class=\"line\">    [[NSRunLoop currentRunLoop] addPort:self.machPort forMode:(__bridge NSString *)kCFRunLoopCommonModes];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(processNotification:) name:@&quot;TestNotification&quot; object:nil];</span><br><span class=\"line\">    </span><br><span class=\"line\">    //CFNotificationCenterRef:通过CFNotificationCenterRef发送出来的通知无论是在子线程还是主线程最终都会h转发到主线程中</span><br><span class=\"line\">    CFNotificationCenterRef center = CFNotificationCenterGetDarwinNotifyCenter();</span><br><span class=\"line\"></span><br><span class=\"line\">    CFNotificationSuspensionBehavior behavior = CFNotificationSuspensionBehaviorDeliverImmediately;</span><br><span class=\"line\"></span><br><span class=\"line\">    CFNotificationCenterAddObserver(center,</span><br><span class=\"line\">                                    NULL,</span><br><span class=\"line\">                                    Callback,</span><br><span class=\"line\">                                    CFSTR(&quot;notification.identifier&quot;),</span><br><span class=\"line\">                                    NULL,</span><br><span class=\"line\">                                    behavior);</span><br><span class=\"line\">    //NSNotificationCenter:子线程发出的通知依旧在子线程</span><br><span class=\"line\">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(doSome:) name:@&quot;notification.identifier&quot; object:nil];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)doSome:(NSNotification *)notifi &#123;</span><br><span class=\"line\">    NSLog(@&quot;NSNotificationCenter====%@====%@&quot;,[NSThread currentThread],notifi.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)processNotification:(NSNotification *)notifi &#123;</span><br><span class=\"line\">    if ([NSThread currentThread] != self.thread) &#123;</span><br><span class=\"line\">        NSLog(@&quot;NSMachPort if====%@====%@&quot;,[NSThread currentThread],notifi.name);</span><br><span class=\"line\">        [self.lock lock];</span><br><span class=\"line\">        [self.notifiQueue addObject:notifi];</span><br><span class=\"line\">        [self.lock unlock];</span><br><span class=\"line\">        //通过MachPort转发子线程通知到主线程</span><br><span class=\"line\">        [self.machPort sendBeforeDate:[NSDate date]</span><br><span class=\"line\">                                   components:nil</span><br><span class=\"line\">                                         from:nil</span><br><span class=\"line\">                                     reserved:0];</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        NSLog(@&quot;NSMachPort else====%@====%@&quot;, [NSThread currentThread],notifi.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// MARK: - NSMachPortDelegate</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)handleMachMessage:(void *)msg &#123;</span><br><span class=\"line\">    [self.lock lock];</span><br><span class=\"line\">    NSLog(@&quot;self.notifiQueue ==== %@&quot;,self.notifiQueue);</span><br><span class=\"line\">    while ([self.notifiQueue count]) &#123;</span><br><span class=\"line\">        NSNotification *notification = [self.notifiQueue objectAtIndex:0];</span><br><span class=\"line\">        [self.notifiQueue removeObjectAtIndex:0];</span><br><span class=\"line\">        [self.lock unlock];</span><br><span class=\"line\">        [self processNotification:notification];</span><br><span class=\"line\">        [self.lock lock];</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    [self.lock unlock];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">// 其它地方</span><br><span class=\"line\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class=\"line\">        void *Object;</span><br><span class=\"line\">        CFDictionaryRef userInfo;</span><br><span class=\"line\">        CFNotificationCenterRef center = CFNotificationCenterGetDarwinNotifyCenter();</span><br><span class=\"line\">        CFNotificationCenterPostNotification(center,</span><br><span class=\"line\">                                             CFSTR(&quot;notification.identifier&quot;),</span><br><span class=\"line\">                                             Object,</span><br><span class=\"line\">                                             userInfo,</span><br><span class=\"line\">                                             true);</span><br><span class=\"line\">        NSLog(@&quot;CFNotificationCenterRef====%@====%p&quot;,[NSThread currentThread],Object);</span><br><span class=\"line\">        [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;notification.identifier&quot; object:nil];</span><br><span class=\"line\">        [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;TestNotification&quot; object:nil];</span><br><span class=\"line\">        NSLog(@&quot;NSNotificationCenter====%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>上面的代码就是我们通常所做的事情：添加一个通知监听者，定义一个回调，并在所属对象释放时移除监听者；然后在程序的某个地方post一个通知。简单明了，如果这一切都是发生在一个线程里面，或者至少dealloc方法是在-postNotificationName:的线程中运行的(注意：NSNotification的post和转发是同步的)，那么都OK，没有线程安全问题。但如果dealloc方法和-postNotificationName:方法不在同一个线程中运行时，会出现什么问题呢？</p>\n<p>我们再改造一下上面的代码：</p>\n<h2 id=\"NSNotificationCenter引发的线程安全问题\"><a href=\"#NSNotificationCenter引发的线程安全问题\" class=\"headerlink\" title=\"NSNotificationCenter引发的线程安全问题\"></a>NSNotificationCenter引发的线程安全问题</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#pragma mark - Poster</span><br><span class=\"line\">\t</span><br><span class=\"line\">@interface Poster : NSObject</span><br><span class=\"line\">\t</span><br><span class=\"line\">@end</span><br><span class=\"line\">\t</span><br><span class=\"line\">@implementation Poster</span><br><span class=\"line\">\t</span><br><span class=\"line\">- (instancetype)init</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    self = [super init];</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (self)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        [self performSelectorInBackground:@selector(postNotification) withObject:nil];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">- (void)postNotification</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [[NSNotificationCenter defaultCenter] postNotificationName:TEST_NOTIFICATION object:nil];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">@end</span><br><span class=\"line\">\t</span><br><span class=\"line\">#pragma mark - Observer</span><br><span class=\"line\">\t</span><br><span class=\"line\">@interface Observer : NSObject</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Poster  *_poster;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">@property (nonatomic, assign) NSInteger i;</span><br><span class=\"line\">\t</span><br><span class=\"line\">@end</span><br><span class=\"line\">\t</span><br><span class=\"line\">@implementation Observer</span><br><span class=\"line\">\t</span><br><span class=\"line\">- (instancetype)init</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    self = [super init];</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (self)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _poster = [[Poster alloc] init];</span><br><span class=\"line\">        </span><br><span class=\"line\">        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:TEST_NOTIFICATION object:nil];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">- (void)handleNotification:(NSNotification *)notification</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;handle notification begin&quot;);</span><br><span class=\"line\">    sleep(1);</span><br><span class=\"line\">    NSLog(@&quot;handle notification end&quot;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    self.i = 10;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">- (void)dealloc</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [[NSNotificationCenter defaultCenter] removeObserver:self];</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;Observer dealloc&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">@end</span><br><span class=\"line\">\t</span><br><span class=\"line\">#pragma mark - ViewController</span><br><span class=\"line\">\t</span><br><span class=\"line\">@implementation ViewController</span><br><span class=\"line\">\t</span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    __autoreleasing Observer *observer = [[Observer alloc] init];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n\n\n<p>这段代码是在主线程添加了一个TEST_NOTIFICATION通知的监听者，并在主线程中将其移除，而我们的NSNotification是在后台线程中post的。在通知处理函数中，我们让回调所在的线程睡眠1秒钟，然后再去设置属性i值。这时会发生什么呢？我们先来看看输出结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2015-03-14 00:31:41.286 SKTest[932:88791] handle notification begin</span><br><span class=\"line\">2015-03-14 00:31:41.291 SKTest[932:88713] Observer dealloc</span><br><span class=\"line\">2015-03-14 00:31:42.361 SKTest[932:88791] handle notification end</span><br><span class=\"line\">(lldb) </span><br><span class=\"line\">\t</span><br><span class=\"line\">// 程序在self.i = 10处抛出了&quot;Thread 6: EXC_BAD_ACCESS(code=EXC_I386_GPFLT)&quot;</span><br></pre></td></tr></table></figure>\n\n<p>经典的内存错误，程序崩溃了。其实从输出结果中，我们就可以看到到底是发生了什么事。我们简要描述一下：</p>\n<ol>\n<li>当我们注册一个观察者是，通知中心会持有观察者的一个弱引用，来确保观察者是可用的。</li>\n<li>主线程调用dealloc操作会让Observer对象的引用计数减为0，这时对象会被释放掉。</li>\n<li>后台线程发送一个通知，如果此时Observer还未被释放，则会向其转发消息，并执行回调方法。而如果在回调执行的过程中对象被释放了，就会出现上面的问题。</li>\n</ol>\n<p>当然，上面这个例子是故意而为之，但不排除在实际编码中会遇到类似的问题。虽然NSNotificationCenter是线程安全的，但并不意味着我们在使用时就可以保证线程安全的，如果稍不注意，还是会出现线程问题。</p>\n<p>那我们该怎么做呢？这里有一些好的建议：</p>\n<ol>\n<li>尽量在一个线程中处理通知相关的操作，大部分情况下，这样做都能确保通知的正常工作。不过，我们无法确定到底会在哪个线程中调用dealloc方法，所以这一点还是比较困难。</li>\n<li>注册监听都时，使用基于block的API。这样我们在block还要继续调用self的属性或方法，就可以通过weak-strong的方式来处理。具体大家可以改造下上面的代码试试是什么效果。</li>\n<li>使用带有安全生命周期的对象，这一点对象单例对象来说再合适不过了，在应用的整个生命周期都不会被释放。</li>\n<li>使用代理。</li>\n</ol>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>NSNotificationCenter虽然是线程安全的，但不要被这个事实所误导。在涉及到多线程时，我们还是需要多加小心，避免出现上面的线程问题。想进一步了解的话，可以查看<a href=\"http://inessential.com/2013/12/20/observers_and_thread_safety\">Observers and Thread Safety</a>。</p>"},{"title":"iOS多线程编程之GCD(更新swift3.0用法)","top":0,"need_not_copyright":true,"date":"2018-04-20T09:38:52.000Z","banner_img":null,"_content":"\n> iOS多线程编程之GCD\n\n<!-- more -->\n\n## iOS多线程编程之GCD(更新swift3.0用法)\n\n**如果不考虑到其他任何因素和技术**，多线程其实是百害而无一利的，只能浪费时间，降低CPU的运行效率。\n\n试想一下，一个任务由十个子任务组成。现在有两种方式去完成这个任务：\n\n1、新建是个线程，把每个子任务放到对应的子线程中去执行。执行完一个线程就切换到另外一个线程；\n\n2、把是个人物放在一个线程里，按顺序执行。\n\n线程，是执行程序的最基本单元，他有自己的栈和自己的寄存器。说的具体一点，**线程就是“一个CPU执行一条无分叉的命令列”**。\n\n对于第一种方法，在十条线程之间来回切换，就意味着有十组栈和寄存器的值需要不断地备份、替换。而对于第二种方法，只需要一组寄存器和栈的存在，显然效率更加高效。\n\n---\n\n### 并发和并行\n\n通过刚刚的分析，我们可以看到，多线程本身并不能带来效率上的提升。严格意义上来说多线程在处理并发任务时，并不能提高其运行效率，反而会降低程序的运行效率。\n\n那么什么是并发呢？它和并行不一样\n\n> 并发指的是一种现象，一种经常出现，无可避免的现象。它描述的是“多个任务同时发生，需要被处理”这一现象。它的侧重点在于“发生”。\n\n比如或者站排队检票。\n\n> 并行指的是一种技术，一个同时处理多个任务的技术。它描述了一种能够同时处理多个任务的能力，侧重点在于“运行”。\n\n比如景点开放了多个检票窗口，同一时间内能服务多个游客。这种情况可以理解为并行。\n\n并行的反义词就是串行，表示任务必须按顺序来，一个一个执行，前一个执行完了才能执行后一个。\n\n然而我们经常挂载嘴边的“多线程”其实正是采用了并行技术，从而提高执行效率。因为有多个线程，所以CPU有多个内核可以同时工作。并同时处理不同线程内的指令。\n\n然而并发是一种现象，面向这一对象，我们首先需要先创建多个线程，然而真正加快程序运行速度的，是并行技术。也就是让多个CPU内核同时工作，而多线程的技术，正是让多个CPU同时进行工作。\n\n---\n\n### 同步与异步\n\n同步方法就是我们平时调用的哪些方法。因为任何有编程经验的人都知道，比如在第一行调用`foo()`方法，那么程序运行到第二行的时候，foo\\(\\)方法肯定是执行完了。\n\n所谓的异步，就是允许在执行某一个任务时，函数立刻返回，但是真正要执行的任务稍后完成。\n\n比如我们在点击保存按钮之后，要先把数据写到磁盘，然后更新UI。同步方法就是等到数据保存完再更新UI，而异步则是立刻从保存数据的方法返回并向后执行代码，同时真正用来保存数据的指令将在稍后执行。\n\n---\n\n### GCD简介\n\nGCD是以block为单位，一个block中的代码可以为一个任务。下文中提到的任务，可以理解为执行某个block。\n\n同时GCD有两个很重要的概念：列队和执行方式。\n\n#### 三种队列：\n\n* 串行列队：先入先出，每次只只执行一个任务；\n* 并发列队：依然是先入先出，但是可以多个任务并发执行；\n* 主列队：在主线程中执行；\n\n#### 两种执行方式：\n\n* 同步执行\n* 异步执行\n\n其关系如下\n\n|  | 同步 | 异步 |\n| :---: | :---: | :---: |\n| 主列队 | 在主线程中执行 | 在当前主线程中执行 |\n| 串行列队 | 在当前线程中执行 | 新建线程执行 |\n| 并发列队 | 在当前线程中执行 | 新建线程执行 |\n\n---\n\n### GCD死锁\n\n下面的代码会造成死锁：\n\n```\nDispatchQueue.main.sync {\n    print(\"当前线程\\(Thread.current)\")\n}\n其写法相当于OC中的：\ndispatch_sync(dispatch_get_main_queue(){\n    NSLog(@\"当前线程%@\",NSThread.currentThread);\n})\n```\n\n为什么会造成死锁？首先这是swift3.0的写法，DispatchQueue.main表示已经在主队列中执行，而sync中的代码块也是在当前的主队列中执行，那么，如果sync代码块中的代码要执行，则需要等待DispatchQueue.main执行完成才能执行，而DispatchQueue.main的代码要执行，则需要sync中的代码块执行完成才能执行，那么这样主队列中的两个任务就处在相互等待的状态，都在等对方先执行，而造成了死锁的问题。\n\n其实这种解决方案很简单，只带代码写成下面这样就不会造成死锁：\n\n```\nDispatchQueue.main.async {\n    print(\"当前线程\\(Thread.current)\")\n}\n```\n\nasync是一个异步执行方式，由于是在异步执行，那么就不会存在主队列相互等待的状态，这样就不会造成死锁的问题。\n\n---\n\n### GCD中的group\n\n代码如下：\n\n```\nlet group = DispatchGroup()\nDispatchQueue(label: \"label1\").async(group:group) {\n    print(\"当前线程111\\(Thread.current)\")\n}\nDispatchQueue(label: \"label2\").async(group: group) {\n    print(\"当前线程222\\(Thread.current)\")\n}\ngroup.notify(queue: DispatchQueue.main) {\n    print(\"当前线程333\\(Thread.current)\")\n}\n```\n\n在一个gcd队列组中并发执行线程111和线程222，所有并发线程完成之后通过队列组中的notify方法，回调到主线程。\n\n---\n\n### GCD中的barrier\n\nGCD中的barrier是用来控制GCD线程的先后顺序的方法，代码如下：\n\n```\nlet group = DispatchGroup()\nlet queue = DispatchQueue.init(label: \"queue\")\nqueue.async(group:group) {\n    for i in 0..<10 {\n        print(\"\\(i)\")\n    }\n    print(\"当前线程111\\(Thread.current)\")\n}\nqueue.async(group: group, qos: .default, flags: .barrier) {\n    print(\"线程阻塞中。。。\")\n}\nqueue.async(group: group) {\n    for i in 0..<20 {\n        print(\"\\(i)\")\n    }\n    print(\"当前线程222\\(Thread.current)\")\n}\ngroup.notify(queue: DispatchQueue.main) {\n    print(\"当前线程333\\(Thread.current)\")\n}\n```\n\n---\n\n### GCD中的信号量（semaphore）\n\n如果你有计算机基础，那么下面这段话应该很简单就能理解\n\n> 信号量就是一个资源计数器，对信号量有两个操作来达到互斥，分别是P和V操作。 一般情况是这样进行临界访问或互斥访问的： 设信号量值为1， 当一个进程1运行是，使用资源，进行P操作，即对信号量值减1，也就是资源数少了1个。这是信号量值为0。系统中规定当信号量值为0是，必须等待，知道信号量值不为零才能继续操作。 这时如果进程2想要运行，那么也必须进行P操作，但是此时信号量为0，所以无法减1，即不能P操作，也就阻塞。这样就到到了进程1排他访问。 当进程1运行结束后，释放资源，进行V操作。资源数重新加1，这是信号量的值变为1. 这时进程2发现资源数不为0，信号量能进行P操作了，立即执行P操作。信号量值又变为0.次数进程2咱有资源，排他访问资源。 这就是信号量来控制互斥的原理\n\n简单点来说，信号量为0时，阻塞线程，大于0是不会阻塞线程，GCD则可以通过信号量的值来达到是否阻塞线程，从而达到线程同步。\n\n简单来说，在GCD中，让线程同步可以用三种方法（就目前我所能想到的）：\n\n* group\n\n* barrier\n\n* semaphore\n\ngroup和barrier前面我们已经讲解过了，下面我们来说一说semaphore的的用法，在GCD中的信号量有三个函数操作：\n\n* DispatchSemaphore.init   -&gt;   OC代码（dispatch\\_semaphore\\_create）//**创建一个semaphore信号量**\n\n* dispatch\\_semaphore\\_signal     //**发送一个信号**\n\n* dispatch\\_semaphore\\_wait       //**等待信号**\n\n代码如下：\n\n```\nlet queue = DispatchQueue.init(label: \"queue\")\nlet semaphore = DispatchSemaphore.init(value: 2)//初始化的信号量为2\nfor i in 0...2 {\n    print(i)\n    _ = semaphore.wait()\n    _ = semaphore.wait(timeout: DispatchTime.now() + 10.0)//当前信号量为0时，阻塞线程10秒，10秒过后信号量如果依然为0，将不再等待，继续执行下面的代码\n    queue.async {\n        for j in 0...3 {\n            print(\"有限资源\\(j)\")\n            sleep(3)//阻塞线程3秒\n            print(\"-------------------\")\n        }\n        semaphore.signal()\n    }\n\n}\n```\n\n\n\n","source":"_posts/iOS多线程编程之GCD-更新swift3-0用法.md","raw":"---\ntitle: iOS多线程编程之GCD(更新swift3.0用法)\ntags: [GCD, 多线程]\ntop: 0\nneed_not_copyright: true\ndate: 2018-04-20 17:38:52\ncategories: 多线程\nbanner_img:\n---\n\n> iOS多线程编程之GCD\n\n<!-- more -->\n\n## iOS多线程编程之GCD(更新swift3.0用法)\n\n**如果不考虑到其他任何因素和技术**，多线程其实是百害而无一利的，只能浪费时间，降低CPU的运行效率。\n\n试想一下，一个任务由十个子任务组成。现在有两种方式去完成这个任务：\n\n1、新建是个线程，把每个子任务放到对应的子线程中去执行。执行完一个线程就切换到另外一个线程；\n\n2、把是个人物放在一个线程里，按顺序执行。\n\n线程，是执行程序的最基本单元，他有自己的栈和自己的寄存器。说的具体一点，**线程就是“一个CPU执行一条无分叉的命令列”**。\n\n对于第一种方法，在十条线程之间来回切换，就意味着有十组栈和寄存器的值需要不断地备份、替换。而对于第二种方法，只需要一组寄存器和栈的存在，显然效率更加高效。\n\n---\n\n### 并发和并行\n\n通过刚刚的分析，我们可以看到，多线程本身并不能带来效率上的提升。严格意义上来说多线程在处理并发任务时，并不能提高其运行效率，反而会降低程序的运行效率。\n\n那么什么是并发呢？它和并行不一样\n\n> 并发指的是一种现象，一种经常出现，无可避免的现象。它描述的是“多个任务同时发生，需要被处理”这一现象。它的侧重点在于“发生”。\n\n比如或者站排队检票。\n\n> 并行指的是一种技术，一个同时处理多个任务的技术。它描述了一种能够同时处理多个任务的能力，侧重点在于“运行”。\n\n比如景点开放了多个检票窗口，同一时间内能服务多个游客。这种情况可以理解为并行。\n\n并行的反义词就是串行，表示任务必须按顺序来，一个一个执行，前一个执行完了才能执行后一个。\n\n然而我们经常挂载嘴边的“多线程”其实正是采用了并行技术，从而提高执行效率。因为有多个线程，所以CPU有多个内核可以同时工作。并同时处理不同线程内的指令。\n\n然而并发是一种现象，面向这一对象，我们首先需要先创建多个线程，然而真正加快程序运行速度的，是并行技术。也就是让多个CPU内核同时工作，而多线程的技术，正是让多个CPU同时进行工作。\n\n---\n\n### 同步与异步\n\n同步方法就是我们平时调用的哪些方法。因为任何有编程经验的人都知道，比如在第一行调用`foo()`方法，那么程序运行到第二行的时候，foo\\(\\)方法肯定是执行完了。\n\n所谓的异步，就是允许在执行某一个任务时，函数立刻返回，但是真正要执行的任务稍后完成。\n\n比如我们在点击保存按钮之后，要先把数据写到磁盘，然后更新UI。同步方法就是等到数据保存完再更新UI，而异步则是立刻从保存数据的方法返回并向后执行代码，同时真正用来保存数据的指令将在稍后执行。\n\n---\n\n### GCD简介\n\nGCD是以block为单位，一个block中的代码可以为一个任务。下文中提到的任务，可以理解为执行某个block。\n\n同时GCD有两个很重要的概念：列队和执行方式。\n\n#### 三种队列：\n\n* 串行列队：先入先出，每次只只执行一个任务；\n* 并发列队：依然是先入先出，但是可以多个任务并发执行；\n* 主列队：在主线程中执行；\n\n#### 两种执行方式：\n\n* 同步执行\n* 异步执行\n\n其关系如下\n\n|  | 同步 | 异步 |\n| :---: | :---: | :---: |\n| 主列队 | 在主线程中执行 | 在当前主线程中执行 |\n| 串行列队 | 在当前线程中执行 | 新建线程执行 |\n| 并发列队 | 在当前线程中执行 | 新建线程执行 |\n\n---\n\n### GCD死锁\n\n下面的代码会造成死锁：\n\n```\nDispatchQueue.main.sync {\n    print(\"当前线程\\(Thread.current)\")\n}\n其写法相当于OC中的：\ndispatch_sync(dispatch_get_main_queue(){\n    NSLog(@\"当前线程%@\",NSThread.currentThread);\n})\n```\n\n为什么会造成死锁？首先这是swift3.0的写法，DispatchQueue.main表示已经在主队列中执行，而sync中的代码块也是在当前的主队列中执行，那么，如果sync代码块中的代码要执行，则需要等待DispatchQueue.main执行完成才能执行，而DispatchQueue.main的代码要执行，则需要sync中的代码块执行完成才能执行，那么这样主队列中的两个任务就处在相互等待的状态，都在等对方先执行，而造成了死锁的问题。\n\n其实这种解决方案很简单，只带代码写成下面这样就不会造成死锁：\n\n```\nDispatchQueue.main.async {\n    print(\"当前线程\\(Thread.current)\")\n}\n```\n\nasync是一个异步执行方式，由于是在异步执行，那么就不会存在主队列相互等待的状态，这样就不会造成死锁的问题。\n\n---\n\n### GCD中的group\n\n代码如下：\n\n```\nlet group = DispatchGroup()\nDispatchQueue(label: \"label1\").async(group:group) {\n    print(\"当前线程111\\(Thread.current)\")\n}\nDispatchQueue(label: \"label2\").async(group: group) {\n    print(\"当前线程222\\(Thread.current)\")\n}\ngroup.notify(queue: DispatchQueue.main) {\n    print(\"当前线程333\\(Thread.current)\")\n}\n```\n\n在一个gcd队列组中并发执行线程111和线程222，所有并发线程完成之后通过队列组中的notify方法，回调到主线程。\n\n---\n\n### GCD中的barrier\n\nGCD中的barrier是用来控制GCD线程的先后顺序的方法，代码如下：\n\n```\nlet group = DispatchGroup()\nlet queue = DispatchQueue.init(label: \"queue\")\nqueue.async(group:group) {\n    for i in 0..<10 {\n        print(\"\\(i)\")\n    }\n    print(\"当前线程111\\(Thread.current)\")\n}\nqueue.async(group: group, qos: .default, flags: .barrier) {\n    print(\"线程阻塞中。。。\")\n}\nqueue.async(group: group) {\n    for i in 0..<20 {\n        print(\"\\(i)\")\n    }\n    print(\"当前线程222\\(Thread.current)\")\n}\ngroup.notify(queue: DispatchQueue.main) {\n    print(\"当前线程333\\(Thread.current)\")\n}\n```\n\n---\n\n### GCD中的信号量（semaphore）\n\n如果你有计算机基础，那么下面这段话应该很简单就能理解\n\n> 信号量就是一个资源计数器，对信号量有两个操作来达到互斥，分别是P和V操作。 一般情况是这样进行临界访问或互斥访问的： 设信号量值为1， 当一个进程1运行是，使用资源，进行P操作，即对信号量值减1，也就是资源数少了1个。这是信号量值为0。系统中规定当信号量值为0是，必须等待，知道信号量值不为零才能继续操作。 这时如果进程2想要运行，那么也必须进行P操作，但是此时信号量为0，所以无法减1，即不能P操作，也就阻塞。这样就到到了进程1排他访问。 当进程1运行结束后，释放资源，进行V操作。资源数重新加1，这是信号量的值变为1. 这时进程2发现资源数不为0，信号量能进行P操作了，立即执行P操作。信号量值又变为0.次数进程2咱有资源，排他访问资源。 这就是信号量来控制互斥的原理\n\n简单点来说，信号量为0时，阻塞线程，大于0是不会阻塞线程，GCD则可以通过信号量的值来达到是否阻塞线程，从而达到线程同步。\n\n简单来说，在GCD中，让线程同步可以用三种方法（就目前我所能想到的）：\n\n* group\n\n* barrier\n\n* semaphore\n\ngroup和barrier前面我们已经讲解过了，下面我们来说一说semaphore的的用法，在GCD中的信号量有三个函数操作：\n\n* DispatchSemaphore.init   -&gt;   OC代码（dispatch\\_semaphore\\_create）//**创建一个semaphore信号量**\n\n* dispatch\\_semaphore\\_signal     //**发送一个信号**\n\n* dispatch\\_semaphore\\_wait       //**等待信号**\n\n代码如下：\n\n```\nlet queue = DispatchQueue.init(label: \"queue\")\nlet semaphore = DispatchSemaphore.init(value: 2)//初始化的信号量为2\nfor i in 0...2 {\n    print(i)\n    _ = semaphore.wait()\n    _ = semaphore.wait(timeout: DispatchTime.now() + 10.0)//当前信号量为0时，阻塞线程10秒，10秒过后信号量如果依然为0，将不再等待，继续执行下面的代码\n    queue.async {\n        for j in 0...3 {\n            print(\"有限资源\\(j)\")\n            sleep(3)//阻塞线程3秒\n            print(\"-------------------\")\n        }\n        semaphore.signal()\n    }\n\n}\n```\n\n\n\n","slug":"iOS多线程编程之GCD-更新swift3-0用法","published":1,"updated":"2023-07-21T09:10:33.573Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clkcgbp590007pfo7a85xcg7t","content":"<blockquote>\n<p>iOS多线程编程之GCD</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"iOS多线程编程之GCD-更新swift3-0用法\"><a href=\"#iOS多线程编程之GCD-更新swift3-0用法\" class=\"headerlink\" title=\"iOS多线程编程之GCD(更新swift3.0用法)\"></a>iOS多线程编程之GCD(更新swift3.0用法)</h2><p><strong>如果不考虑到其他任何因素和技术</strong>，多线程其实是百害而无一利的，只能浪费时间，降低CPU的运行效率。</p>\n<p>试想一下，一个任务由十个子任务组成。现在有两种方式去完成这个任务：</p>\n<p>1、新建是个线程，把每个子任务放到对应的子线程中去执行。执行完一个线程就切换到另外一个线程；</p>\n<p>2、把是个人物放在一个线程里，按顺序执行。</p>\n<p>线程，是执行程序的最基本单元，他有自己的栈和自己的寄存器。说的具体一点，<strong>线程就是“一个CPU执行一条无分叉的命令列”</strong>。</p>\n<p>对于第一种方法，在十条线程之间来回切换，就意味着有十组栈和寄存器的值需要不断地备份、替换。而对于第二种方法，只需要一组寄存器和栈的存在，显然效率更加高效。</p>\n<hr>\n<h3 id=\"并发和并行\"><a href=\"#并发和并行\" class=\"headerlink\" title=\"并发和并行\"></a>并发和并行</h3><p>通过刚刚的分析，我们可以看到，多线程本身并不能带来效率上的提升。严格意义上来说多线程在处理并发任务时，并不能提高其运行效率，反而会降低程序的运行效率。</p>\n<p>那么什么是并发呢？它和并行不一样</p>\n<blockquote>\n<p>并发指的是一种现象，一种经常出现，无可避免的现象。它描述的是“多个任务同时发生，需要被处理”这一现象。它的侧重点在于“发生”。</p>\n</blockquote>\n<p>比如或者站排队检票。</p>\n<blockquote>\n<p>并行指的是一种技术，一个同时处理多个任务的技术。它描述了一种能够同时处理多个任务的能力，侧重点在于“运行”。</p>\n</blockquote>\n<p>比如景点开放了多个检票窗口，同一时间内能服务多个游客。这种情况可以理解为并行。</p>\n<p>并行的反义词就是串行，表示任务必须按顺序来，一个一个执行，前一个执行完了才能执行后一个。</p>\n<p>然而我们经常挂载嘴边的“多线程”其实正是采用了并行技术，从而提高执行效率。因为有多个线程，所以CPU有多个内核可以同时工作。并同时处理不同线程内的指令。</p>\n<p>然而并发是一种现象，面向这一对象，我们首先需要先创建多个线程，然而真正加快程序运行速度的，是并行技术。也就是让多个CPU内核同时工作，而多线程的技术，正是让多个CPU同时进行工作。</p>\n<hr>\n<h3 id=\"同步与异步\"><a href=\"#同步与异步\" class=\"headerlink\" title=\"同步与异步\"></a>同步与异步</h3><p>同步方法就是我们平时调用的哪些方法。因为任何有编程经验的人都知道，比如在第一行调用<code>foo()</code>方法，那么程序运行到第二行的时候，foo()方法肯定是执行完了。</p>\n<p>所谓的异步，就是允许在执行某一个任务时，函数立刻返回，但是真正要执行的任务稍后完成。</p>\n<p>比如我们在点击保存按钮之后，要先把数据写到磁盘，然后更新UI。同步方法就是等到数据保存完再更新UI，而异步则是立刻从保存数据的方法返回并向后执行代码，同时真正用来保存数据的指令将在稍后执行。</p>\n<hr>\n<h3 id=\"GCD简介\"><a href=\"#GCD简介\" class=\"headerlink\" title=\"GCD简介\"></a>GCD简介</h3><p>GCD是以block为单位，一个block中的代码可以为一个任务。下文中提到的任务，可以理解为执行某个block。</p>\n<p>同时GCD有两个很重要的概念：列队和执行方式。</p>\n<h4 id=\"三种队列：\"><a href=\"#三种队列：\" class=\"headerlink\" title=\"三种队列：\"></a>三种队列：</h4><ul>\n<li>串行列队：先入先出，每次只只执行一个任务；</li>\n<li>并发列队：依然是先入先出，但是可以多个任务并发执行；</li>\n<li>主列队：在主线程中执行；</li>\n</ul>\n<h4 id=\"两种执行方式：\"><a href=\"#两种执行方式：\" class=\"headerlink\" title=\"两种执行方式：\"></a>两种执行方式：</h4><ul>\n<li>同步执行</li>\n<li>异步执行</li>\n</ul>\n<p>其关系如下</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">同步</th>\n<th align=\"center\">异步</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">主列队</td>\n<td align=\"center\">在主线程中执行</td>\n<td align=\"center\">在当前主线程中执行</td>\n</tr>\n<tr>\n<td align=\"center\">串行列队</td>\n<td align=\"center\">在当前线程中执行</td>\n<td align=\"center\">新建线程执行</td>\n</tr>\n<tr>\n<td align=\"center\">并发列队</td>\n<td align=\"center\">在当前线程中执行</td>\n<td align=\"center\">新建线程执行</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"GCD死锁\"><a href=\"#GCD死锁\" class=\"headerlink\" title=\"GCD死锁\"></a>GCD死锁</h3><p>下面的代码会造成死锁：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DispatchQueue.main.sync &#123;</span><br><span class=\"line\">    print(&quot;当前线程\\(Thread.current)&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">其写法相当于OC中的：</span><br><span class=\"line\">dispatch_sync(dispatch_get_main_queue()&#123;</span><br><span class=\"line\">    NSLog(@&quot;当前线程%@&quot;,NSThread.currentThread);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>为什么会造成死锁？首先这是swift3.0的写法，DispatchQueue.main表示已经在主队列中执行，而sync中的代码块也是在当前的主队列中执行，那么，如果sync代码块中的代码要执行，则需要等待DispatchQueue.main执行完成才能执行，而DispatchQueue.main的代码要执行，则需要sync中的代码块执行完成才能执行，那么这样主队列中的两个任务就处在相互等待的状态，都在等对方先执行，而造成了死锁的问题。</p>\n<p>其实这种解决方案很简单，只带代码写成下面这样就不会造成死锁：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DispatchQueue.main.async &#123;</span><br><span class=\"line\">    print(&quot;当前线程\\(Thread.current)&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>async是一个异步执行方式，由于是在异步执行，那么就不会存在主队列相互等待的状态，这样就不会造成死锁的问题。</p>\n<hr>\n<h3 id=\"GCD中的group\"><a href=\"#GCD中的group\" class=\"headerlink\" title=\"GCD中的group\"></a>GCD中的group</h3><p>代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let group = DispatchGroup()</span><br><span class=\"line\">DispatchQueue(label: &quot;label1&quot;).async(group:group) &#123;</span><br><span class=\"line\">    print(&quot;当前线程111\\(Thread.current)&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">DispatchQueue(label: &quot;label2&quot;).async(group: group) &#123;</span><br><span class=\"line\">    print(&quot;当前线程222\\(Thread.current)&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">group.notify(queue: DispatchQueue.main) &#123;</span><br><span class=\"line\">    print(&quot;当前线程333\\(Thread.current)&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在一个gcd队列组中并发执行线程111和线程222，所有并发线程完成之后通过队列组中的notify方法，回调到主线程。</p>\n<hr>\n<h3 id=\"GCD中的barrier\"><a href=\"#GCD中的barrier\" class=\"headerlink\" title=\"GCD中的barrier\"></a>GCD中的barrier</h3><p>GCD中的barrier是用来控制GCD线程的先后顺序的方法，代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let group = DispatchGroup()</span><br><span class=\"line\">let queue = DispatchQueue.init(label: &quot;queue&quot;)</span><br><span class=\"line\">queue.async(group:group) &#123;</span><br><span class=\"line\">    for i in 0..&lt;10 &#123;</span><br><span class=\"line\">        print(&quot;\\(i)&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    print(&quot;当前线程111\\(Thread.current)&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">queue.async(group: group, qos: .default, flags: .barrier) &#123;</span><br><span class=\"line\">    print(&quot;线程阻塞中。。。&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">queue.async(group: group) &#123;</span><br><span class=\"line\">    for i in 0..&lt;20 &#123;</span><br><span class=\"line\">        print(&quot;\\(i)&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    print(&quot;当前线程222\\(Thread.current)&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">group.notify(queue: DispatchQueue.main) &#123;</span><br><span class=\"line\">    print(&quot;当前线程333\\(Thread.current)&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"GCD中的信号量（semaphore）\"><a href=\"#GCD中的信号量（semaphore）\" class=\"headerlink\" title=\"GCD中的信号量（semaphore）\"></a>GCD中的信号量（semaphore）</h3><p>如果你有计算机基础，那么下面这段话应该很简单就能理解</p>\n<blockquote>\n<p>信号量就是一个资源计数器，对信号量有两个操作来达到互斥，分别是P和V操作。 一般情况是这样进行临界访问或互斥访问的： 设信号量值为1， 当一个进程1运行是，使用资源，进行P操作，即对信号量值减1，也就是资源数少了1个。这是信号量值为0。系统中规定当信号量值为0是，必须等待，知道信号量值不为零才能继续操作。 这时如果进程2想要运行，那么也必须进行P操作，但是此时信号量为0，所以无法减1，即不能P操作，也就阻塞。这样就到到了进程1排他访问。 当进程1运行结束后，释放资源，进行V操作。资源数重新加1，这是信号量的值变为1. 这时进程2发现资源数不为0，信号量能进行P操作了，立即执行P操作。信号量值又变为0.次数进程2咱有资源，排他访问资源。 这就是信号量来控制互斥的原理</p>\n</blockquote>\n<p>简单点来说，信号量为0时，阻塞线程，大于0是不会阻塞线程，GCD则可以通过信号量的值来达到是否阻塞线程，从而达到线程同步。</p>\n<p>简单来说，在GCD中，让线程同步可以用三种方法（就目前我所能想到的）：</p>\n<ul>\n<li><p>group</p>\n</li>\n<li><p>barrier</p>\n</li>\n<li><p>semaphore</p>\n</li>\n</ul>\n<p>group和barrier前面我们已经讲解过了，下面我们来说一说semaphore的的用法，在GCD中的信号量有三个函数操作：</p>\n<ul>\n<li><p>DispatchSemaphore.init   -&gt;   OC代码（dispatch_semaphore_create）&#x2F;&#x2F;<strong>创建一个semaphore信号量</strong></p>\n</li>\n<li><p>dispatch_semaphore_signal     &#x2F;&#x2F;<strong>发送一个信号</strong></p>\n</li>\n<li><p>dispatch_semaphore_wait       &#x2F;&#x2F;<strong>等待信号</strong></p>\n</li>\n</ul>\n<p>代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let queue = DispatchQueue.init(label: &quot;queue&quot;)</span><br><span class=\"line\">let semaphore = DispatchSemaphore.init(value: 2)//初始化的信号量为2</span><br><span class=\"line\">for i in 0...2 &#123;</span><br><span class=\"line\">    print(i)</span><br><span class=\"line\">    _ = semaphore.wait()</span><br><span class=\"line\">    _ = semaphore.wait(timeout: DispatchTime.now() + 10.0)//当前信号量为0时，阻塞线程10秒，10秒过后信号量如果依然为0，将不再等待，继续执行下面的代码</span><br><span class=\"line\">    queue.async &#123;</span><br><span class=\"line\">        for j in 0...3 &#123;</span><br><span class=\"line\">            print(&quot;有限资源\\(j)&quot;)</span><br><span class=\"line\">            sleep(3)//阻塞线程3秒</span><br><span class=\"line\">            print(&quot;-------------------&quot;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        semaphore.signal()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"length":4011,"excerpt":"<blockquote>\n<p>iOS多线程编程之GCD</p>\n</blockquote>","more":"<h2 id=\"iOS多线程编程之GCD-更新swift3-0用法\"><a href=\"#iOS多线程编程之GCD-更新swift3-0用法\" class=\"headerlink\" title=\"iOS多线程编程之GCD(更新swift3.0用法)\"></a>iOS多线程编程之GCD(更新swift3.0用法)</h2><p><strong>如果不考虑到其他任何因素和技术</strong>，多线程其实是百害而无一利的，只能浪费时间，降低CPU的运行效率。</p>\n<p>试想一下，一个任务由十个子任务组成。现在有两种方式去完成这个任务：</p>\n<p>1、新建是个线程，把每个子任务放到对应的子线程中去执行。执行完一个线程就切换到另外一个线程；</p>\n<p>2、把是个人物放在一个线程里，按顺序执行。</p>\n<p>线程，是执行程序的最基本单元，他有自己的栈和自己的寄存器。说的具体一点，<strong>线程就是“一个CPU执行一条无分叉的命令列”</strong>。</p>\n<p>对于第一种方法，在十条线程之间来回切换，就意味着有十组栈和寄存器的值需要不断地备份、替换。而对于第二种方法，只需要一组寄存器和栈的存在，显然效率更加高效。</p>\n<hr>\n<h3 id=\"并发和并行\"><a href=\"#并发和并行\" class=\"headerlink\" title=\"并发和并行\"></a>并发和并行</h3><p>通过刚刚的分析，我们可以看到，多线程本身并不能带来效率上的提升。严格意义上来说多线程在处理并发任务时，并不能提高其运行效率，反而会降低程序的运行效率。</p>\n<p>那么什么是并发呢？它和并行不一样</p>\n<blockquote>\n<p>并发指的是一种现象，一种经常出现，无可避免的现象。它描述的是“多个任务同时发生，需要被处理”这一现象。它的侧重点在于“发生”。</p>\n</blockquote>\n<p>比如或者站排队检票。</p>\n<blockquote>\n<p>并行指的是一种技术，一个同时处理多个任务的技术。它描述了一种能够同时处理多个任务的能力，侧重点在于“运行”。</p>\n</blockquote>\n<p>比如景点开放了多个检票窗口，同一时间内能服务多个游客。这种情况可以理解为并行。</p>\n<p>并行的反义词就是串行，表示任务必须按顺序来，一个一个执行，前一个执行完了才能执行后一个。</p>\n<p>然而我们经常挂载嘴边的“多线程”其实正是采用了并行技术，从而提高执行效率。因为有多个线程，所以CPU有多个内核可以同时工作。并同时处理不同线程内的指令。</p>\n<p>然而并发是一种现象，面向这一对象，我们首先需要先创建多个线程，然而真正加快程序运行速度的，是并行技术。也就是让多个CPU内核同时工作，而多线程的技术，正是让多个CPU同时进行工作。</p>\n<hr>\n<h3 id=\"同步与异步\"><a href=\"#同步与异步\" class=\"headerlink\" title=\"同步与异步\"></a>同步与异步</h3><p>同步方法就是我们平时调用的哪些方法。因为任何有编程经验的人都知道，比如在第一行调用<code>foo()</code>方法，那么程序运行到第二行的时候，foo()方法肯定是执行完了。</p>\n<p>所谓的异步，就是允许在执行某一个任务时，函数立刻返回，但是真正要执行的任务稍后完成。</p>\n<p>比如我们在点击保存按钮之后，要先把数据写到磁盘，然后更新UI。同步方法就是等到数据保存完再更新UI，而异步则是立刻从保存数据的方法返回并向后执行代码，同时真正用来保存数据的指令将在稍后执行。</p>\n<hr>\n<h3 id=\"GCD简介\"><a href=\"#GCD简介\" class=\"headerlink\" title=\"GCD简介\"></a>GCD简介</h3><p>GCD是以block为单位，一个block中的代码可以为一个任务。下文中提到的任务，可以理解为执行某个block。</p>\n<p>同时GCD有两个很重要的概念：列队和执行方式。</p>\n<h4 id=\"三种队列：\"><a href=\"#三种队列：\" class=\"headerlink\" title=\"三种队列：\"></a>三种队列：</h4><ul>\n<li>串行列队：先入先出，每次只只执行一个任务；</li>\n<li>并发列队：依然是先入先出，但是可以多个任务并发执行；</li>\n<li>主列队：在主线程中执行；</li>\n</ul>\n<h4 id=\"两种执行方式：\"><a href=\"#两种执行方式：\" class=\"headerlink\" title=\"两种执行方式：\"></a>两种执行方式：</h4><ul>\n<li>同步执行</li>\n<li>异步执行</li>\n</ul>\n<p>其关系如下</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">同步</th>\n<th align=\"center\">异步</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">主列队</td>\n<td align=\"center\">在主线程中执行</td>\n<td align=\"center\">在当前主线程中执行</td>\n</tr>\n<tr>\n<td align=\"center\">串行列队</td>\n<td align=\"center\">在当前线程中执行</td>\n<td align=\"center\">新建线程执行</td>\n</tr>\n<tr>\n<td align=\"center\">并发列队</td>\n<td align=\"center\">在当前线程中执行</td>\n<td align=\"center\">新建线程执行</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"GCD死锁\"><a href=\"#GCD死锁\" class=\"headerlink\" title=\"GCD死锁\"></a>GCD死锁</h3><p>下面的代码会造成死锁：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DispatchQueue.main.sync &#123;</span><br><span class=\"line\">    print(&quot;当前线程\\(Thread.current)&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">其写法相当于OC中的：</span><br><span class=\"line\">dispatch_sync(dispatch_get_main_queue()&#123;</span><br><span class=\"line\">    NSLog(@&quot;当前线程%@&quot;,NSThread.currentThread);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>为什么会造成死锁？首先这是swift3.0的写法，DispatchQueue.main表示已经在主队列中执行，而sync中的代码块也是在当前的主队列中执行，那么，如果sync代码块中的代码要执行，则需要等待DispatchQueue.main执行完成才能执行，而DispatchQueue.main的代码要执行，则需要sync中的代码块执行完成才能执行，那么这样主队列中的两个任务就处在相互等待的状态，都在等对方先执行，而造成了死锁的问题。</p>\n<p>其实这种解决方案很简单，只带代码写成下面这样就不会造成死锁：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DispatchQueue.main.async &#123;</span><br><span class=\"line\">    print(&quot;当前线程\\(Thread.current)&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>async是一个异步执行方式，由于是在异步执行，那么就不会存在主队列相互等待的状态，这样就不会造成死锁的问题。</p>\n<hr>\n<h3 id=\"GCD中的group\"><a href=\"#GCD中的group\" class=\"headerlink\" title=\"GCD中的group\"></a>GCD中的group</h3><p>代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let group = DispatchGroup()</span><br><span class=\"line\">DispatchQueue(label: &quot;label1&quot;).async(group:group) &#123;</span><br><span class=\"line\">    print(&quot;当前线程111\\(Thread.current)&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">DispatchQueue(label: &quot;label2&quot;).async(group: group) &#123;</span><br><span class=\"line\">    print(&quot;当前线程222\\(Thread.current)&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">group.notify(queue: DispatchQueue.main) &#123;</span><br><span class=\"line\">    print(&quot;当前线程333\\(Thread.current)&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在一个gcd队列组中并发执行线程111和线程222，所有并发线程完成之后通过队列组中的notify方法，回调到主线程。</p>\n<hr>\n<h3 id=\"GCD中的barrier\"><a href=\"#GCD中的barrier\" class=\"headerlink\" title=\"GCD中的barrier\"></a>GCD中的barrier</h3><p>GCD中的barrier是用来控制GCD线程的先后顺序的方法，代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let group = DispatchGroup()</span><br><span class=\"line\">let queue = DispatchQueue.init(label: &quot;queue&quot;)</span><br><span class=\"line\">queue.async(group:group) &#123;</span><br><span class=\"line\">    for i in 0..&lt;10 &#123;</span><br><span class=\"line\">        print(&quot;\\(i)&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    print(&quot;当前线程111\\(Thread.current)&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">queue.async(group: group, qos: .default, flags: .barrier) &#123;</span><br><span class=\"line\">    print(&quot;线程阻塞中。。。&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">queue.async(group: group) &#123;</span><br><span class=\"line\">    for i in 0..&lt;20 &#123;</span><br><span class=\"line\">        print(&quot;\\(i)&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    print(&quot;当前线程222\\(Thread.current)&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">group.notify(queue: DispatchQueue.main) &#123;</span><br><span class=\"line\">    print(&quot;当前线程333\\(Thread.current)&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"GCD中的信号量（semaphore）\"><a href=\"#GCD中的信号量（semaphore）\" class=\"headerlink\" title=\"GCD中的信号量（semaphore）\"></a>GCD中的信号量（semaphore）</h3><p>如果你有计算机基础，那么下面这段话应该很简单就能理解</p>\n<blockquote>\n<p>信号量就是一个资源计数器，对信号量有两个操作来达到互斥，分别是P和V操作。 一般情况是这样进行临界访问或互斥访问的： 设信号量值为1， 当一个进程1运行是，使用资源，进行P操作，即对信号量值减1，也就是资源数少了1个。这是信号量值为0。系统中规定当信号量值为0是，必须等待，知道信号量值不为零才能继续操作。 这时如果进程2想要运行，那么也必须进行P操作，但是此时信号量为0，所以无法减1，即不能P操作，也就阻塞。这样就到到了进程1排他访问。 当进程1运行结束后，释放资源，进行V操作。资源数重新加1，这是信号量的值变为1. 这时进程2发现资源数不为0，信号量能进行P操作了，立即执行P操作。信号量值又变为0.次数进程2咱有资源，排他访问资源。 这就是信号量来控制互斥的原理</p>\n</blockquote>\n<p>简单点来说，信号量为0时，阻塞线程，大于0是不会阻塞线程，GCD则可以通过信号量的值来达到是否阻塞线程，从而达到线程同步。</p>\n<p>简单来说，在GCD中，让线程同步可以用三种方法（就目前我所能想到的）：</p>\n<ul>\n<li><p>group</p>\n</li>\n<li><p>barrier</p>\n</li>\n<li><p>semaphore</p>\n</li>\n</ul>\n<p>group和barrier前面我们已经讲解过了，下面我们来说一说semaphore的的用法，在GCD中的信号量有三个函数操作：</p>\n<ul>\n<li><p>DispatchSemaphore.init   -&gt;   OC代码（dispatch_semaphore_create）&#x2F;&#x2F;<strong>创建一个semaphore信号量</strong></p>\n</li>\n<li><p>dispatch_semaphore_signal     &#x2F;&#x2F;<strong>发送一个信号</strong></p>\n</li>\n<li><p>dispatch_semaphore_wait       &#x2F;&#x2F;<strong>等待信号</strong></p>\n</li>\n</ul>\n<p>代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let queue = DispatchQueue.init(label: &quot;queue&quot;)</span><br><span class=\"line\">let semaphore = DispatchSemaphore.init(value: 2)//初始化的信号量为2</span><br><span class=\"line\">for i in 0...2 &#123;</span><br><span class=\"line\">    print(i)</span><br><span class=\"line\">    _ = semaphore.wait()</span><br><span class=\"line\">    _ = semaphore.wait(timeout: DispatchTime.now() + 10.0)//当前信号量为0时，阻塞线程10秒，10秒过后信号量如果依然为0，将不再等待，继续执行下面的代码</span><br><span class=\"line\">    queue.async &#123;</span><br><span class=\"line\">        for j in 0...3 &#123;</span><br><span class=\"line\">            print(&quot;有限资源\\(j)&quot;)</span><br><span class=\"line\">            sleep(3)//阻塞线程3秒</span><br><span class=\"line\">            print(&quot;-------------------&quot;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        semaphore.signal()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"iOS多线程编程之线程锁","date":"2017-02-24T10:04:15.000Z","_content":"\n# 何所谓线程安全\n\n线程安全就是在多线程访问的同时，采用用了加锁机制，当一个线程访问该线程外的某个数据时，进行保护，其他线程不能进行访问，直到该线程读取完毕，其他线程才可以访问。保护线程安全无在乎就是对线程进行加锁。\n\n在iOS开发中常用的加锁方式有以下几种：\n\n<!-- more -->\n\n# NSLock\n\n在iOS程序中NSLock中实现了一个简单的互斥锁，实现了NSLocking协议，\n\nlock为加锁，\n\nunlock为解锁，\n\ntryLock为尝试加锁，如果加锁失败则不会阻塞线程，只会立即回调，需要注意的是，使用tryLock并不能加锁成功 ，如果获取锁失败，则不会执行加锁。\n\nNOLockBforeDate:在指定的date之前暂时阻塞线程（如果没有获取锁），如果在指定的时间仍然没有获取到🔐的话。线程会被立即唤醒，函数立即返回NO。\n\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    __weak typeof(self) weakSelf = self;\n    dispatch_group_t group = dispatch_group_create();\n    dispatch_queue_t queueA = dispatch_queue_create(\"queueA\", nil);\n    dispatch_queue_t queueB = dispatch_queue_create(\"queueB\", nil);\n    dispatch_group_async(group, queueA, ^{\n        [weakSelf getWithArray:weakSelf.array];\n        NSLog(@\"%@线程A\",weakSelf.array);\n    });\n    dispatch_group_async(group, queueB, ^{\n        [weakSelf getWithArray:weakSelf.array];\n        NSLog(@\"%@线程B\",weakSelf.array);\n    });\n    NSLog(@\"%@主线程\",weakSelf.array);\n}\n\n- (void)getWithArray:(NSMutableArray *)array {\n    [self.lock lock];\n    if (array.count > 0) {\n        NSLog(@\"%@...objc\",array.lastObject);\n        [array removeLastObject];\n    }\n    [self.lock unlock];\n}\n```\n\n不加锁的打印：可看出线程A和线程B同时操作了getWithArray:\\(NSMutableArray \\*\\)array，由于资源抢占，导致了数组越界而崩溃\n\n```\n2016-07-22 22:18:55.695827+0800 ThreadLock[10764:315922] 4444...objc\n2016-07-22 22:18:55.695827+0800 ThreadLock[10764:315923] 4444...objc\n2016-07-22 22:18:55.695892+0800 ThreadLock[10764:315824] (\n    1111,\n    2222,\n    3333,\n    4444\n)主线程\n2016-07-22 22:18:55.696036+0800 ThreadLock[10764:315922] (\n    1111,\n    2222,\n    3333\n)线程A\n2016-07-22 22:18:55.697056+0800 ThreadLock[10764:315923] *** Terminating app due to uncaught exception 'NSRangeException', reason: '*** -[__NSArrayM removeObjectsInRange:]: range {3, 1} extends beyond bounds [0 .. 2]'\n```\n\n加锁打印：加锁后，线程A先跑，跑的过程中由于线程加锁，线程B无法访问getWithArray:\\(NSMutableArray \\*\\)array，线程A结束之后，线程B发现array中只剩下3个元素，所以把最后一个元素3333给remove掉了，从而达到了线程运行的安全。\n\n```\n2016-07-22 22:10:40.114063+0800 ThreadLock[10425:305487] 4444...objc\n2016-07-22 22:10:40.113988+0800 ThreadLock[10425:305421] (\n    1111,\n    2222,\n    3333,\n    4444\n)主线程\n2016-07-22 22:10:40.117108+0800 ThreadLock[10425:305487] (\n    1111,\n    2222,\n    3333\n)线程A\n2016-07-22 22:10:40.117076+0800 ThreadLock[10425:305486] 3333...objc\n2016-07-22 22:10:40.117703+0800 ThreadLock[10425:305486] (\n    1111,\n    2222\n)线程B\n```\n\n# @synchronized\n\n@synchronized在早期接触的iOS开发中经常接触，尤其是在创建单利模式的时候。\n\n代码以及打印如下：\n\n```\n- (void)getWithArray:(NSMutableArray *)array {\n    @synchronized (self) {\n        if (array.count > 0) {\n            NSLog(@\"%@...objc\",array.lastObject);\n            [array removeLastObject];\n        }\n    }\n}\n```\n\n```\n2016-07-22 22:20:33.083045+0800 ThreadLock[10837:317900] 4444...objc\n2016-07-22 22:20:33.083278+0800 ThreadLock[10837:317693] (\n    1111,\n    2222,\n    3333,\n    4444\n)主线程\n2016-07-22 22:20:33.083437+0800 ThreadLock[10837:317900] (\n    1111,\n    2222,\n    3333\n)线程A\n2016-07-22 22:20:33.083438+0800 ThreadLock[10837:317899] 3333...objc\n2016-07-22 22:20:33.083814+0800 ThreadLock[10837:317899] (\n    1111,\n    2222\n)线程B\n```\n\n---\n\n# 条件信号量dispatch\\_semaphore\\_t\n\n条件信号量详细用法见上一遍，GCD的用法\n\n---\n\n# dispatch\\_barrier\\_async/dispatch\\_barrier\\_sync\n\n详细用法见上一遍，GCD的用法，但有一点值得注意的是：\n\n> 如果在当前线程调用dispatch\\_barrier\\_sync阻塞线程会发生死锁\n\n---\n\n# NSCondition\n\nNSCondition同样实现了NSLocking协议，所以它和NSLock一样，也有NSLocking协议的lock和unlock方法，可以当做NSLock来使用解决线程同步问题，用法完全一样。\n\n```\n- (void)getWithArray:(NSMutableArray *)array {\n    [self.lock lock];\n    if (array.count > 0) {\n        NSLog(@\"%@...objc\",array.lastObject);\n        [array removeLastObject];\n    }\n    [self.lock unlock];\n}\n```\n\n同时，NSCondition提供更高级的用法。wait和signal，和条件信号量类似。\n\n比如我们要监听imageNames数组的个数，当imageNames的个数大于0的时候就执行清空操作。思路是这样的，当imageNames个数大于0时执行清空操作，否则，wait等待执行清空操作。当imageNames个数增加的时候发生signal信号，让等待的线程唤醒继续执行。\n\nNSCondition和NSLock、@synchronized等是不同的是，NSCondition可以给每个线程分别加锁，加锁后不影响其他线程进入临界区。这是非常强大。但是正是因为这种分别加锁的方式，NSCondition使用wait并使用加锁后并不能真正的解决资源的竞争。比如我们有个需求：不能让m&lt;0。假设当前m=0,线程A要判断到m&gt;0为假,执行等待；线程B执行了m=1操作，并唤醒线程A执行m-1操作的同时线程C判断到m&gt;0，因为他们在不同的线程锁里面，同样判断为真也执行了m-1，这个时候线程A和线程C都会执行m-1,但是m=1，结果就会造成m=-1.\n\n当我用数组做删除试验时，做增删操作并不是每次都会出现，大概3-4次后会出现。单纯的使用lock、unlock是没有问题的。\n\n---\n\n# 条件锁NSConditionLock\n\n也有人说这是个互斥锁。NSConditionLock同样实现了NSLocking协议，试验过程中发现性能很低。\n\n```\n- (void)getIamgeName:(NSMutableArray *)imageNames{\n    NSString *imageName;\n    [lock lock];\n    if (imageNames.count>0) {\n        imageName = [imageNames lastObject];\n        [imageNames removeObject:imageName];\n    }\n    [lock unlock];\n}\n```\n\nNSConditionLock也可以像NSCondition一样做多线程之间的任务等待调用，而且是线程安全的。\n\n```\n- (void)getIamgeName:(NSMutableArray *)imageNames{\n    NSString *imageName;\n    [lock lockWhenCondition:1];    //加锁\n    if (imageNames.count>0) {\n        imageName = [imageNames lastObject];\n        [imageNames removeObjectAtIndex:0];\n    }\n    [lock unlockWithCondition:0];     //解锁\n}\n- (void)createImageName:(NSMutableArray *)imageNames{\n    [lock lockWhenCondition:0];\n    [imageNames addObject:@\"0\"];\n    [lock unlockWithCondition:1];\n}\n\n#pragma mark - 多线程取出图片后删除\n- (void)getImageNameWithMultiThread{\n    NSMutableArray *imageNames = [[NSMutableArray alloc]init];\n    dispatch_group_t dispatchGroup = dispatch_group_create();\n    __block double then, now;\n    then = CFAbsoluteTimeGetCurrent();\n    for (int i=0; i<10000; i++) {\n        dispatch_group_async(dispatchGroup, self.synchronizationQueue, ^(){\n            [self getIamgeName:imageNames];\n        });\n        dispatch_group_async(dispatchGroup, self.synchronizationQueue, ^(){\n            [self createImageName:imageNames];\n        });\n    }\n    dispatch_group_notify(dispatchGroup, self.synchronizationQueue, ^(){\n        now = CFAbsoluteTimeGetCurrent();\n        printf(\"thread_lock: %f sec\\nimageNames count: %ld\\n\", now-then,imageNames.count);\n    });\n}\n```\n\n---\n\n# 递归锁NSRecursiveLock\n\n有时候“加锁代码”中存在递归调用，**递归开始前加锁，递归调用开始后会重复执行此方法以至于反复执行加锁代码最终造成死锁，这个时候可以使用递归锁来解决。使用递归锁可以在一个线程中反复获取锁而不造成死锁，这个过程中会记录获取锁和释放锁的次数，只有最后两者平衡锁才被最终释放。**\n\n```\n- (void)getIamgeName:(NSMutableArray *)imageNames{\n    NSString *imageName;\n    [lock lock];\n    if (imageNames.count>0) {\n        imageName = [imageNames firstObject];\n        [imageNames removeObjectAtIndex:0];\n        [self getIamgeName:imageNames];\n    }\n    [lock unlock];\n}\n- (void)getImageNameWithMultiThread{\n    NSMutableArray *imageNames = [NSMutableArray new];\n    int count = 1024*10;\n    for (int i=0; i<count; i++) {\n        [imageNames addObject:[NSString stringWithFormat:@\"%d\",i]];\n    }\n    dispatch_group_t dispatchGroup = dispatch_group_create();\n    __block double then, now;\n    then = CFAbsoluteTimeGetCurrent();\n    dispatch_group_async(dispatchGroup, self.synchronizationQueue, ^(){\n        [self getIamgeName:imageNames];\n    });\n    dispatch_group_notify(dispatchGroup, dispatch_get_main_queue(), ^(){\n        now = CFAbsoluteTimeGetCurrent();\n        printf(\"thread_lock: %f sec\\nimageNames count: %ld\\n\", now-then,imageNames.count);\n    });\n\n}\n```\n\n---\n\n# NSDistributedLock\n\nNSDistributedLock是MAC开发中的跨进程的分布式锁，底层是用文件系统实现的互斥锁。NSDistributedLock没有实现NSLocking协议，所以没有lock方法，取而代之的是非阻塞的tryLock方法。\n\n```\nNSDistributedLock *lock = [[NSDistributedLock alloc] initWithPath:@\"/Users/mac/Desktop/lock.lock\"];\n    while (![lock tryLock])\n    {\n        sleep(1);\n    }\n\n    //do something\n    [lock unlock];\n```\n\n当执行到do something时程序退出,程序再次启动之后tryLock就再也不能成功了,陷入死锁状态.其他应用也不能访问受保护的共享资源。在这种情况下，你可以使用breadLock方法来打破现存的锁以便你可以获取它。但是通常应该避免打破锁，除非你确定拥有进程已经死亡并不可能再释放该锁。\n\n因为是MAC下的线程锁，所以demo里面没有，这里也不做过多关注。\n\n---\n\n# 互斥锁POSIX\n\nPOSIX和dispatch\\_semaphore\\_t很像，但是完全不同。POSIX是Unix/Linux平台上提供的一套条件互斥锁的API。\n\n新建一个简单的POSIX互斥锁，引入头文件`#import <pthread.h>`声明并初始化一个pthread\\_mutex\\_t的结构。使用pthread\\_mutex\\_lock和pthread\\_mutex\\_unlock函数。调用pthread\\_mutex\\_destroy来释放该锁的数据结构。\n\n```\n#import <pthread.h>\n@interface MYPOSIXViewController ()\n{\n    pthread_mutex_t mutex;  //声明pthread_mutex_t的结构\n}\n@end\n\n@implementation MYPOSIXViewController\n- (void)dealloc{\n    pthread_mutex_destroy(&mutex);  //释放该锁的数据结构\n}\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view.\n    pthread_mutex_init(&mutex, NULL);\n    /**\n     *  初始化\n     *\n     */\n}\n\n- (void)getIamgeName:(NSMutableArray *)imageNames{\n    NSString *imageName;\n    /**\n     *  加锁\n     */\n    pthread_mutex_lock(&mutex);\n    if (imageNames.count>0) {\n        imageName = [imageNames firstObject];\n        [imageNames removeObjectAtIndex:0];\n    }\n    /**\n     *  解锁\n     */\n    pthread_mutex_unlock(&mutex);\n}\n```\n\nPOSIX还可以创建条件锁，提供了和NSCondition一样的条件控制，初始化互斥锁同时使用pthread\\_cond\\_init来初始化条件数据结构，\n\n```\n// 初始化\n    int pthread_cond_init (pthread_cond_t *cond, pthread_condattr_t *attr);\n\n    // 等待（会阻塞）\n    int pthread_cond_wait (pthread_cond_t *cond, pthread_mutex_t *mut);\n\n    // 定时等待\n    int pthread_cond_timedwait (pthread_cond_t *cond, pthread_mutex_t *mut, const struct timespec *abstime);\n\n    // 唤醒\n    int pthread_cond_signal (pthread_cond_t *cond);\n\n    // 广播唤醒\n    int pthread_cond_broadcast (pthread_cond_t *cond);\n\n    // 销毁\n    int pthread_cond_destroy (pthread_cond_t *cond);\n```\n\nPOSIX还提供了很多函数，有一套完整的API，包含Pthreads线程的创建控制等等，非常底层，可以手动处理线程的各个状态的转换即管理生命周期，甚至可以实现一套自己的多线程，感兴趣的可以继续深入了解。推荐一篇详细文章，但不是基于iOS的，是基于Linux的，但是介绍的非常详细 [Linux 线程锁详解](http://blog.chinaunix.net/uid-26885237-id-3207962.html)\n\n---\n\n# 自旋锁OSSpinLock\n\n首先要提的是OSSpinLock已经出现了BUG，导致并不能完全保证是线程安全的。\n\n> 新版 iOS 中，系统维护了 5 个不同的线程优先级/QoS: background，utility，default，user-initiated，user-interactive。高优先级线程始终会在低优先级线程前执行，一个线程不会受到比它更低优先级线程的干扰。这种线程调度算法会产生潜在的优先级反转问题，从而破坏了 spin lock。\n>\n> 具体来说，如果一个低优先级的线程获得锁并访问共享资源，这时一个高优先级的线程也尝试获得这个锁，它会处于 spin lock 的忙等状态从而占用大量 CPU。此时低优先级线程无法与高优先级线程争夺 CPU 时间，从而导致任务迟迟完不成、无法释放 lock。这并不只是理论上的问题，libobjc 已经遇到了很多次这个问题了，于是苹果的工程师停用了 OSSpinLock。\n\n> 苹果工程师 Greg Parker 提到，对于这个问题，一种解决方案是用 truly unbounded backoff 算法，这能避免 livelock 问题，但如果系统负载高时，它仍有可能将高优先级的线程阻塞数十秒之久；另一种方案是使用 handoff lock 算法，这也是 libobjc 目前正在使用的。锁的持有者会把线程 ID 保存到锁内部，锁的等待者会临时贡献出它的优先级来避免优先级反转的问题。理论上这种模式会在比较复杂的多锁条件下产生问题，但实践上目前还一切都好。\n\n> OSSpinLock 自旋锁，性能最高的锁。原理很简单，就是一直 do while 忙等。它的缺点是当等待时会消耗大量 CPU 资源，所以它不适用于较长时间的任务。对于内存缓存的存取来说，它非常合适。\n>\n> -摘自[ibireme](http://blog.ibireme.com/author/ibireme/)\n\n```\n<libkern/OSAtomic.h>\n\n#import <libkern/OSAtomic.h>\n@interface MYOSSpinLockViewController ()\n{\n    OSSpinLock spinlock;  //声明pthread_mutex_t的结构\n}\n@end\n\n@implementation MYOSSpinLockViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view.\n    spinlock = OS_SPINLOCK_INIT;\n    /**\n     *  初始化\n     *\n     */\n}\n\n- (void)getIamgeName:(NSMutableArray *)imageNames{\n    NSString *imageName;\n    /**\n     *  加锁\n     */\n    OSSpinLockLock(&spinlock);\n    if (imageNames.count>0) {\n        imageName = [imageNames firstObject];\n        [imageNames removeObjectAtIndex:0];\n    }\n    /**\n     *  解锁\n     */\n    OSSpinLockUnlock(&spinlock);\n}\n@end\n```\n\n# 自旋锁os_unfair_lock\n\n由于OSSpinLock的线程安全问题，Apple已经在iOS10废弃了OSSpinLock自旋锁，取而代之的是os_unfair_lock，虽然os_unfair_lock是线程安全的，但代价就是os_unfair_lock的性能效果相对于OSSpinLock大打折扣\n\nos_unfair_lock用法：\n\n```\n#import <os/lock.h>\n// 初始化\n os_unfair_lock unfair_lock = OS_UNFAIR_LOCK_INIT;\n// 加锁\nos_unfair_lock_lock(&unfair_lock);\n// 解锁\nos_unfair_lock_unlock(&unfair_lock);\n// 尝试加锁，可以加锁则立即加锁并返回 YES,反之返回 NO\nos_unfair_lock_trylock(&unfair_lock);\n/*\n注:解决不同优先级的线程申请锁的时候不会发生优先级反转问题.\n不过相对于 OSSpinLock , os_unfair_lock性能方面减弱了许多.\n*/\n```\n\n---\n\n# 总结\n\n**@synchronized：适用线程不多，任务量不大的多线程加锁；**\n\n**NSLock：其实NSLock并没有想象中的那么差，不知道大家为什么不推荐使用；**\n\n**dispatch\\_semaphore\\_t：使用信号来做加锁，性能提升显著；**\n\n**NSCondition：使用其做多线程之间的通信调用不是线程安全的；**\n\n**NSConditionLock：单纯加锁性能非常低，比NSLock低很多，但是可以用来做多线程处理不同任务的通信调用；**\n\n**NSRecursiveLock：递归锁的性能出奇的高，但是只能作为递归使用,所以限制了使用场景；**\n\n**NSDistributedLock：因为是MAC开发的，就不讨论了；**\n\n**POSIX\\(pthread\\_mutex\\)：底层的api，复杂的多线程处理建议使用，并且可以封装自己的多线程；**\n\n**OSSpinLock：性能也非常高，可惜出现了线程问题；**\n\n**os_unfair_lock iOS10以后用于替代OSSpinLock的另外一种自旋锁，线程安全，性能相对于OSSpinLock大打折扣**\n\n**dispatch\\_barrier\\_async/dispatch\\_barrier\\_sync：测试中发现dispatch\\_barrier\\_sync比dispatch\\_barrier\\_async性能要高，真是大出意外。**\n\n","source":"_posts/iOS多线程编程之线程锁.md","raw":"---\ntitle: iOS多线程编程之线程锁\ndate: 2017-02-24 18:04:15\ntags: [iOS线程锁, 多线程]\ncategories: 多线程\n---\n\n# 何所谓线程安全\n\n线程安全就是在多线程访问的同时，采用用了加锁机制，当一个线程访问该线程外的某个数据时，进行保护，其他线程不能进行访问，直到该线程读取完毕，其他线程才可以访问。保护线程安全无在乎就是对线程进行加锁。\n\n在iOS开发中常用的加锁方式有以下几种：\n\n<!-- more -->\n\n# NSLock\n\n在iOS程序中NSLock中实现了一个简单的互斥锁，实现了NSLocking协议，\n\nlock为加锁，\n\nunlock为解锁，\n\ntryLock为尝试加锁，如果加锁失败则不会阻塞线程，只会立即回调，需要注意的是，使用tryLock并不能加锁成功 ，如果获取锁失败，则不会执行加锁。\n\nNOLockBforeDate:在指定的date之前暂时阻塞线程（如果没有获取锁），如果在指定的时间仍然没有获取到🔐的话。线程会被立即唤醒，函数立即返回NO。\n\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    __weak typeof(self) weakSelf = self;\n    dispatch_group_t group = dispatch_group_create();\n    dispatch_queue_t queueA = dispatch_queue_create(\"queueA\", nil);\n    dispatch_queue_t queueB = dispatch_queue_create(\"queueB\", nil);\n    dispatch_group_async(group, queueA, ^{\n        [weakSelf getWithArray:weakSelf.array];\n        NSLog(@\"%@线程A\",weakSelf.array);\n    });\n    dispatch_group_async(group, queueB, ^{\n        [weakSelf getWithArray:weakSelf.array];\n        NSLog(@\"%@线程B\",weakSelf.array);\n    });\n    NSLog(@\"%@主线程\",weakSelf.array);\n}\n\n- (void)getWithArray:(NSMutableArray *)array {\n    [self.lock lock];\n    if (array.count > 0) {\n        NSLog(@\"%@...objc\",array.lastObject);\n        [array removeLastObject];\n    }\n    [self.lock unlock];\n}\n```\n\n不加锁的打印：可看出线程A和线程B同时操作了getWithArray:\\(NSMutableArray \\*\\)array，由于资源抢占，导致了数组越界而崩溃\n\n```\n2016-07-22 22:18:55.695827+0800 ThreadLock[10764:315922] 4444...objc\n2016-07-22 22:18:55.695827+0800 ThreadLock[10764:315923] 4444...objc\n2016-07-22 22:18:55.695892+0800 ThreadLock[10764:315824] (\n    1111,\n    2222,\n    3333,\n    4444\n)主线程\n2016-07-22 22:18:55.696036+0800 ThreadLock[10764:315922] (\n    1111,\n    2222,\n    3333\n)线程A\n2016-07-22 22:18:55.697056+0800 ThreadLock[10764:315923] *** Terminating app due to uncaught exception 'NSRangeException', reason: '*** -[__NSArrayM removeObjectsInRange:]: range {3, 1} extends beyond bounds [0 .. 2]'\n```\n\n加锁打印：加锁后，线程A先跑，跑的过程中由于线程加锁，线程B无法访问getWithArray:\\(NSMutableArray \\*\\)array，线程A结束之后，线程B发现array中只剩下3个元素，所以把最后一个元素3333给remove掉了，从而达到了线程运行的安全。\n\n```\n2016-07-22 22:10:40.114063+0800 ThreadLock[10425:305487] 4444...objc\n2016-07-22 22:10:40.113988+0800 ThreadLock[10425:305421] (\n    1111,\n    2222,\n    3333,\n    4444\n)主线程\n2016-07-22 22:10:40.117108+0800 ThreadLock[10425:305487] (\n    1111,\n    2222,\n    3333\n)线程A\n2016-07-22 22:10:40.117076+0800 ThreadLock[10425:305486] 3333...objc\n2016-07-22 22:10:40.117703+0800 ThreadLock[10425:305486] (\n    1111,\n    2222\n)线程B\n```\n\n# @synchronized\n\n@synchronized在早期接触的iOS开发中经常接触，尤其是在创建单利模式的时候。\n\n代码以及打印如下：\n\n```\n- (void)getWithArray:(NSMutableArray *)array {\n    @synchronized (self) {\n        if (array.count > 0) {\n            NSLog(@\"%@...objc\",array.lastObject);\n            [array removeLastObject];\n        }\n    }\n}\n```\n\n```\n2016-07-22 22:20:33.083045+0800 ThreadLock[10837:317900] 4444...objc\n2016-07-22 22:20:33.083278+0800 ThreadLock[10837:317693] (\n    1111,\n    2222,\n    3333,\n    4444\n)主线程\n2016-07-22 22:20:33.083437+0800 ThreadLock[10837:317900] (\n    1111,\n    2222,\n    3333\n)线程A\n2016-07-22 22:20:33.083438+0800 ThreadLock[10837:317899] 3333...objc\n2016-07-22 22:20:33.083814+0800 ThreadLock[10837:317899] (\n    1111,\n    2222\n)线程B\n```\n\n---\n\n# 条件信号量dispatch\\_semaphore\\_t\n\n条件信号量详细用法见上一遍，GCD的用法\n\n---\n\n# dispatch\\_barrier\\_async/dispatch\\_barrier\\_sync\n\n详细用法见上一遍，GCD的用法，但有一点值得注意的是：\n\n> 如果在当前线程调用dispatch\\_barrier\\_sync阻塞线程会发生死锁\n\n---\n\n# NSCondition\n\nNSCondition同样实现了NSLocking协议，所以它和NSLock一样，也有NSLocking协议的lock和unlock方法，可以当做NSLock来使用解决线程同步问题，用法完全一样。\n\n```\n- (void)getWithArray:(NSMutableArray *)array {\n    [self.lock lock];\n    if (array.count > 0) {\n        NSLog(@\"%@...objc\",array.lastObject);\n        [array removeLastObject];\n    }\n    [self.lock unlock];\n}\n```\n\n同时，NSCondition提供更高级的用法。wait和signal，和条件信号量类似。\n\n比如我们要监听imageNames数组的个数，当imageNames的个数大于0的时候就执行清空操作。思路是这样的，当imageNames个数大于0时执行清空操作，否则，wait等待执行清空操作。当imageNames个数增加的时候发生signal信号，让等待的线程唤醒继续执行。\n\nNSCondition和NSLock、@synchronized等是不同的是，NSCondition可以给每个线程分别加锁，加锁后不影响其他线程进入临界区。这是非常强大。但是正是因为这种分别加锁的方式，NSCondition使用wait并使用加锁后并不能真正的解决资源的竞争。比如我们有个需求：不能让m&lt;0。假设当前m=0,线程A要判断到m&gt;0为假,执行等待；线程B执行了m=1操作，并唤醒线程A执行m-1操作的同时线程C判断到m&gt;0，因为他们在不同的线程锁里面，同样判断为真也执行了m-1，这个时候线程A和线程C都会执行m-1,但是m=1，结果就会造成m=-1.\n\n当我用数组做删除试验时，做增删操作并不是每次都会出现，大概3-4次后会出现。单纯的使用lock、unlock是没有问题的。\n\n---\n\n# 条件锁NSConditionLock\n\n也有人说这是个互斥锁。NSConditionLock同样实现了NSLocking协议，试验过程中发现性能很低。\n\n```\n- (void)getIamgeName:(NSMutableArray *)imageNames{\n    NSString *imageName;\n    [lock lock];\n    if (imageNames.count>0) {\n        imageName = [imageNames lastObject];\n        [imageNames removeObject:imageName];\n    }\n    [lock unlock];\n}\n```\n\nNSConditionLock也可以像NSCondition一样做多线程之间的任务等待调用，而且是线程安全的。\n\n```\n- (void)getIamgeName:(NSMutableArray *)imageNames{\n    NSString *imageName;\n    [lock lockWhenCondition:1];    //加锁\n    if (imageNames.count>0) {\n        imageName = [imageNames lastObject];\n        [imageNames removeObjectAtIndex:0];\n    }\n    [lock unlockWithCondition:0];     //解锁\n}\n- (void)createImageName:(NSMutableArray *)imageNames{\n    [lock lockWhenCondition:0];\n    [imageNames addObject:@\"0\"];\n    [lock unlockWithCondition:1];\n}\n\n#pragma mark - 多线程取出图片后删除\n- (void)getImageNameWithMultiThread{\n    NSMutableArray *imageNames = [[NSMutableArray alloc]init];\n    dispatch_group_t dispatchGroup = dispatch_group_create();\n    __block double then, now;\n    then = CFAbsoluteTimeGetCurrent();\n    for (int i=0; i<10000; i++) {\n        dispatch_group_async(dispatchGroup, self.synchronizationQueue, ^(){\n            [self getIamgeName:imageNames];\n        });\n        dispatch_group_async(dispatchGroup, self.synchronizationQueue, ^(){\n            [self createImageName:imageNames];\n        });\n    }\n    dispatch_group_notify(dispatchGroup, self.synchronizationQueue, ^(){\n        now = CFAbsoluteTimeGetCurrent();\n        printf(\"thread_lock: %f sec\\nimageNames count: %ld\\n\", now-then,imageNames.count);\n    });\n}\n```\n\n---\n\n# 递归锁NSRecursiveLock\n\n有时候“加锁代码”中存在递归调用，**递归开始前加锁，递归调用开始后会重复执行此方法以至于反复执行加锁代码最终造成死锁，这个时候可以使用递归锁来解决。使用递归锁可以在一个线程中反复获取锁而不造成死锁，这个过程中会记录获取锁和释放锁的次数，只有最后两者平衡锁才被最终释放。**\n\n```\n- (void)getIamgeName:(NSMutableArray *)imageNames{\n    NSString *imageName;\n    [lock lock];\n    if (imageNames.count>0) {\n        imageName = [imageNames firstObject];\n        [imageNames removeObjectAtIndex:0];\n        [self getIamgeName:imageNames];\n    }\n    [lock unlock];\n}\n- (void)getImageNameWithMultiThread{\n    NSMutableArray *imageNames = [NSMutableArray new];\n    int count = 1024*10;\n    for (int i=0; i<count; i++) {\n        [imageNames addObject:[NSString stringWithFormat:@\"%d\",i]];\n    }\n    dispatch_group_t dispatchGroup = dispatch_group_create();\n    __block double then, now;\n    then = CFAbsoluteTimeGetCurrent();\n    dispatch_group_async(dispatchGroup, self.synchronizationQueue, ^(){\n        [self getIamgeName:imageNames];\n    });\n    dispatch_group_notify(dispatchGroup, dispatch_get_main_queue(), ^(){\n        now = CFAbsoluteTimeGetCurrent();\n        printf(\"thread_lock: %f sec\\nimageNames count: %ld\\n\", now-then,imageNames.count);\n    });\n\n}\n```\n\n---\n\n# NSDistributedLock\n\nNSDistributedLock是MAC开发中的跨进程的分布式锁，底层是用文件系统实现的互斥锁。NSDistributedLock没有实现NSLocking协议，所以没有lock方法，取而代之的是非阻塞的tryLock方法。\n\n```\nNSDistributedLock *lock = [[NSDistributedLock alloc] initWithPath:@\"/Users/mac/Desktop/lock.lock\"];\n    while (![lock tryLock])\n    {\n        sleep(1);\n    }\n\n    //do something\n    [lock unlock];\n```\n\n当执行到do something时程序退出,程序再次启动之后tryLock就再也不能成功了,陷入死锁状态.其他应用也不能访问受保护的共享资源。在这种情况下，你可以使用breadLock方法来打破现存的锁以便你可以获取它。但是通常应该避免打破锁，除非你确定拥有进程已经死亡并不可能再释放该锁。\n\n因为是MAC下的线程锁，所以demo里面没有，这里也不做过多关注。\n\n---\n\n# 互斥锁POSIX\n\nPOSIX和dispatch\\_semaphore\\_t很像，但是完全不同。POSIX是Unix/Linux平台上提供的一套条件互斥锁的API。\n\n新建一个简单的POSIX互斥锁，引入头文件`#import <pthread.h>`声明并初始化一个pthread\\_mutex\\_t的结构。使用pthread\\_mutex\\_lock和pthread\\_mutex\\_unlock函数。调用pthread\\_mutex\\_destroy来释放该锁的数据结构。\n\n```\n#import <pthread.h>\n@interface MYPOSIXViewController ()\n{\n    pthread_mutex_t mutex;  //声明pthread_mutex_t的结构\n}\n@end\n\n@implementation MYPOSIXViewController\n- (void)dealloc{\n    pthread_mutex_destroy(&mutex);  //释放该锁的数据结构\n}\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view.\n    pthread_mutex_init(&mutex, NULL);\n    /**\n     *  初始化\n     *\n     */\n}\n\n- (void)getIamgeName:(NSMutableArray *)imageNames{\n    NSString *imageName;\n    /**\n     *  加锁\n     */\n    pthread_mutex_lock(&mutex);\n    if (imageNames.count>0) {\n        imageName = [imageNames firstObject];\n        [imageNames removeObjectAtIndex:0];\n    }\n    /**\n     *  解锁\n     */\n    pthread_mutex_unlock(&mutex);\n}\n```\n\nPOSIX还可以创建条件锁，提供了和NSCondition一样的条件控制，初始化互斥锁同时使用pthread\\_cond\\_init来初始化条件数据结构，\n\n```\n// 初始化\n    int pthread_cond_init (pthread_cond_t *cond, pthread_condattr_t *attr);\n\n    // 等待（会阻塞）\n    int pthread_cond_wait (pthread_cond_t *cond, pthread_mutex_t *mut);\n\n    // 定时等待\n    int pthread_cond_timedwait (pthread_cond_t *cond, pthread_mutex_t *mut, const struct timespec *abstime);\n\n    // 唤醒\n    int pthread_cond_signal (pthread_cond_t *cond);\n\n    // 广播唤醒\n    int pthread_cond_broadcast (pthread_cond_t *cond);\n\n    // 销毁\n    int pthread_cond_destroy (pthread_cond_t *cond);\n```\n\nPOSIX还提供了很多函数，有一套完整的API，包含Pthreads线程的创建控制等等，非常底层，可以手动处理线程的各个状态的转换即管理生命周期，甚至可以实现一套自己的多线程，感兴趣的可以继续深入了解。推荐一篇详细文章，但不是基于iOS的，是基于Linux的，但是介绍的非常详细 [Linux 线程锁详解](http://blog.chinaunix.net/uid-26885237-id-3207962.html)\n\n---\n\n# 自旋锁OSSpinLock\n\n首先要提的是OSSpinLock已经出现了BUG，导致并不能完全保证是线程安全的。\n\n> 新版 iOS 中，系统维护了 5 个不同的线程优先级/QoS: background，utility，default，user-initiated，user-interactive。高优先级线程始终会在低优先级线程前执行，一个线程不会受到比它更低优先级线程的干扰。这种线程调度算法会产生潜在的优先级反转问题，从而破坏了 spin lock。\n>\n> 具体来说，如果一个低优先级的线程获得锁并访问共享资源，这时一个高优先级的线程也尝试获得这个锁，它会处于 spin lock 的忙等状态从而占用大量 CPU。此时低优先级线程无法与高优先级线程争夺 CPU 时间，从而导致任务迟迟完不成、无法释放 lock。这并不只是理论上的问题，libobjc 已经遇到了很多次这个问题了，于是苹果的工程师停用了 OSSpinLock。\n\n> 苹果工程师 Greg Parker 提到，对于这个问题，一种解决方案是用 truly unbounded backoff 算法，这能避免 livelock 问题，但如果系统负载高时，它仍有可能将高优先级的线程阻塞数十秒之久；另一种方案是使用 handoff lock 算法，这也是 libobjc 目前正在使用的。锁的持有者会把线程 ID 保存到锁内部，锁的等待者会临时贡献出它的优先级来避免优先级反转的问题。理论上这种模式会在比较复杂的多锁条件下产生问题，但实践上目前还一切都好。\n\n> OSSpinLock 自旋锁，性能最高的锁。原理很简单，就是一直 do while 忙等。它的缺点是当等待时会消耗大量 CPU 资源，所以它不适用于较长时间的任务。对于内存缓存的存取来说，它非常合适。\n>\n> -摘自[ibireme](http://blog.ibireme.com/author/ibireme/)\n\n```\n<libkern/OSAtomic.h>\n\n#import <libkern/OSAtomic.h>\n@interface MYOSSpinLockViewController ()\n{\n    OSSpinLock spinlock;  //声明pthread_mutex_t的结构\n}\n@end\n\n@implementation MYOSSpinLockViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view.\n    spinlock = OS_SPINLOCK_INIT;\n    /**\n     *  初始化\n     *\n     */\n}\n\n- (void)getIamgeName:(NSMutableArray *)imageNames{\n    NSString *imageName;\n    /**\n     *  加锁\n     */\n    OSSpinLockLock(&spinlock);\n    if (imageNames.count>0) {\n        imageName = [imageNames firstObject];\n        [imageNames removeObjectAtIndex:0];\n    }\n    /**\n     *  解锁\n     */\n    OSSpinLockUnlock(&spinlock);\n}\n@end\n```\n\n# 自旋锁os_unfair_lock\n\n由于OSSpinLock的线程安全问题，Apple已经在iOS10废弃了OSSpinLock自旋锁，取而代之的是os_unfair_lock，虽然os_unfair_lock是线程安全的，但代价就是os_unfair_lock的性能效果相对于OSSpinLock大打折扣\n\nos_unfair_lock用法：\n\n```\n#import <os/lock.h>\n// 初始化\n os_unfair_lock unfair_lock = OS_UNFAIR_LOCK_INIT;\n// 加锁\nos_unfair_lock_lock(&unfair_lock);\n// 解锁\nos_unfair_lock_unlock(&unfair_lock);\n// 尝试加锁，可以加锁则立即加锁并返回 YES,反之返回 NO\nos_unfair_lock_trylock(&unfair_lock);\n/*\n注:解决不同优先级的线程申请锁的时候不会发生优先级反转问题.\n不过相对于 OSSpinLock , os_unfair_lock性能方面减弱了许多.\n*/\n```\n\n---\n\n# 总结\n\n**@synchronized：适用线程不多，任务量不大的多线程加锁；**\n\n**NSLock：其实NSLock并没有想象中的那么差，不知道大家为什么不推荐使用；**\n\n**dispatch\\_semaphore\\_t：使用信号来做加锁，性能提升显著；**\n\n**NSCondition：使用其做多线程之间的通信调用不是线程安全的；**\n\n**NSConditionLock：单纯加锁性能非常低，比NSLock低很多，但是可以用来做多线程处理不同任务的通信调用；**\n\n**NSRecursiveLock：递归锁的性能出奇的高，但是只能作为递归使用,所以限制了使用场景；**\n\n**NSDistributedLock：因为是MAC开发的，就不讨论了；**\n\n**POSIX\\(pthread\\_mutex\\)：底层的api，复杂的多线程处理建议使用，并且可以封装自己的多线程；**\n\n**OSSpinLock：性能也非常高，可惜出现了线程问题；**\n\n**os_unfair_lock iOS10以后用于替代OSSpinLock的另外一种自旋锁，线程安全，性能相对于OSSpinLock大打折扣**\n\n**dispatch\\_barrier\\_async/dispatch\\_barrier\\_sync：测试中发现dispatch\\_barrier\\_sync比dispatch\\_barrier\\_async性能要高，真是大出意外。**\n\n","slug":"iOS多线程编程之线程锁","published":1,"updated":"2023-07-21T09:10:33.573Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clkcgbp5a0009pfo7dmxe7wwb","content":"<h1 id=\"何所谓线程安全\"><a href=\"#何所谓线程安全\" class=\"headerlink\" title=\"何所谓线程安全\"></a>何所谓线程安全</h1><p>线程安全就是在多线程访问的同时，采用用了加锁机制，当一个线程访问该线程外的某个数据时，进行保护，其他线程不能进行访问，直到该线程读取完毕，其他线程才可以访问。保护线程安全无在乎就是对线程进行加锁。</p>\n<p>在iOS开发中常用的加锁方式有以下几种：</p>\n<span id=\"more\"></span>\n\n<h1 id=\"NSLock\"><a href=\"#NSLock\" class=\"headerlink\" title=\"NSLock\"></a>NSLock</h1><p>在iOS程序中NSLock中实现了一个简单的互斥锁，实现了NSLocking协议，</p>\n<p>lock为加锁，</p>\n<p>unlock为解锁，</p>\n<p>tryLock为尝试加锁，如果加锁失败则不会阻塞线程，只会立即回调，需要注意的是，使用tryLock并不能加锁成功 ，如果获取锁失败，则不会执行加锁。</p>\n<p>NOLockBforeDate:在指定的date之前暂时阻塞线程（如果没有获取锁），如果在指定的时间仍然没有获取到🔐的话。线程会被立即唤醒，函数立即返回NO。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    __weak typeof(self) weakSelf = self;</span><br><span class=\"line\">    dispatch_group_t group = dispatch_group_create();</span><br><span class=\"line\">    dispatch_queue_t queueA = dispatch_queue_create(&quot;queueA&quot;, nil);</span><br><span class=\"line\">    dispatch_queue_t queueB = dispatch_queue_create(&quot;queueB&quot;, nil);</span><br><span class=\"line\">    dispatch_group_async(group, queueA, ^&#123;</span><br><span class=\"line\">        [weakSelf getWithArray:weakSelf.array];</span><br><span class=\"line\">        NSLog(@&quot;%@线程A&quot;,weakSelf.array);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    dispatch_group_async(group, queueB, ^&#123;</span><br><span class=\"line\">        [weakSelf getWithArray:weakSelf.array];</span><br><span class=\"line\">        NSLog(@&quot;%@线程B&quot;,weakSelf.array);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    NSLog(@&quot;%@主线程&quot;,weakSelf.array);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)getWithArray:(NSMutableArray *)array &#123;</span><br><span class=\"line\">    [self.lock lock];</span><br><span class=\"line\">    if (array.count &gt; 0) &#123;</span><br><span class=\"line\">        NSLog(@&quot;%@...objc&quot;,array.lastObject);</span><br><span class=\"line\">        [array removeLastObject];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    [self.lock unlock];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不加锁的打印：可看出线程A和线程B同时操作了getWithArray:(NSMutableArray *)array，由于资源抢占，导致了数组越界而崩溃</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-07-22 22:18:55.695827+0800 ThreadLock[10764:315922] 4444...objc</span><br><span class=\"line\">2016-07-22 22:18:55.695827+0800 ThreadLock[10764:315923] 4444...objc</span><br><span class=\"line\">2016-07-22 22:18:55.695892+0800 ThreadLock[10764:315824] (</span><br><span class=\"line\">    1111,</span><br><span class=\"line\">    2222,</span><br><span class=\"line\">    3333,</span><br><span class=\"line\">    4444</span><br><span class=\"line\">)主线程</span><br><span class=\"line\">2016-07-22 22:18:55.696036+0800 ThreadLock[10764:315922] (</span><br><span class=\"line\">    1111,</span><br><span class=\"line\">    2222,</span><br><span class=\"line\">    3333</span><br><span class=\"line\">)线程A</span><br><span class=\"line\">2016-07-22 22:18:55.697056+0800 ThreadLock[10764:315923] *** Terminating app due to uncaught exception &#x27;NSRangeException&#x27;, reason: &#x27;*** -[__NSArrayM removeObjectsInRange:]: range &#123;3, 1&#125; extends beyond bounds [0 .. 2]&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>加锁打印：加锁后，线程A先跑，跑的过程中由于线程加锁，线程B无法访问getWithArray:(NSMutableArray *)array，线程A结束之后，线程B发现array中只剩下3个元素，所以把最后一个元素3333给remove掉了，从而达到了线程运行的安全。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-07-22 22:10:40.114063+0800 ThreadLock[10425:305487] 4444...objc</span><br><span class=\"line\">2016-07-22 22:10:40.113988+0800 ThreadLock[10425:305421] (</span><br><span class=\"line\">    1111,</span><br><span class=\"line\">    2222,</span><br><span class=\"line\">    3333,</span><br><span class=\"line\">    4444</span><br><span class=\"line\">)主线程</span><br><span class=\"line\">2016-07-22 22:10:40.117108+0800 ThreadLock[10425:305487] (</span><br><span class=\"line\">    1111,</span><br><span class=\"line\">    2222,</span><br><span class=\"line\">    3333</span><br><span class=\"line\">)线程A</span><br><span class=\"line\">2016-07-22 22:10:40.117076+0800 ThreadLock[10425:305486] 3333...objc</span><br><span class=\"line\">2016-07-22 22:10:40.117703+0800 ThreadLock[10425:305486] (</span><br><span class=\"line\">    1111,</span><br><span class=\"line\">    2222</span><br><span class=\"line\">)线程B</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"@synchronized\"></a>@synchronized</h1><p>@synchronized在早期接触的iOS开发中经常接触，尤其是在创建单利模式的时候。</p>\n<p>代码以及打印如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)getWithArray:(NSMutableArray *)array &#123;</span><br><span class=\"line\">    @synchronized (self) &#123;</span><br><span class=\"line\">        if (array.count &gt; 0) &#123;</span><br><span class=\"line\">            NSLog(@&quot;%@...objc&quot;,array.lastObject);</span><br><span class=\"line\">            [array removeLastObject];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-07-22 22:20:33.083045+0800 ThreadLock[10837:317900] 4444...objc</span><br><span class=\"line\">2016-07-22 22:20:33.083278+0800 ThreadLock[10837:317693] (</span><br><span class=\"line\">    1111,</span><br><span class=\"line\">    2222,</span><br><span class=\"line\">    3333,</span><br><span class=\"line\">    4444</span><br><span class=\"line\">)主线程</span><br><span class=\"line\">2016-07-22 22:20:33.083437+0800 ThreadLock[10837:317900] (</span><br><span class=\"line\">    1111,</span><br><span class=\"line\">    2222,</span><br><span class=\"line\">    3333</span><br><span class=\"line\">)线程A</span><br><span class=\"line\">2016-07-22 22:20:33.083438+0800 ThreadLock[10837:317899] 3333...objc</span><br><span class=\"line\">2016-07-22 22:20:33.083814+0800 ThreadLock[10837:317899] (</span><br><span class=\"line\">    1111,</span><br><span class=\"line\">    2222</span><br><span class=\"line\">)线程B</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"条件信号量dispatch-semaphore-t\"><a href=\"#条件信号量dispatch-semaphore-t\" class=\"headerlink\" title=\"条件信号量dispatch_semaphore_t\"></a>条件信号量dispatch_semaphore_t</h1><p>条件信号量详细用法见上一遍，GCD的用法</p>\n<hr>\n<h1 id=\"dispatch-barrier-async-dispatch-barrier-sync\"><a href=\"#dispatch-barrier-async-dispatch-barrier-sync\" class=\"headerlink\" title=\"dispatch_barrier_async&#x2F;dispatch_barrier_sync\"></a>dispatch_barrier_async&#x2F;dispatch_barrier_sync</h1><p>详细用法见上一遍，GCD的用法，但有一点值得注意的是：</p>\n<blockquote>\n<p>如果在当前线程调用dispatch_barrier_sync阻塞线程会发生死锁</p>\n</blockquote>\n<hr>\n<h1 id=\"NSCondition\"><a href=\"#NSCondition\" class=\"headerlink\" title=\"NSCondition\"></a>NSCondition</h1><p>NSCondition同样实现了NSLocking协议，所以它和NSLock一样，也有NSLocking协议的lock和unlock方法，可以当做NSLock来使用解决线程同步问题，用法完全一样。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)getWithArray:(NSMutableArray *)array &#123;</span><br><span class=\"line\">    [self.lock lock];</span><br><span class=\"line\">    if (array.count &gt; 0) &#123;</span><br><span class=\"line\">        NSLog(@&quot;%@...objc&quot;,array.lastObject);</span><br><span class=\"line\">        [array removeLastObject];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    [self.lock unlock];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同时，NSCondition提供更高级的用法。wait和signal，和条件信号量类似。</p>\n<p>比如我们要监听imageNames数组的个数，当imageNames的个数大于0的时候就执行清空操作。思路是这样的，当imageNames个数大于0时执行清空操作，否则，wait等待执行清空操作。当imageNames个数增加的时候发生signal信号，让等待的线程唤醒继续执行。</p>\n<p>NSCondition和NSLock、@synchronized等是不同的是，NSCondition可以给每个线程分别加锁，加锁后不影响其他线程进入临界区。这是非常强大。但是正是因为这种分别加锁的方式，NSCondition使用wait并使用加锁后并不能真正的解决资源的竞争。比如我们有个需求：不能让m&lt;0。假设当前m&#x3D;0,线程A要判断到m&gt;0为假,执行等待；线程B执行了m&#x3D;1操作，并唤醒线程A执行m-1操作的同时线程C判断到m&gt;0，因为他们在不同的线程锁里面，同样判断为真也执行了m-1，这个时候线程A和线程C都会执行m-1,但是m&#x3D;1，结果就会造成m&#x3D;-1.</p>\n<p>当我用数组做删除试验时，做增删操作并不是每次都会出现，大概3-4次后会出现。单纯的使用lock、unlock是没有问题的。</p>\n<hr>\n<h1 id=\"条件锁NSConditionLock\"><a href=\"#条件锁NSConditionLock\" class=\"headerlink\" title=\"条件锁NSConditionLock\"></a>条件锁NSConditionLock</h1><p>也有人说这是个互斥锁。NSConditionLock同样实现了NSLocking协议，试验过程中发现性能很低。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)getIamgeName:(NSMutableArray *)imageNames&#123;</span><br><span class=\"line\">    NSString *imageName;</span><br><span class=\"line\">    [lock lock];</span><br><span class=\"line\">    if (imageNames.count&gt;0) &#123;</span><br><span class=\"line\">        imageName = [imageNames lastObject];</span><br><span class=\"line\">        [imageNames removeObject:imageName];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    [lock unlock];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>NSConditionLock也可以像NSCondition一样做多线程之间的任务等待调用，而且是线程安全的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)getIamgeName:(NSMutableArray *)imageNames&#123;</span><br><span class=\"line\">    NSString *imageName;</span><br><span class=\"line\">    [lock lockWhenCondition:1];    //加锁</span><br><span class=\"line\">    if (imageNames.count&gt;0) &#123;</span><br><span class=\"line\">        imageName = [imageNames lastObject];</span><br><span class=\"line\">        [imageNames removeObjectAtIndex:0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    [lock unlockWithCondition:0];     //解锁</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)createImageName:(NSMutableArray *)imageNames&#123;</span><br><span class=\"line\">    [lock lockWhenCondition:0];</span><br><span class=\"line\">    [imageNames addObject:@&quot;0&quot;];</span><br><span class=\"line\">    [lock unlockWithCondition:1];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#pragma mark - 多线程取出图片后删除</span><br><span class=\"line\">- (void)getImageNameWithMultiThread&#123;</span><br><span class=\"line\">    NSMutableArray *imageNames = [[NSMutableArray alloc]init];</span><br><span class=\"line\">    dispatch_group_t dispatchGroup = dispatch_group_create();</span><br><span class=\"line\">    __block double then, now;</span><br><span class=\"line\">    then = CFAbsoluteTimeGetCurrent();</span><br><span class=\"line\">    for (int i=0; i&lt;10000; i++) &#123;</span><br><span class=\"line\">        dispatch_group_async(dispatchGroup, self.synchronizationQueue, ^()&#123;</span><br><span class=\"line\">            [self getIamgeName:imageNames];</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        dispatch_group_async(dispatchGroup, self.synchronizationQueue, ^()&#123;</span><br><span class=\"line\">            [self createImageName:imageNames];</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dispatch_group_notify(dispatchGroup, self.synchronizationQueue, ^()&#123;</span><br><span class=\"line\">        now = CFAbsoluteTimeGetCurrent();</span><br><span class=\"line\">        printf(&quot;thread_lock: %f sec\\nimageNames count: %ld\\n&quot;, now-then,imageNames.count);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"递归锁NSRecursiveLock\"><a href=\"#递归锁NSRecursiveLock\" class=\"headerlink\" title=\"递归锁NSRecursiveLock\"></a>递归锁NSRecursiveLock</h1><p>有时候“加锁代码”中存在递归调用，<strong>递归开始前加锁，递归调用开始后会重复执行此方法以至于反复执行加锁代码最终造成死锁，这个时候可以使用递归锁来解决。使用递归锁可以在一个线程中反复获取锁而不造成死锁，这个过程中会记录获取锁和释放锁的次数，只有最后两者平衡锁才被最终释放。</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)getIamgeName:(NSMutableArray *)imageNames&#123;</span><br><span class=\"line\">    NSString *imageName;</span><br><span class=\"line\">    [lock lock];</span><br><span class=\"line\">    if (imageNames.count&gt;0) &#123;</span><br><span class=\"line\">        imageName = [imageNames firstObject];</span><br><span class=\"line\">        [imageNames removeObjectAtIndex:0];</span><br><span class=\"line\">        [self getIamgeName:imageNames];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    [lock unlock];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)getImageNameWithMultiThread&#123;</span><br><span class=\"line\">    NSMutableArray *imageNames = [NSMutableArray new];</span><br><span class=\"line\">    int count = 1024*10;</span><br><span class=\"line\">    for (int i=0; i&lt;count; i++) &#123;</span><br><span class=\"line\">        [imageNames addObject:[NSString stringWithFormat:@&quot;%d&quot;,i]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dispatch_group_t dispatchGroup = dispatch_group_create();</span><br><span class=\"line\">    __block double then, now;</span><br><span class=\"line\">    then = CFAbsoluteTimeGetCurrent();</span><br><span class=\"line\">    dispatch_group_async(dispatchGroup, self.synchronizationQueue, ^()&#123;</span><br><span class=\"line\">        [self getIamgeName:imageNames];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    dispatch_group_notify(dispatchGroup, dispatch_get_main_queue(), ^()&#123;</span><br><span class=\"line\">        now = CFAbsoluteTimeGetCurrent();</span><br><span class=\"line\">        printf(&quot;thread_lock: %f sec\\nimageNames count: %ld\\n&quot;, now-then,imageNames.count);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"NSDistributedLock\"><a href=\"#NSDistributedLock\" class=\"headerlink\" title=\"NSDistributedLock\"></a>NSDistributedLock</h1><p>NSDistributedLock是MAC开发中的跨进程的分布式锁，底层是用文件系统实现的互斥锁。NSDistributedLock没有实现NSLocking协议，所以没有lock方法，取而代之的是非阻塞的tryLock方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSDistributedLock *lock = [[NSDistributedLock alloc] initWithPath:@&quot;/Users/mac/Desktop/lock.lock&quot;];</span><br><span class=\"line\">    while (![lock tryLock])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        sleep(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //do something</span><br><span class=\"line\">    [lock unlock];</span><br></pre></td></tr></table></figure>\n\n<p>当执行到do something时程序退出,程序再次启动之后tryLock就再也不能成功了,陷入死锁状态.其他应用也不能访问受保护的共享资源。在这种情况下，你可以使用breadLock方法来打破现存的锁以便你可以获取它。但是通常应该避免打破锁，除非你确定拥有进程已经死亡并不可能再释放该锁。</p>\n<p>因为是MAC下的线程锁，所以demo里面没有，这里也不做过多关注。</p>\n<hr>\n<h1 id=\"互斥锁POSIX\"><a href=\"#互斥锁POSIX\" class=\"headerlink\" title=\"互斥锁POSIX\"></a>互斥锁POSIX</h1><p>POSIX和dispatch_semaphore_t很像，但是完全不同。POSIX是Unix&#x2F;Linux平台上提供的一套条件互斥锁的API。</p>\n<p>新建一个简单的POSIX互斥锁，引入头文件<code>#import &lt;pthread.h&gt;</code>声明并初始化一个pthread_mutex_t的结构。使用pthread_mutex_lock和pthread_mutex_unlock函数。调用pthread_mutex_destroy来释放该锁的数据结构。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;pthread.h&gt;</span><br><span class=\"line\">@interface MYPOSIXViewController ()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    pthread_mutex_t mutex;  //声明pthread_mutex_t的结构</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation MYPOSIXViewController</span><br><span class=\"line\">- (void)dealloc&#123;</span><br><span class=\"line\">    pthread_mutex_destroy(&amp;mutex);  //释放该锁的数据结构</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    // Do any additional setup after loading the view.</span><br><span class=\"line\">    pthread_mutex_init(&amp;mutex, NULL);</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *  初始化</span><br><span class=\"line\">     *</span><br><span class=\"line\">     */</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)getIamgeName:(NSMutableArray *)imageNames&#123;</span><br><span class=\"line\">    NSString *imageName;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *  加锁</span><br><span class=\"line\">     */</span><br><span class=\"line\">    pthread_mutex_lock(&amp;mutex);</span><br><span class=\"line\">    if (imageNames.count&gt;0) &#123;</span><br><span class=\"line\">        imageName = [imageNames firstObject];</span><br><span class=\"line\">        [imageNames removeObjectAtIndex:0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *  解锁</span><br><span class=\"line\">     */</span><br><span class=\"line\">    pthread_mutex_unlock(&amp;mutex);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>POSIX还可以创建条件锁，提供了和NSCondition一样的条件控制，初始化互斥锁同时使用pthread_cond_init来初始化条件数据结构，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 初始化</span><br><span class=\"line\">    int pthread_cond_init (pthread_cond_t *cond, pthread_condattr_t *attr);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 等待（会阻塞）</span><br><span class=\"line\">    int pthread_cond_wait (pthread_cond_t *cond, pthread_mutex_t *mut);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 定时等待</span><br><span class=\"line\">    int pthread_cond_timedwait (pthread_cond_t *cond, pthread_mutex_t *mut, const struct timespec *abstime);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 唤醒</span><br><span class=\"line\">    int pthread_cond_signal (pthread_cond_t *cond);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 广播唤醒</span><br><span class=\"line\">    int pthread_cond_broadcast (pthread_cond_t *cond);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 销毁</span><br><span class=\"line\">    int pthread_cond_destroy (pthread_cond_t *cond);</span><br></pre></td></tr></table></figure>\n\n<p>POSIX还提供了很多函数，有一套完整的API，包含Pthreads线程的创建控制等等，非常底层，可以手动处理线程的各个状态的转换即管理生命周期，甚至可以实现一套自己的多线程，感兴趣的可以继续深入了解。推荐一篇详细文章，但不是基于iOS的，是基于Linux的，但是介绍的非常详细 <a href=\"http://blog.chinaunix.net/uid-26885237-id-3207962.html\">Linux 线程锁详解</a></p>\n<hr>\n<h1 id=\"自旋锁OSSpinLock\"><a href=\"#自旋锁OSSpinLock\" class=\"headerlink\" title=\"自旋锁OSSpinLock\"></a>自旋锁OSSpinLock</h1><p>首先要提的是OSSpinLock已经出现了BUG，导致并不能完全保证是线程安全的。</p>\n<blockquote>\n<p>新版 iOS 中，系统维护了 5 个不同的线程优先级&#x2F;QoS: background，utility，default，user-initiated，user-interactive。高优先级线程始终会在低优先级线程前执行，一个线程不会受到比它更低优先级线程的干扰。这种线程调度算法会产生潜在的优先级反转问题，从而破坏了 spin lock。</p>\n<p>具体来说，如果一个低优先级的线程获得锁并访问共享资源，这时一个高优先级的线程也尝试获得这个锁，它会处于 spin lock 的忙等状态从而占用大量 CPU。此时低优先级线程无法与高优先级线程争夺 CPU 时间，从而导致任务迟迟完不成、无法释放 lock。这并不只是理论上的问题，libobjc 已经遇到了很多次这个问题了，于是苹果的工程师停用了 OSSpinLock。</p>\n</blockquote>\n<blockquote>\n<p>苹果工程师 Greg Parker 提到，对于这个问题，一种解决方案是用 truly unbounded backoff 算法，这能避免 livelock 问题，但如果系统负载高时，它仍有可能将高优先级的线程阻塞数十秒之久；另一种方案是使用 handoff lock 算法，这也是 libobjc 目前正在使用的。锁的持有者会把线程 ID 保存到锁内部，锁的等待者会临时贡献出它的优先级来避免优先级反转的问题。理论上这种模式会在比较复杂的多锁条件下产生问题，但实践上目前还一切都好。</p>\n</blockquote>\n<blockquote>\n<p>OSSpinLock 自旋锁，性能最高的锁。原理很简单，就是一直 do while 忙等。它的缺点是当等待时会消耗大量 CPU 资源，所以它不适用于较长时间的任务。对于内存缓存的存取来说，它非常合适。</p>\n<p>-摘自<a href=\"http://blog.ibireme.com/author/ibireme/\">ibireme</a></p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;libkern/OSAtomic.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#import &lt;libkern/OSAtomic.h&gt;</span><br><span class=\"line\">@interface MYOSSpinLockViewController ()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    OSSpinLock spinlock;  //声明pthread_mutex_t的结构</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation MYOSSpinLockViewController</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    // Do any additional setup after loading the view.</span><br><span class=\"line\">    spinlock = OS_SPINLOCK_INIT;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *  初始化</span><br><span class=\"line\">     *</span><br><span class=\"line\">     */</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)getIamgeName:(NSMutableArray *)imageNames&#123;</span><br><span class=\"line\">    NSString *imageName;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *  加锁</span><br><span class=\"line\">     */</span><br><span class=\"line\">    OSSpinLockLock(&amp;spinlock);</span><br><span class=\"line\">    if (imageNames.count&gt;0) &#123;</span><br><span class=\"line\">        imageName = [imageNames firstObject];</span><br><span class=\"line\">        [imageNames removeObjectAtIndex:0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *  解锁</span><br><span class=\"line\">     */</span><br><span class=\"line\">    OSSpinLockUnlock(&amp;spinlock);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"自旋锁os-unfair-lock\"><a href=\"#自旋锁os-unfair-lock\" class=\"headerlink\" title=\"自旋锁os_unfair_lock\"></a>自旋锁os_unfair_lock</h1><p>由于OSSpinLock的线程安全问题，Apple已经在iOS10废弃了OSSpinLock自旋锁，取而代之的是os_unfair_lock，虽然os_unfair_lock是线程安全的，但代价就是os_unfair_lock的性能效果相对于OSSpinLock大打折扣</p>\n<p>os_unfair_lock用法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;os/lock.h&gt;</span><br><span class=\"line\">// 初始化</span><br><span class=\"line\"> os_unfair_lock unfair_lock = OS_UNFAIR_LOCK_INIT;</span><br><span class=\"line\">// 加锁</span><br><span class=\"line\">os_unfair_lock_lock(&amp;unfair_lock);</span><br><span class=\"line\">// 解锁</span><br><span class=\"line\">os_unfair_lock_unlock(&amp;unfair_lock);</span><br><span class=\"line\">// 尝试加锁，可以加锁则立即加锁并返回 YES,反之返回 NO</span><br><span class=\"line\">os_unfair_lock_trylock(&amp;unfair_lock);</span><br><span class=\"line\">/*</span><br><span class=\"line\">注:解决不同优先级的线程申请锁的时候不会发生优先级反转问题.</span><br><span class=\"line\">不过相对于 OSSpinLock , os_unfair_lock性能方面减弱了许多.</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p><strong>@synchronized：适用线程不多，任务量不大的多线程加锁；</strong></p>\n<p><strong>NSLock：其实NSLock并没有想象中的那么差，不知道大家为什么不推荐使用；</strong></p>\n<p><strong>dispatch_semaphore_t：使用信号来做加锁，性能提升显著；</strong></p>\n<p><strong>NSCondition：使用其做多线程之间的通信调用不是线程安全的；</strong></p>\n<p><strong>NSConditionLock：单纯加锁性能非常低，比NSLock低很多，但是可以用来做多线程处理不同任务的通信调用；</strong></p>\n<p><strong>NSRecursiveLock：递归锁的性能出奇的高，但是只能作为递归使用,所以限制了使用场景；</strong></p>\n<p><strong>NSDistributedLock：因为是MAC开发的，就不讨论了；</strong></p>\n<p><strong>POSIX(pthread_mutex)：底层的api，复杂的多线程处理建议使用，并且可以封装自己的多线程；</strong></p>\n<p><strong>OSSpinLock：性能也非常高，可惜出现了线程问题；</strong></p>\n<p><strong>os_unfair_lock iOS10以后用于替代OSSpinLock的另外一种自旋锁，线程安全，性能相对于OSSpinLock大打折扣</strong></p>\n<p><strong>dispatch_barrier_async&#x2F;dispatch_barrier_sync：测试中发现dispatch_barrier_sync比dispatch_barrier_async性能要高，真是大出意外。</strong></p>\n","site":{"data":{}},"length":10915,"excerpt":"<h1 id=\"何所谓线程安全\"><a href=\"#何所谓线程安全\" class=\"headerlink\" title=\"何所谓线程安全\"></a>何所谓线程安全</h1><p>线程安全就是在多线程访问的同时，采用用了加锁机制，当一个线程访问该线程外的某个数据时，进行保护，其他线程不能进行访问，直到该线程读取完毕，其他线程才可以访问。保护线程安全无在乎就是对线程进行加锁。</p>\n<p>在iOS开发中常用的加锁方式有以下几种：</p>","more":"<h1 id=\"NSLock\"><a href=\"#NSLock\" class=\"headerlink\" title=\"NSLock\"></a>NSLock</h1><p>在iOS程序中NSLock中实现了一个简单的互斥锁，实现了NSLocking协议，</p>\n<p>lock为加锁，</p>\n<p>unlock为解锁，</p>\n<p>tryLock为尝试加锁，如果加锁失败则不会阻塞线程，只会立即回调，需要注意的是，使用tryLock并不能加锁成功 ，如果获取锁失败，则不会执行加锁。</p>\n<p>NOLockBforeDate:在指定的date之前暂时阻塞线程（如果没有获取锁），如果在指定的时间仍然没有获取到🔐的话。线程会被立即唤醒，函数立即返回NO。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    __weak typeof(self) weakSelf = self;</span><br><span class=\"line\">    dispatch_group_t group = dispatch_group_create();</span><br><span class=\"line\">    dispatch_queue_t queueA = dispatch_queue_create(&quot;queueA&quot;, nil);</span><br><span class=\"line\">    dispatch_queue_t queueB = dispatch_queue_create(&quot;queueB&quot;, nil);</span><br><span class=\"line\">    dispatch_group_async(group, queueA, ^&#123;</span><br><span class=\"line\">        [weakSelf getWithArray:weakSelf.array];</span><br><span class=\"line\">        NSLog(@&quot;%@线程A&quot;,weakSelf.array);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    dispatch_group_async(group, queueB, ^&#123;</span><br><span class=\"line\">        [weakSelf getWithArray:weakSelf.array];</span><br><span class=\"line\">        NSLog(@&quot;%@线程B&quot;,weakSelf.array);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    NSLog(@&quot;%@主线程&quot;,weakSelf.array);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)getWithArray:(NSMutableArray *)array &#123;</span><br><span class=\"line\">    [self.lock lock];</span><br><span class=\"line\">    if (array.count &gt; 0) &#123;</span><br><span class=\"line\">        NSLog(@&quot;%@...objc&quot;,array.lastObject);</span><br><span class=\"line\">        [array removeLastObject];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    [self.lock unlock];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不加锁的打印：可看出线程A和线程B同时操作了getWithArray:(NSMutableArray *)array，由于资源抢占，导致了数组越界而崩溃</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-07-22 22:18:55.695827+0800 ThreadLock[10764:315922] 4444...objc</span><br><span class=\"line\">2016-07-22 22:18:55.695827+0800 ThreadLock[10764:315923] 4444...objc</span><br><span class=\"line\">2016-07-22 22:18:55.695892+0800 ThreadLock[10764:315824] (</span><br><span class=\"line\">    1111,</span><br><span class=\"line\">    2222,</span><br><span class=\"line\">    3333,</span><br><span class=\"line\">    4444</span><br><span class=\"line\">)主线程</span><br><span class=\"line\">2016-07-22 22:18:55.696036+0800 ThreadLock[10764:315922] (</span><br><span class=\"line\">    1111,</span><br><span class=\"line\">    2222,</span><br><span class=\"line\">    3333</span><br><span class=\"line\">)线程A</span><br><span class=\"line\">2016-07-22 22:18:55.697056+0800 ThreadLock[10764:315923] *** Terminating app due to uncaught exception &#x27;NSRangeException&#x27;, reason: &#x27;*** -[__NSArrayM removeObjectsInRange:]: range &#123;3, 1&#125; extends beyond bounds [0 .. 2]&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>加锁打印：加锁后，线程A先跑，跑的过程中由于线程加锁，线程B无法访问getWithArray:(NSMutableArray *)array，线程A结束之后，线程B发现array中只剩下3个元素，所以把最后一个元素3333给remove掉了，从而达到了线程运行的安全。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-07-22 22:10:40.114063+0800 ThreadLock[10425:305487] 4444...objc</span><br><span class=\"line\">2016-07-22 22:10:40.113988+0800 ThreadLock[10425:305421] (</span><br><span class=\"line\">    1111,</span><br><span class=\"line\">    2222,</span><br><span class=\"line\">    3333,</span><br><span class=\"line\">    4444</span><br><span class=\"line\">)主线程</span><br><span class=\"line\">2016-07-22 22:10:40.117108+0800 ThreadLock[10425:305487] (</span><br><span class=\"line\">    1111,</span><br><span class=\"line\">    2222,</span><br><span class=\"line\">    3333</span><br><span class=\"line\">)线程A</span><br><span class=\"line\">2016-07-22 22:10:40.117076+0800 ThreadLock[10425:305486] 3333...objc</span><br><span class=\"line\">2016-07-22 22:10:40.117703+0800 ThreadLock[10425:305486] (</span><br><span class=\"line\">    1111,</span><br><span class=\"line\">    2222</span><br><span class=\"line\">)线程B</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"@synchronized\"></a>@synchronized</h1><p>@synchronized在早期接触的iOS开发中经常接触，尤其是在创建单利模式的时候。</p>\n<p>代码以及打印如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)getWithArray:(NSMutableArray *)array &#123;</span><br><span class=\"line\">    @synchronized (self) &#123;</span><br><span class=\"line\">        if (array.count &gt; 0) &#123;</span><br><span class=\"line\">            NSLog(@&quot;%@...objc&quot;,array.lastObject);</span><br><span class=\"line\">            [array removeLastObject];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-07-22 22:20:33.083045+0800 ThreadLock[10837:317900] 4444...objc</span><br><span class=\"line\">2016-07-22 22:20:33.083278+0800 ThreadLock[10837:317693] (</span><br><span class=\"line\">    1111,</span><br><span class=\"line\">    2222,</span><br><span class=\"line\">    3333,</span><br><span class=\"line\">    4444</span><br><span class=\"line\">)主线程</span><br><span class=\"line\">2016-07-22 22:20:33.083437+0800 ThreadLock[10837:317900] (</span><br><span class=\"line\">    1111,</span><br><span class=\"line\">    2222,</span><br><span class=\"line\">    3333</span><br><span class=\"line\">)线程A</span><br><span class=\"line\">2016-07-22 22:20:33.083438+0800 ThreadLock[10837:317899] 3333...objc</span><br><span class=\"line\">2016-07-22 22:20:33.083814+0800 ThreadLock[10837:317899] (</span><br><span class=\"line\">    1111,</span><br><span class=\"line\">    2222</span><br><span class=\"line\">)线程B</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"条件信号量dispatch-semaphore-t\"><a href=\"#条件信号量dispatch-semaphore-t\" class=\"headerlink\" title=\"条件信号量dispatch_semaphore_t\"></a>条件信号量dispatch_semaphore_t</h1><p>条件信号量详细用法见上一遍，GCD的用法</p>\n<hr>\n<h1 id=\"dispatch-barrier-async-dispatch-barrier-sync\"><a href=\"#dispatch-barrier-async-dispatch-barrier-sync\" class=\"headerlink\" title=\"dispatch_barrier_async&#x2F;dispatch_barrier_sync\"></a>dispatch_barrier_async&#x2F;dispatch_barrier_sync</h1><p>详细用法见上一遍，GCD的用法，但有一点值得注意的是：</p>\n<blockquote>\n<p>如果在当前线程调用dispatch_barrier_sync阻塞线程会发生死锁</p>\n</blockquote>\n<hr>\n<h1 id=\"NSCondition\"><a href=\"#NSCondition\" class=\"headerlink\" title=\"NSCondition\"></a>NSCondition</h1><p>NSCondition同样实现了NSLocking协议，所以它和NSLock一样，也有NSLocking协议的lock和unlock方法，可以当做NSLock来使用解决线程同步问题，用法完全一样。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)getWithArray:(NSMutableArray *)array &#123;</span><br><span class=\"line\">    [self.lock lock];</span><br><span class=\"line\">    if (array.count &gt; 0) &#123;</span><br><span class=\"line\">        NSLog(@&quot;%@...objc&quot;,array.lastObject);</span><br><span class=\"line\">        [array removeLastObject];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    [self.lock unlock];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同时，NSCondition提供更高级的用法。wait和signal，和条件信号量类似。</p>\n<p>比如我们要监听imageNames数组的个数，当imageNames的个数大于0的时候就执行清空操作。思路是这样的，当imageNames个数大于0时执行清空操作，否则，wait等待执行清空操作。当imageNames个数增加的时候发生signal信号，让等待的线程唤醒继续执行。</p>\n<p>NSCondition和NSLock、@synchronized等是不同的是，NSCondition可以给每个线程分别加锁，加锁后不影响其他线程进入临界区。这是非常强大。但是正是因为这种分别加锁的方式，NSCondition使用wait并使用加锁后并不能真正的解决资源的竞争。比如我们有个需求：不能让m&lt;0。假设当前m&#x3D;0,线程A要判断到m&gt;0为假,执行等待；线程B执行了m&#x3D;1操作，并唤醒线程A执行m-1操作的同时线程C判断到m&gt;0，因为他们在不同的线程锁里面，同样判断为真也执行了m-1，这个时候线程A和线程C都会执行m-1,但是m&#x3D;1，结果就会造成m&#x3D;-1.</p>\n<p>当我用数组做删除试验时，做增删操作并不是每次都会出现，大概3-4次后会出现。单纯的使用lock、unlock是没有问题的。</p>\n<hr>\n<h1 id=\"条件锁NSConditionLock\"><a href=\"#条件锁NSConditionLock\" class=\"headerlink\" title=\"条件锁NSConditionLock\"></a>条件锁NSConditionLock</h1><p>也有人说这是个互斥锁。NSConditionLock同样实现了NSLocking协议，试验过程中发现性能很低。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)getIamgeName:(NSMutableArray *)imageNames&#123;</span><br><span class=\"line\">    NSString *imageName;</span><br><span class=\"line\">    [lock lock];</span><br><span class=\"line\">    if (imageNames.count&gt;0) &#123;</span><br><span class=\"line\">        imageName = [imageNames lastObject];</span><br><span class=\"line\">        [imageNames removeObject:imageName];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    [lock unlock];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>NSConditionLock也可以像NSCondition一样做多线程之间的任务等待调用，而且是线程安全的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)getIamgeName:(NSMutableArray *)imageNames&#123;</span><br><span class=\"line\">    NSString *imageName;</span><br><span class=\"line\">    [lock lockWhenCondition:1];    //加锁</span><br><span class=\"line\">    if (imageNames.count&gt;0) &#123;</span><br><span class=\"line\">        imageName = [imageNames lastObject];</span><br><span class=\"line\">        [imageNames removeObjectAtIndex:0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    [lock unlockWithCondition:0];     //解锁</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)createImageName:(NSMutableArray *)imageNames&#123;</span><br><span class=\"line\">    [lock lockWhenCondition:0];</span><br><span class=\"line\">    [imageNames addObject:@&quot;0&quot;];</span><br><span class=\"line\">    [lock unlockWithCondition:1];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#pragma mark - 多线程取出图片后删除</span><br><span class=\"line\">- (void)getImageNameWithMultiThread&#123;</span><br><span class=\"line\">    NSMutableArray *imageNames = [[NSMutableArray alloc]init];</span><br><span class=\"line\">    dispatch_group_t dispatchGroup = dispatch_group_create();</span><br><span class=\"line\">    __block double then, now;</span><br><span class=\"line\">    then = CFAbsoluteTimeGetCurrent();</span><br><span class=\"line\">    for (int i=0; i&lt;10000; i++) &#123;</span><br><span class=\"line\">        dispatch_group_async(dispatchGroup, self.synchronizationQueue, ^()&#123;</span><br><span class=\"line\">            [self getIamgeName:imageNames];</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        dispatch_group_async(dispatchGroup, self.synchronizationQueue, ^()&#123;</span><br><span class=\"line\">            [self createImageName:imageNames];</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dispatch_group_notify(dispatchGroup, self.synchronizationQueue, ^()&#123;</span><br><span class=\"line\">        now = CFAbsoluteTimeGetCurrent();</span><br><span class=\"line\">        printf(&quot;thread_lock: %f sec\\nimageNames count: %ld\\n&quot;, now-then,imageNames.count);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"递归锁NSRecursiveLock\"><a href=\"#递归锁NSRecursiveLock\" class=\"headerlink\" title=\"递归锁NSRecursiveLock\"></a>递归锁NSRecursiveLock</h1><p>有时候“加锁代码”中存在递归调用，<strong>递归开始前加锁，递归调用开始后会重复执行此方法以至于反复执行加锁代码最终造成死锁，这个时候可以使用递归锁来解决。使用递归锁可以在一个线程中反复获取锁而不造成死锁，这个过程中会记录获取锁和释放锁的次数，只有最后两者平衡锁才被最终释放。</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)getIamgeName:(NSMutableArray *)imageNames&#123;</span><br><span class=\"line\">    NSString *imageName;</span><br><span class=\"line\">    [lock lock];</span><br><span class=\"line\">    if (imageNames.count&gt;0) &#123;</span><br><span class=\"line\">        imageName = [imageNames firstObject];</span><br><span class=\"line\">        [imageNames removeObjectAtIndex:0];</span><br><span class=\"line\">        [self getIamgeName:imageNames];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    [lock unlock];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)getImageNameWithMultiThread&#123;</span><br><span class=\"line\">    NSMutableArray *imageNames = [NSMutableArray new];</span><br><span class=\"line\">    int count = 1024*10;</span><br><span class=\"line\">    for (int i=0; i&lt;count; i++) &#123;</span><br><span class=\"line\">        [imageNames addObject:[NSString stringWithFormat:@&quot;%d&quot;,i]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dispatch_group_t dispatchGroup = dispatch_group_create();</span><br><span class=\"line\">    __block double then, now;</span><br><span class=\"line\">    then = CFAbsoluteTimeGetCurrent();</span><br><span class=\"line\">    dispatch_group_async(dispatchGroup, self.synchronizationQueue, ^()&#123;</span><br><span class=\"line\">        [self getIamgeName:imageNames];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    dispatch_group_notify(dispatchGroup, dispatch_get_main_queue(), ^()&#123;</span><br><span class=\"line\">        now = CFAbsoluteTimeGetCurrent();</span><br><span class=\"line\">        printf(&quot;thread_lock: %f sec\\nimageNames count: %ld\\n&quot;, now-then,imageNames.count);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"NSDistributedLock\"><a href=\"#NSDistributedLock\" class=\"headerlink\" title=\"NSDistributedLock\"></a>NSDistributedLock</h1><p>NSDistributedLock是MAC开发中的跨进程的分布式锁，底层是用文件系统实现的互斥锁。NSDistributedLock没有实现NSLocking协议，所以没有lock方法，取而代之的是非阻塞的tryLock方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSDistributedLock *lock = [[NSDistributedLock alloc] initWithPath:@&quot;/Users/mac/Desktop/lock.lock&quot;];</span><br><span class=\"line\">    while (![lock tryLock])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        sleep(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //do something</span><br><span class=\"line\">    [lock unlock];</span><br></pre></td></tr></table></figure>\n\n<p>当执行到do something时程序退出,程序再次启动之后tryLock就再也不能成功了,陷入死锁状态.其他应用也不能访问受保护的共享资源。在这种情况下，你可以使用breadLock方法来打破现存的锁以便你可以获取它。但是通常应该避免打破锁，除非你确定拥有进程已经死亡并不可能再释放该锁。</p>\n<p>因为是MAC下的线程锁，所以demo里面没有，这里也不做过多关注。</p>\n<hr>\n<h1 id=\"互斥锁POSIX\"><a href=\"#互斥锁POSIX\" class=\"headerlink\" title=\"互斥锁POSIX\"></a>互斥锁POSIX</h1><p>POSIX和dispatch_semaphore_t很像，但是完全不同。POSIX是Unix&#x2F;Linux平台上提供的一套条件互斥锁的API。</p>\n<p>新建一个简单的POSIX互斥锁，引入头文件<code>#import &lt;pthread.h&gt;</code>声明并初始化一个pthread_mutex_t的结构。使用pthread_mutex_lock和pthread_mutex_unlock函数。调用pthread_mutex_destroy来释放该锁的数据结构。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;pthread.h&gt;</span><br><span class=\"line\">@interface MYPOSIXViewController ()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    pthread_mutex_t mutex;  //声明pthread_mutex_t的结构</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation MYPOSIXViewController</span><br><span class=\"line\">- (void)dealloc&#123;</span><br><span class=\"line\">    pthread_mutex_destroy(&amp;mutex);  //释放该锁的数据结构</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    // Do any additional setup after loading the view.</span><br><span class=\"line\">    pthread_mutex_init(&amp;mutex, NULL);</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *  初始化</span><br><span class=\"line\">     *</span><br><span class=\"line\">     */</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)getIamgeName:(NSMutableArray *)imageNames&#123;</span><br><span class=\"line\">    NSString *imageName;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *  加锁</span><br><span class=\"line\">     */</span><br><span class=\"line\">    pthread_mutex_lock(&amp;mutex);</span><br><span class=\"line\">    if (imageNames.count&gt;0) &#123;</span><br><span class=\"line\">        imageName = [imageNames firstObject];</span><br><span class=\"line\">        [imageNames removeObjectAtIndex:0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *  解锁</span><br><span class=\"line\">     */</span><br><span class=\"line\">    pthread_mutex_unlock(&amp;mutex);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>POSIX还可以创建条件锁，提供了和NSCondition一样的条件控制，初始化互斥锁同时使用pthread_cond_init来初始化条件数据结构，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 初始化</span><br><span class=\"line\">    int pthread_cond_init (pthread_cond_t *cond, pthread_condattr_t *attr);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 等待（会阻塞）</span><br><span class=\"line\">    int pthread_cond_wait (pthread_cond_t *cond, pthread_mutex_t *mut);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 定时等待</span><br><span class=\"line\">    int pthread_cond_timedwait (pthread_cond_t *cond, pthread_mutex_t *mut, const struct timespec *abstime);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 唤醒</span><br><span class=\"line\">    int pthread_cond_signal (pthread_cond_t *cond);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 广播唤醒</span><br><span class=\"line\">    int pthread_cond_broadcast (pthread_cond_t *cond);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 销毁</span><br><span class=\"line\">    int pthread_cond_destroy (pthread_cond_t *cond);</span><br></pre></td></tr></table></figure>\n\n<p>POSIX还提供了很多函数，有一套完整的API，包含Pthreads线程的创建控制等等，非常底层，可以手动处理线程的各个状态的转换即管理生命周期，甚至可以实现一套自己的多线程，感兴趣的可以继续深入了解。推荐一篇详细文章，但不是基于iOS的，是基于Linux的，但是介绍的非常详细 <a href=\"http://blog.chinaunix.net/uid-26885237-id-3207962.html\">Linux 线程锁详解</a></p>\n<hr>\n<h1 id=\"自旋锁OSSpinLock\"><a href=\"#自旋锁OSSpinLock\" class=\"headerlink\" title=\"自旋锁OSSpinLock\"></a>自旋锁OSSpinLock</h1><p>首先要提的是OSSpinLock已经出现了BUG，导致并不能完全保证是线程安全的。</p>\n<blockquote>\n<p>新版 iOS 中，系统维护了 5 个不同的线程优先级&#x2F;QoS: background，utility，default，user-initiated，user-interactive。高优先级线程始终会在低优先级线程前执行，一个线程不会受到比它更低优先级线程的干扰。这种线程调度算法会产生潜在的优先级反转问题，从而破坏了 spin lock。</p>\n<p>具体来说，如果一个低优先级的线程获得锁并访问共享资源，这时一个高优先级的线程也尝试获得这个锁，它会处于 spin lock 的忙等状态从而占用大量 CPU。此时低优先级线程无法与高优先级线程争夺 CPU 时间，从而导致任务迟迟完不成、无法释放 lock。这并不只是理论上的问题，libobjc 已经遇到了很多次这个问题了，于是苹果的工程师停用了 OSSpinLock。</p>\n</blockquote>\n<blockquote>\n<p>苹果工程师 Greg Parker 提到，对于这个问题，一种解决方案是用 truly unbounded backoff 算法，这能避免 livelock 问题，但如果系统负载高时，它仍有可能将高优先级的线程阻塞数十秒之久；另一种方案是使用 handoff lock 算法，这也是 libobjc 目前正在使用的。锁的持有者会把线程 ID 保存到锁内部，锁的等待者会临时贡献出它的优先级来避免优先级反转的问题。理论上这种模式会在比较复杂的多锁条件下产生问题，但实践上目前还一切都好。</p>\n</blockquote>\n<blockquote>\n<p>OSSpinLock 自旋锁，性能最高的锁。原理很简单，就是一直 do while 忙等。它的缺点是当等待时会消耗大量 CPU 资源，所以它不适用于较长时间的任务。对于内存缓存的存取来说，它非常合适。</p>\n<p>-摘自<a href=\"http://blog.ibireme.com/author/ibireme/\">ibireme</a></p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;libkern/OSAtomic.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#import &lt;libkern/OSAtomic.h&gt;</span><br><span class=\"line\">@interface MYOSSpinLockViewController ()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    OSSpinLock spinlock;  //声明pthread_mutex_t的结构</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation MYOSSpinLockViewController</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    // Do any additional setup after loading the view.</span><br><span class=\"line\">    spinlock = OS_SPINLOCK_INIT;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *  初始化</span><br><span class=\"line\">     *</span><br><span class=\"line\">     */</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)getIamgeName:(NSMutableArray *)imageNames&#123;</span><br><span class=\"line\">    NSString *imageName;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *  加锁</span><br><span class=\"line\">     */</span><br><span class=\"line\">    OSSpinLockLock(&amp;spinlock);</span><br><span class=\"line\">    if (imageNames.count&gt;0) &#123;</span><br><span class=\"line\">        imageName = [imageNames firstObject];</span><br><span class=\"line\">        [imageNames removeObjectAtIndex:0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *  解锁</span><br><span class=\"line\">     */</span><br><span class=\"line\">    OSSpinLockUnlock(&amp;spinlock);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"自旋锁os-unfair-lock\"><a href=\"#自旋锁os-unfair-lock\" class=\"headerlink\" title=\"自旋锁os_unfair_lock\"></a>自旋锁os_unfair_lock</h1><p>由于OSSpinLock的线程安全问题，Apple已经在iOS10废弃了OSSpinLock自旋锁，取而代之的是os_unfair_lock，虽然os_unfair_lock是线程安全的，但代价就是os_unfair_lock的性能效果相对于OSSpinLock大打折扣</p>\n<p>os_unfair_lock用法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;os/lock.h&gt;</span><br><span class=\"line\">// 初始化</span><br><span class=\"line\"> os_unfair_lock unfair_lock = OS_UNFAIR_LOCK_INIT;</span><br><span class=\"line\">// 加锁</span><br><span class=\"line\">os_unfair_lock_lock(&amp;unfair_lock);</span><br><span class=\"line\">// 解锁</span><br><span class=\"line\">os_unfair_lock_unlock(&amp;unfair_lock);</span><br><span class=\"line\">// 尝试加锁，可以加锁则立即加锁并返回 YES,反之返回 NO</span><br><span class=\"line\">os_unfair_lock_trylock(&amp;unfair_lock);</span><br><span class=\"line\">/*</span><br><span class=\"line\">注:解决不同优先级的线程申请锁的时候不会发生优先级反转问题.</span><br><span class=\"line\">不过相对于 OSSpinLock , os_unfair_lock性能方面减弱了许多.</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p><strong>@synchronized：适用线程不多，任务量不大的多线程加锁；</strong></p>\n<p><strong>NSLock：其实NSLock并没有想象中的那么差，不知道大家为什么不推荐使用；</strong></p>\n<p><strong>dispatch_semaphore_t：使用信号来做加锁，性能提升显著；</strong></p>\n<p><strong>NSCondition：使用其做多线程之间的通信调用不是线程安全的；</strong></p>\n<p><strong>NSConditionLock：单纯加锁性能非常低，比NSLock低很多，但是可以用来做多线程处理不同任务的通信调用；</strong></p>\n<p><strong>NSRecursiveLock：递归锁的性能出奇的高，但是只能作为递归使用,所以限制了使用场景；</strong></p>\n<p><strong>NSDistributedLock：因为是MAC开发的，就不讨论了；</strong></p>\n<p><strong>POSIX(pthread_mutex)：底层的api，复杂的多线程处理建议使用，并且可以封装自己的多线程；</strong></p>\n<p><strong>OSSpinLock：性能也非常高，可惜出现了线程问题；</strong></p>\n<p><strong>os_unfair_lock iOS10以后用于替代OSSpinLock的另外一种自旋锁，线程安全，性能相对于OSSpinLock大打折扣</strong></p>\n<p><strong>dispatch_barrier_async&#x2F;dispatch_barrier_sync：测试中发现dispatch_barrier_sync比dispatch_barrier_async性能要高，真是大出意外。</strong></p>"},{"title":"iOS Reveal2Loader修复版（iOS13修复）","date":"2020-09-14T07:20:00.000Z","top":0,"need_not_copyright":true,"banner_img":null,"_content":"\n今天同事说这个插件在iOS13越狱下失效了，所以就修复了在iOS13下无法窥探的bug，把RevealLoader库也更新到了24，附带[Reveal24下载地址](https://www.macwk.com/soft/reveal)。\n\n修复后的Reveal源地址：https://eziochiu.cn/cydia/\n\n~~随着iOS12 越狱的发布，又可以在iOS12的机器上随便搞事情了，但是今天突然发现安装bigBoss上的Reveal2Loader插件替换RevealLoader的库之后竟然无法窥探系统APP和第三方APP，然后在插间内部看到了作者的源码，于是心血来潮就进行了修改一番。~~\n\n<!-- more -->\n\n具体修改过程就不说了，[修改后的源码](https://github.com/eziochiu/Reveal2Loader-Fixed-or-iOS12),[作者源码](https://github.com/zidaneno5/Reveal2Loader)\n\n# 打包及安装方法\n\n1、cd 到工程目录reveal2Loader文件夹下 执行下列语句\n\n> find . -name .DS_Store -print0 | xargs -0 git rm -f --ignore-unmatch 删除当前目录的DS_Store隐藏文件\n>\n> sudo dpkg-deb -b Package reveal2Loader.deb (前提是必须安装dpkg，可以用brew安装也可以用macport安装)\n\n然后会在目录下生成reveal2Loader.deb\n\n2、将reveal2Loader.deb拷贝到手机\n\n3、将原来的reveal2Loader插件卸载，注销SpringBoard\n\n4、直接用filza找到该文件进行安装，前提是卸载之前的旧版本，否则会报错。\n\nenjoy！！！\n\n![样例](QQ20190225-124715@2x.png)\n\n![样例](QQ20190225-124731@2x.png)","source":"_posts/iOS Reveal2Loader修复版（iOS13修复）.md","raw":"---\ntitle: iOS Reveal2Loader修复版（iOS13修复）\ndate: 2020-09-14 15:20:00\ntags: [Reveal2Loader, 越狱插件]\ntop: 0\nneed_not_copyright: true\ncategories: 越狱插件\nbanner_img:\n---\n\n今天同事说这个插件在iOS13越狱下失效了，所以就修复了在iOS13下无法窥探的bug，把RevealLoader库也更新到了24，附带[Reveal24下载地址](https://www.macwk.com/soft/reveal)。\n\n修复后的Reveal源地址：https://eziochiu.cn/cydia/\n\n~~随着iOS12 越狱的发布，又可以在iOS12的机器上随便搞事情了，但是今天突然发现安装bigBoss上的Reveal2Loader插件替换RevealLoader的库之后竟然无法窥探系统APP和第三方APP，然后在插间内部看到了作者的源码，于是心血来潮就进行了修改一番。~~\n\n<!-- more -->\n\n具体修改过程就不说了，[修改后的源码](https://github.com/eziochiu/Reveal2Loader-Fixed-or-iOS12),[作者源码](https://github.com/zidaneno5/Reveal2Loader)\n\n# 打包及安装方法\n\n1、cd 到工程目录reveal2Loader文件夹下 执行下列语句\n\n> find . -name .DS_Store -print0 | xargs -0 git rm -f --ignore-unmatch 删除当前目录的DS_Store隐藏文件\n>\n> sudo dpkg-deb -b Package reveal2Loader.deb (前提是必须安装dpkg，可以用brew安装也可以用macport安装)\n\n然后会在目录下生成reveal2Loader.deb\n\n2、将reveal2Loader.deb拷贝到手机\n\n3、将原来的reveal2Loader插件卸载，注销SpringBoard\n\n4、直接用filza找到该文件进行安装，前提是卸载之前的旧版本，否则会报错。\n\nenjoy！！！\n\n![样例](QQ20190225-124715@2x.png)\n\n![样例](QQ20190225-124731@2x.png)","slug":"iOS Reveal2Loader修复版（iOS13修复）","published":1,"updated":"2023-07-21T09:50:08.170Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clkcgbp5b000bpfo7c1j6ezhc","content":"<p>今天同事说这个插件在iOS13越狱下失效了，所以就修复了在iOS13下无法窥探的bug，把RevealLoader库也更新到了24，附带<a href=\"https://www.macwk.com/soft/reveal\">Reveal24下载地址</a>。</p>\n<p>修复后的Reveal源地址：<a href=\"https://eziochiu.cn/cydia/\">https://eziochiu.cn/cydia/</a></p>\n<p><del>随着iOS12 越狱的发布，又可以在iOS12的机器上随便搞事情了，但是今天突然发现安装bigBoss上的Reveal2Loader插件替换RevealLoader的库之后竟然无法窥探系统APP和第三方APP，然后在插间内部看到了作者的源码，于是心血来潮就进行了修改一番。</del></p>\n<span id=\"more\"></span>\n\n<p>具体修改过程就不说了，<a href=\"https://github.com/eziochiu/Reveal2Loader-Fixed-or-iOS12\">修改后的源码</a>,<a href=\"https://github.com/zidaneno5/Reveal2Loader\">作者源码</a></p>\n<h1 id=\"打包及安装方法\"><a href=\"#打包及安装方法\" class=\"headerlink\" title=\"打包及安装方法\"></a>打包及安装方法</h1><p>1、cd 到工程目录reveal2Loader文件夹下 执行下列语句</p>\n<blockquote>\n<p>find . -name .DS_Store -print0 | xargs -0 git rm -f –ignore-unmatch 删除当前目录的DS_Store隐藏文件</p>\n<p>sudo dpkg-deb -b Package reveal2Loader.deb (前提是必须安装dpkg，可以用brew安装也可以用macport安装)</p>\n</blockquote>\n<p>然后会在目录下生成reveal2Loader.deb</p>\n<p>2、将reveal2Loader.deb拷贝到手机</p>\n<p>3、将原来的reveal2Loader插件卸载，注销SpringBoard</p>\n<p>4、直接用filza找到该文件进行安装，前提是卸载之前的旧版本，否则会报错。</p>\n<p>enjoy！！！</p>\n<p><img src=\"/2020/09/14/iOS%20Reveal2Loader%E4%BF%AE%E5%A4%8D%E7%89%88%EF%BC%88iOS13%E4%BF%AE%E5%A4%8D%EF%BC%89/QQ20190225-124715@2x.png\" alt=\"样例\"></p>\n<p><img src=\"/2020/09/14/iOS%20Reveal2Loader%E4%BF%AE%E5%A4%8D%E7%89%88%EF%BC%88iOS13%E4%BF%AE%E5%A4%8D%EF%BC%89/QQ20190225-124731@2x.png\" alt=\"样例\"></p>\n","site":{"data":{}},"length":600,"excerpt":"<p>今天同事说这个插件在iOS13越狱下失效了，所以就修复了在iOS13下无法窥探的bug，把RevealLoader库也更新到了24，附带<a href=\"https://www.macwk.com/soft/reveal\">Reveal24下载地址</a>。</p>\n<p>修复后的Reveal源地址：<a href=\"https://eziochiu.cn/cydia/\">https://eziochiu.cn/cydia/</a></p>\n<p><del>随着iOS12 越狱的发布，又可以在iOS12的机器上随便搞事情了，但是今天突然发现安装bigBoss上的Reveal2Loader插件替换RevealLoader的库之后竟然无法窥探系统APP和第三方APP，然后在插间内部看到了作者的源码，于是心血来潮就进行了修改一番。</del></p>","more":"<p>具体修改过程就不说了，<a href=\"https://github.com/eziochiu/Reveal2Loader-Fixed-or-iOS12\">修改后的源码</a>,<a href=\"https://github.com/zidaneno5/Reveal2Loader\">作者源码</a></p>\n<h1 id=\"打包及安装方法\"><a href=\"#打包及安装方法\" class=\"headerlink\" title=\"打包及安装方法\"></a>打包及安装方法</h1><p>1、cd 到工程目录reveal2Loader文件夹下 执行下列语句</p>\n<blockquote>\n<p>find . -name .DS_Store -print0 | xargs -0 git rm -f –ignore-unmatch 删除当前目录的DS_Store隐藏文件</p>\n<p>sudo dpkg-deb -b Package reveal2Loader.deb (前提是必须安装dpkg，可以用brew安装也可以用macport安装)</p>\n</blockquote>\n<p>然后会在目录下生成reveal2Loader.deb</p>\n<p>2、将reveal2Loader.deb拷贝到手机</p>\n<p>3、将原来的reveal2Loader插件卸载，注销SpringBoard</p>\n<p>4、直接用filza找到该文件进行安装，前提是卸载之前的旧版本，否则会报错。</p>\n<p>enjoy！！！</p>\n<p><img src=\"/2020/09/14/iOS%20Reveal2Loader%E4%BF%AE%E5%A4%8D%E7%89%88%EF%BC%88iOS13%E4%BF%AE%E5%A4%8D%EF%BC%89/QQ20190225-124715@2x.png\" alt=\"样例\"></p>\n<p><img src=\"/2020/09/14/iOS%20Reveal2Loader%E4%BF%AE%E5%A4%8D%E7%89%88%EF%BC%88iOS13%E4%BF%AE%E5%A4%8D%EF%BC%89/QQ20190225-124731@2x.png\" alt=\"样例\"></p>"},{"title":"iOS底层之Block","top":0,"need_not_copyright":true,"date":"2018-06-22T10:38:52.000Z","banner_img":null,"_content":"\n* 在此之前需要先了解一个概念 - 闭包（swift中叫闭包），在维基百科中，闭包的定义如下：\n\n```\n In programming languages, a closure is a function or reference to a function together with a referencing\n environment—a table storing a reference to each of the non-local variables (also called free variables \n or upvalues) of that function.\n```\n\n实际上就是一个指向函数的指针。而block实际上就是一个闭包。\n\n---\n\n<!-- more -->\n\n# block的数据结构\n\n* 在讲解block之前，我们先需要知道block的数据结构，鉴于苹果block和runtime的开源，block的源代码可以再\n  [libclosure](https://opensource.apple.com/tarballs/libclosure/)\n  找得到，大约在源码中的runtime.c的第44行可以找到如下定义：\n\n```\n#define BLOCK_DESCRIPTOR_1 1\nstruct Block_descriptor_1 {\n    uintptr_t reserved;\n    uintptr_t size;\n};\n```\n\n第64行中找到block的数据布局：\n\n```\nstruct Block_layout {\n    void *isa;\n    volatile int32_t flags; // contains ref count\n    int32_t reserved; \n    void (*invoke)(void *, ...);\n    struct Block_descriptor_1 *descriptor;\n    // imported variables\n};\n```\n\n根据runtime.c中的对象定义，凡是首地址为\\*isa的结构体指针，都认为是对象。然而在OC中，block其实也被默认定义为对象。\n\n通过上面的2附图其实我们可以知道，一个block实际上是由6部分组成：\n\n> 1、isa指针，所有对象都有一个isa指针，上面也讲到过了，它用于实现对象的一些相关的功能；  \n> 2、flags，用于按bit位表示的block的附加信息，后面讲block为什么要用copy的时候会讲到；  \n> 3、reserved，保留的变量；  \n> 4、invoke，函数指针，用于具体指向block内部实现的函数的调用地址；  \n> 5、descriptor，表示该block的附加描述信息；\n> 6、variables，捕获过来的变量，block之所以能够访问外部的局部变量，是因为将这些变量或者变量的地址拷贝到了这个block的结构体中\n\n写一个简单的例子：\n\n```\nvoid foo_(){\n    int i = 2;\n    NSNumber *num = @3;\n\n    long (^myBlock)(void) = ^long() {\n        return i * num.intValue;\n    };\n\n    long r = myBlock();\n}\n```\n\n在终端中用clang进行反编译会得到如下的代码\n\n```\nstruct __block_impl {\n    void *isa;\n    int Flags;\n    int Reserved;\n    void *FuncPtr;\n};\n\nstruct __foo_block_desc_0 {\n    size_t reserved;\n    size_t Block_size;\n    void (*copy)(struct __foo_block_impl_0*, struct __foo_block_impl_0*);\n    void (*dispose)(struct __foo_block_impl_0*);\n};\n\n//myBlock的数据结构定义\nstruct __foo_block_impl_0 {\n    struct __block_impl impl;\n    struct __foo_block_desc_0* Desc;\n    int i;\n    NSNumber *num;\n};\n\n//block数据的描述\nstatic struct __foo_block_desc_0 __foo_block_desc_0_DATA = {\n    0,\n    sizeof(struct __foo_block_impl_0),\n    __foo_block_copy_0,\n    __foo_block_dispose_0\n};\n\n//block中的方法\nstatic long __foo_block_func_0(struct __foo_block_impl_0 *__cself) {\n    int i = __cself->i; // bound by copy\n    NSNumber *num = __cself->num; // bound by copy\n    return i * num.intValue;\n}\n\nvoid foo(){\n    int i = 2;\n    NSNumber *num = @3;\n    struct __foo_block_impl_0 myBlockT;\n    struct __foo_block_impl_0 *myBlock = &myBlockT;\n    myBlock->impl.isa = &_NSConcreteStackBlock;\n    myBlock->impl.Flags = 570425344;\n    myBlock->impl.FuncPtr = __foo_block_func_0;\n    myBlock->Desc = &__foo_block_desc_0_DATA;\n    myBlock->i = i;\n    myBlock->num = num;\n    long r = myBlock->impl.FuncPtr(myBlock);\n}\n```\n\n> **编译器会根据block捕获的变量，生成具体的结构体定义。block内部的代码将会提取出来，成为一个单独的C函数，创建block时实际上会在实现方法中声明一个结构体（struct），并且初始化该结构体的成员变量。而在执行block时会去调用这个单独的C函数，并把该结构体的指针传递过去。**\n\n---\n\n# block定义的类型\n\n在libclosure的block.h（在data.c中也可以找得到）的源码中，我们可以找到block定义的类型：\n\n```\nvoid * _NSConcreteStackBlock[32] = { 0 };\nvoid * _NSConcreteMallocBlock[32] = { 0 };\nvoid * _NSConcreteAutoBlock[32] = { 0 };\nvoid * _NSConcreteFinalizingBlock[32] = { 0 };\nvoid * _NSConcreteGlobalBlock[32] = { 0 };\nvoid * _NSConcreteWeakBlockVariable[32] = { 0 };\n```\n\n在C语言中定义了6中block，然而在OC当中的block只有3种类型，即：\n\n* NSConcreteStackBlock 定义为栈上创建的block\n\n* NSConcreteMallocBlock 定义为堆上创建的block\n\n* NSConcreteGlobalBlock 作为全局变量的block\n\nPS：在最新的源码中_NSConcreteStackBlock和_NSConcreteGlobalBlock已经被废弃，取而代之的是是_NSConcreteAutoBlock,可能是由于ARC自动管理block内存的原因。\n\n## 全局的block\n\n前面已经提到过\n\n> **在编译器完成编译之后，block会将其内部的代码全部提取出来，形成一个单独的C语言函数，在创建block时实际上它就是在方法声实现中声明一个结构体，并初始化该结构体的成员变量。而在执行block时，会去调用这个单独的C语言函数，并把该结构体的指针传递过去**\n\n于是全局的block就由此而生，其效果就相当于C语言中的匿名函数，因为全局的block是当一个block内部没有捕获任何外部变量时，就会使一个全局的block类型，此时，他就是一个函数，所以他也具备函数的一些特性，当调用block是后面会加上小括号：block()。\n\n那么既然全局的block具有函数的特性，就不必在考虑其生命周期（函数是一执行完就被释放）\n\n---\n\n## 栈中的block\n\n这个block其实是在编译器发现block内部调用或者说引用了外部的一些变量之后才生成的block。\n\n> **在block内部有引用外部变量是，当block内部的结构体第一次被创建时，它会存在与该函数的函数调用栈中，其捕获的变量是会赋值到结构体的成员变量中的，所以当block完成初始化之后是不能更改其内部变量的，所以就知道为什么需要改变block内部的变量需要用到 __block了。**\n\n> **当函数调用结束或者返回时，函数的调用栈就会被销毁，这时block的内存也会被销毁，所以如果后续仍然需要使用这个block的时候，就必须将block以Block_Copy()的方法拷贝到堆上。也就是直接在堆上面申请内存，将block复制过去，最后在捕获到的对象发送retain，增加block的引用计数，保证block在堆上不被释放掉。**\n\n举个例子：\n\n```\n#include <stdio.h>\n\nint main() {\n    int a = 100;\n    void (^block2)(void) = ^{\n        printf(\"%d\\n\", a);\n    };\n    block2();\n    return 0;\n}\n```\n\n让clang反编译重写之后：\n\n```\nstruct __main_block_impl_0 {\n    struct __block_impl impl;\n    struct __main_block_desc_0* Desc;\n    int a;\n    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _a, int flags=0) : a(_a) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n    int a = __cself->a; // bound by copy\n    printf(\"%d\\n\", a);\n}\nstatic struct __main_block_desc_0 {\n    size_t reserved;\n    size_t Block_size;\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};\nint main()\n{\n    int a = 100;\n    void (*block2)(void) = (void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, a);\n    ((void (*)(__block_impl *))((__block_impl *)block2)->FuncPtr)((__block_impl *)block2);\n    return 0;\n}\n```\n\n---\n\n## 堆中的block\n\n> **在栈中的block提到过，当函数调用结束，函数的调用栈会被销毁，那么栈中的block也会被销毁，但是我们一般都需要在函数结束之后任然使用这个block，所以就需要把栈中的block拷贝到堆上，在copy的同时，栈上的block的类型就转换成了堆上的block。**\n\n> **所以，在MRC时代，block的属性关键字必须是copy。这样就能保证再给block的属性复制的时候，能把栈上的block复制到堆上。**\n\n---\n\n# ARC时代的block之循环引用\n\n在开启ARC后，block的内存会比较微妙。ARC会自动处理block的内存，不用手动copy/release。\n\n但是，和非ARC的情况有所不同：\n\n```\nvoid (^aBlock)(void);\naBlock = ^{ \n\tprintf(\"ok\"); \n};\n```\n\nblock是对象，所以aBlock默认是有\\_\\_strong修饰符的，即aBlock对该block有strong references。即aBlock在被赋值的那一刻，这个block会被copy。所以，ARC开启后，所能接触到的block基本都是在堆上的。。\n\n当block被copy之后\\(如开启了ARC、或把block放入dispatch queue\\)，该block对它捕获的对象产生strong references \\(非ARC下是retain\\)，所以有时需要避免block copy后产生的循环引用。\n\n如果用self引用了block，block又捕获了self，这样就会有循环引用。  \n因此，需要用weak来声明self\n\n```\n- (void)configureBlock {\n    XYZBlockKeeper * __weak weakSelf = self;\n    self.block = ^{\n        [weakSelf doSomething]; //捕获到的是弱引用\n    }\n}\n```\n\n如果捕获到的是当前对象的成员变量对象，同样也会造成对self的引用，同样也要避免。\n\n```\n- (void)configureBlock {\n    id tmpIvar = _ivar; //临时变量,避免了self引用\n    self.block = ^{\n        [tmpIvar msg];\n    }\n}\n```\n\n为了避免循环引用，可以这样理解block：block就是一个对象，它捕获到的值就是这个对象的@property (strong)。\n\n\n","source":"_posts/iOS底层之Block.md","raw":"---\ntitle: iOS底层之Block\ntags: [Block, 底层原理]\ntop: 0\nneed_not_copyright: true\ndate: 2018-06-22 18:38:52\ncategories: 底层原理\nbanner_img:\n---\n\n* 在此之前需要先了解一个概念 - 闭包（swift中叫闭包），在维基百科中，闭包的定义如下：\n\n```\n In programming languages, a closure is a function or reference to a function together with a referencing\n environment—a table storing a reference to each of the non-local variables (also called free variables \n or upvalues) of that function.\n```\n\n实际上就是一个指向函数的指针。而block实际上就是一个闭包。\n\n---\n\n<!-- more -->\n\n# block的数据结构\n\n* 在讲解block之前，我们先需要知道block的数据结构，鉴于苹果block和runtime的开源，block的源代码可以再\n  [libclosure](https://opensource.apple.com/tarballs/libclosure/)\n  找得到，大约在源码中的runtime.c的第44行可以找到如下定义：\n\n```\n#define BLOCK_DESCRIPTOR_1 1\nstruct Block_descriptor_1 {\n    uintptr_t reserved;\n    uintptr_t size;\n};\n```\n\n第64行中找到block的数据布局：\n\n```\nstruct Block_layout {\n    void *isa;\n    volatile int32_t flags; // contains ref count\n    int32_t reserved; \n    void (*invoke)(void *, ...);\n    struct Block_descriptor_1 *descriptor;\n    // imported variables\n};\n```\n\n根据runtime.c中的对象定义，凡是首地址为\\*isa的结构体指针，都认为是对象。然而在OC中，block其实也被默认定义为对象。\n\n通过上面的2附图其实我们可以知道，一个block实际上是由6部分组成：\n\n> 1、isa指针，所有对象都有一个isa指针，上面也讲到过了，它用于实现对象的一些相关的功能；  \n> 2、flags，用于按bit位表示的block的附加信息，后面讲block为什么要用copy的时候会讲到；  \n> 3、reserved，保留的变量；  \n> 4、invoke，函数指针，用于具体指向block内部实现的函数的调用地址；  \n> 5、descriptor，表示该block的附加描述信息；\n> 6、variables，捕获过来的变量，block之所以能够访问外部的局部变量，是因为将这些变量或者变量的地址拷贝到了这个block的结构体中\n\n写一个简单的例子：\n\n```\nvoid foo_(){\n    int i = 2;\n    NSNumber *num = @3;\n\n    long (^myBlock)(void) = ^long() {\n        return i * num.intValue;\n    };\n\n    long r = myBlock();\n}\n```\n\n在终端中用clang进行反编译会得到如下的代码\n\n```\nstruct __block_impl {\n    void *isa;\n    int Flags;\n    int Reserved;\n    void *FuncPtr;\n};\n\nstruct __foo_block_desc_0 {\n    size_t reserved;\n    size_t Block_size;\n    void (*copy)(struct __foo_block_impl_0*, struct __foo_block_impl_0*);\n    void (*dispose)(struct __foo_block_impl_0*);\n};\n\n//myBlock的数据结构定义\nstruct __foo_block_impl_0 {\n    struct __block_impl impl;\n    struct __foo_block_desc_0* Desc;\n    int i;\n    NSNumber *num;\n};\n\n//block数据的描述\nstatic struct __foo_block_desc_0 __foo_block_desc_0_DATA = {\n    0,\n    sizeof(struct __foo_block_impl_0),\n    __foo_block_copy_0,\n    __foo_block_dispose_0\n};\n\n//block中的方法\nstatic long __foo_block_func_0(struct __foo_block_impl_0 *__cself) {\n    int i = __cself->i; // bound by copy\n    NSNumber *num = __cself->num; // bound by copy\n    return i * num.intValue;\n}\n\nvoid foo(){\n    int i = 2;\n    NSNumber *num = @3;\n    struct __foo_block_impl_0 myBlockT;\n    struct __foo_block_impl_0 *myBlock = &myBlockT;\n    myBlock->impl.isa = &_NSConcreteStackBlock;\n    myBlock->impl.Flags = 570425344;\n    myBlock->impl.FuncPtr = __foo_block_func_0;\n    myBlock->Desc = &__foo_block_desc_0_DATA;\n    myBlock->i = i;\n    myBlock->num = num;\n    long r = myBlock->impl.FuncPtr(myBlock);\n}\n```\n\n> **编译器会根据block捕获的变量，生成具体的结构体定义。block内部的代码将会提取出来，成为一个单独的C函数，创建block时实际上会在实现方法中声明一个结构体（struct），并且初始化该结构体的成员变量。而在执行block时会去调用这个单独的C函数，并把该结构体的指针传递过去。**\n\n---\n\n# block定义的类型\n\n在libclosure的block.h（在data.c中也可以找得到）的源码中，我们可以找到block定义的类型：\n\n```\nvoid * _NSConcreteStackBlock[32] = { 0 };\nvoid * _NSConcreteMallocBlock[32] = { 0 };\nvoid * _NSConcreteAutoBlock[32] = { 0 };\nvoid * _NSConcreteFinalizingBlock[32] = { 0 };\nvoid * _NSConcreteGlobalBlock[32] = { 0 };\nvoid * _NSConcreteWeakBlockVariable[32] = { 0 };\n```\n\n在C语言中定义了6中block，然而在OC当中的block只有3种类型，即：\n\n* NSConcreteStackBlock 定义为栈上创建的block\n\n* NSConcreteMallocBlock 定义为堆上创建的block\n\n* NSConcreteGlobalBlock 作为全局变量的block\n\nPS：在最新的源码中_NSConcreteStackBlock和_NSConcreteGlobalBlock已经被废弃，取而代之的是是_NSConcreteAutoBlock,可能是由于ARC自动管理block内存的原因。\n\n## 全局的block\n\n前面已经提到过\n\n> **在编译器完成编译之后，block会将其内部的代码全部提取出来，形成一个单独的C语言函数，在创建block时实际上它就是在方法声实现中声明一个结构体，并初始化该结构体的成员变量。而在执行block时，会去调用这个单独的C语言函数，并把该结构体的指针传递过去**\n\n于是全局的block就由此而生，其效果就相当于C语言中的匿名函数，因为全局的block是当一个block内部没有捕获任何外部变量时，就会使一个全局的block类型，此时，他就是一个函数，所以他也具备函数的一些特性，当调用block是后面会加上小括号：block()。\n\n那么既然全局的block具有函数的特性，就不必在考虑其生命周期（函数是一执行完就被释放）\n\n---\n\n## 栈中的block\n\n这个block其实是在编译器发现block内部调用或者说引用了外部的一些变量之后才生成的block。\n\n> **在block内部有引用外部变量是，当block内部的结构体第一次被创建时，它会存在与该函数的函数调用栈中，其捕获的变量是会赋值到结构体的成员变量中的，所以当block完成初始化之后是不能更改其内部变量的，所以就知道为什么需要改变block内部的变量需要用到 __block了。**\n\n> **当函数调用结束或者返回时，函数的调用栈就会被销毁，这时block的内存也会被销毁，所以如果后续仍然需要使用这个block的时候，就必须将block以Block_Copy()的方法拷贝到堆上。也就是直接在堆上面申请内存，将block复制过去，最后在捕获到的对象发送retain，增加block的引用计数，保证block在堆上不被释放掉。**\n\n举个例子：\n\n```\n#include <stdio.h>\n\nint main() {\n    int a = 100;\n    void (^block2)(void) = ^{\n        printf(\"%d\\n\", a);\n    };\n    block2();\n    return 0;\n}\n```\n\n让clang反编译重写之后：\n\n```\nstruct __main_block_impl_0 {\n    struct __block_impl impl;\n    struct __main_block_desc_0* Desc;\n    int a;\n    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _a, int flags=0) : a(_a) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n    int a = __cself->a; // bound by copy\n    printf(\"%d\\n\", a);\n}\nstatic struct __main_block_desc_0 {\n    size_t reserved;\n    size_t Block_size;\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};\nint main()\n{\n    int a = 100;\n    void (*block2)(void) = (void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, a);\n    ((void (*)(__block_impl *))((__block_impl *)block2)->FuncPtr)((__block_impl *)block2);\n    return 0;\n}\n```\n\n---\n\n## 堆中的block\n\n> **在栈中的block提到过，当函数调用结束，函数的调用栈会被销毁，那么栈中的block也会被销毁，但是我们一般都需要在函数结束之后任然使用这个block，所以就需要把栈中的block拷贝到堆上，在copy的同时，栈上的block的类型就转换成了堆上的block。**\n\n> **所以，在MRC时代，block的属性关键字必须是copy。这样就能保证再给block的属性复制的时候，能把栈上的block复制到堆上。**\n\n---\n\n# ARC时代的block之循环引用\n\n在开启ARC后，block的内存会比较微妙。ARC会自动处理block的内存，不用手动copy/release。\n\n但是，和非ARC的情况有所不同：\n\n```\nvoid (^aBlock)(void);\naBlock = ^{ \n\tprintf(\"ok\"); \n};\n```\n\nblock是对象，所以aBlock默认是有\\_\\_strong修饰符的，即aBlock对该block有strong references。即aBlock在被赋值的那一刻，这个block会被copy。所以，ARC开启后，所能接触到的block基本都是在堆上的。。\n\n当block被copy之后\\(如开启了ARC、或把block放入dispatch queue\\)，该block对它捕获的对象产生strong references \\(非ARC下是retain\\)，所以有时需要避免block copy后产生的循环引用。\n\n如果用self引用了block，block又捕获了self，这样就会有循环引用。  \n因此，需要用weak来声明self\n\n```\n- (void)configureBlock {\n    XYZBlockKeeper * __weak weakSelf = self;\n    self.block = ^{\n        [weakSelf doSomething]; //捕获到的是弱引用\n    }\n}\n```\n\n如果捕获到的是当前对象的成员变量对象，同样也会造成对self的引用，同样也要避免。\n\n```\n- (void)configureBlock {\n    id tmpIvar = _ivar; //临时变量,避免了self引用\n    self.block = ^{\n        [tmpIvar msg];\n    }\n}\n```\n\n为了避免循环引用，可以这样理解block：block就是一个对象，它捕获到的值就是这个对象的@property (strong)。\n\n\n","slug":"iOS底层之Block","published":1,"updated":"2023-07-21T09:10:33.574Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clkcgbp5h0016pfo799llcj2k","content":"<ul>\n<li>在此之前需要先了解一个概念 - 闭包（swift中叫闭包），在维基百科中，闭包的定义如下：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In programming languages, a closure is a function or reference to a function together with a referencing</span><br><span class=\"line\">environment—a table storing a reference to each of the non-local variables (also called free variables </span><br><span class=\"line\">or upvalues) of that function.</span><br></pre></td></tr></table></figure>\n\n<p>实际上就是一个指向函数的指针。而block实际上就是一个闭包。</p>\n<hr>\n<span id=\"more\"></span>\n\n<h1 id=\"block的数据结构\"><a href=\"#block的数据结构\" class=\"headerlink\" title=\"block的数据结构\"></a>block的数据结构</h1><ul>\n<li>在讲解block之前，我们先需要知道block的数据结构，鉴于苹果block和runtime的开源，block的源代码可以再<br><a href=\"https://opensource.apple.com/tarballs/libclosure/\">libclosure</a><br>找得到，大约在源码中的runtime.c的第44行可以找到如下定义：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define BLOCK_DESCRIPTOR_1 1</span><br><span class=\"line\">struct Block_descriptor_1 &#123;</span><br><span class=\"line\">    uintptr_t reserved;</span><br><span class=\"line\">    uintptr_t size;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>第64行中找到block的数据布局：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Block_layout &#123;</span><br><span class=\"line\">    void *isa;</span><br><span class=\"line\">    volatile int32_t flags; // contains ref count</span><br><span class=\"line\">    int32_t reserved; </span><br><span class=\"line\">    void (*invoke)(void *, ...);</span><br><span class=\"line\">    struct Block_descriptor_1 *descriptor;</span><br><span class=\"line\">    // imported variables</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>根据runtime.c中的对象定义，凡是首地址为*isa的结构体指针，都认为是对象。然而在OC中，block其实也被默认定义为对象。</p>\n<p>通过上面的2附图其实我们可以知道，一个block实际上是由6部分组成：</p>\n<blockquote>\n<p>1、isa指针，所有对象都有一个isa指针，上面也讲到过了，它用于实现对象的一些相关的功能；<br>2、flags，用于按bit位表示的block的附加信息，后面讲block为什么要用copy的时候会讲到；<br>3、reserved，保留的变量；<br>4、invoke，函数指针，用于具体指向block内部实现的函数的调用地址；<br>5、descriptor，表示该block的附加描述信息；<br>6、variables，捕获过来的变量，block之所以能够访问外部的局部变量，是因为将这些变量或者变量的地址拷贝到了这个block的结构体中</p>\n</blockquote>\n<p>写一个简单的例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void foo_()&#123;</span><br><span class=\"line\">    int i = 2;</span><br><span class=\"line\">    NSNumber *num = @3;</span><br><span class=\"line\"></span><br><span class=\"line\">    long (^myBlock)(void) = ^long() &#123;</span><br><span class=\"line\">        return i * num.intValue;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    long r = myBlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在终端中用clang进行反编译会得到如下的代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct __block_impl &#123;</span><br><span class=\"line\">    void *isa;</span><br><span class=\"line\">    int Flags;</span><br><span class=\"line\">    int Reserved;</span><br><span class=\"line\">    void *FuncPtr;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">struct __foo_block_desc_0 &#123;</span><br><span class=\"line\">    size_t reserved;</span><br><span class=\"line\">    size_t Block_size;</span><br><span class=\"line\">    void (*copy)(struct __foo_block_impl_0*, struct __foo_block_impl_0*);</span><br><span class=\"line\">    void (*dispose)(struct __foo_block_impl_0*);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">//myBlock的数据结构定义</span><br><span class=\"line\">struct __foo_block_impl_0 &#123;</span><br><span class=\"line\">    struct __block_impl impl;</span><br><span class=\"line\">    struct __foo_block_desc_0* Desc;</span><br><span class=\"line\">    int i;</span><br><span class=\"line\">    NSNumber *num;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">//block数据的描述</span><br><span class=\"line\">static struct __foo_block_desc_0 __foo_block_desc_0_DATA = &#123;</span><br><span class=\"line\">    0,</span><br><span class=\"line\">    sizeof(struct __foo_block_impl_0),</span><br><span class=\"line\">    __foo_block_copy_0,</span><br><span class=\"line\">    __foo_block_dispose_0</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">//block中的方法</span><br><span class=\"line\">static long __foo_block_func_0(struct __foo_block_impl_0 *__cself) &#123;</span><br><span class=\"line\">    int i = __cself-&gt;i; // bound by copy</span><br><span class=\"line\">    NSNumber *num = __cself-&gt;num; // bound by copy</span><br><span class=\"line\">    return i * num.intValue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void foo()&#123;</span><br><span class=\"line\">    int i = 2;</span><br><span class=\"line\">    NSNumber *num = @3;</span><br><span class=\"line\">    struct __foo_block_impl_0 myBlockT;</span><br><span class=\"line\">    struct __foo_block_impl_0 *myBlock = &amp;myBlockT;</span><br><span class=\"line\">    myBlock-&gt;impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class=\"line\">    myBlock-&gt;impl.Flags = 570425344;</span><br><span class=\"line\">    myBlock-&gt;impl.FuncPtr = __foo_block_func_0;</span><br><span class=\"line\">    myBlock-&gt;Desc = &amp;__foo_block_desc_0_DATA;</span><br><span class=\"line\">    myBlock-&gt;i = i;</span><br><span class=\"line\">    myBlock-&gt;num = num;</span><br><span class=\"line\">    long r = myBlock-&gt;impl.FuncPtr(myBlock);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>编译器会根据block捕获的变量，生成具体的结构体定义。block内部的代码将会提取出来，成为一个单独的C函数，创建block时实际上会在实现方法中声明一个结构体（struct），并且初始化该结构体的成员变量。而在执行block时会去调用这个单独的C函数，并把该结构体的指针传递过去。</strong></p>\n</blockquote>\n<hr>\n<h1 id=\"block定义的类型\"><a href=\"#block定义的类型\" class=\"headerlink\" title=\"block定义的类型\"></a>block定义的类型</h1><p>在libclosure的block.h（在data.c中也可以找得到）的源码中，我们可以找到block定义的类型：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void * _NSConcreteStackBlock[32] = &#123; 0 &#125;;</span><br><span class=\"line\">void * _NSConcreteMallocBlock[32] = &#123; 0 &#125;;</span><br><span class=\"line\">void * _NSConcreteAutoBlock[32] = &#123; 0 &#125;;</span><br><span class=\"line\">void * _NSConcreteFinalizingBlock[32] = &#123; 0 &#125;;</span><br><span class=\"line\">void * _NSConcreteGlobalBlock[32] = &#123; 0 &#125;;</span><br><span class=\"line\">void * _NSConcreteWeakBlockVariable[32] = &#123; 0 &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在C语言中定义了6中block，然而在OC当中的block只有3种类型，即：</p>\n<ul>\n<li><p>NSConcreteStackBlock 定义为栈上创建的block</p>\n</li>\n<li><p>NSConcreteMallocBlock 定义为堆上创建的block</p>\n</li>\n<li><p>NSConcreteGlobalBlock 作为全局变量的block</p>\n</li>\n</ul>\n<p>PS：在最新的源码中_NSConcreteStackBlock和_NSConcreteGlobalBlock已经被废弃，取而代之的是是_NSConcreteAutoBlock,可能是由于ARC自动管理block内存的原因。</p>\n<h2 id=\"全局的block\"><a href=\"#全局的block\" class=\"headerlink\" title=\"全局的block\"></a>全局的block</h2><p>前面已经提到过</p>\n<blockquote>\n<p><strong>在编译器完成编译之后，block会将其内部的代码全部提取出来，形成一个单独的C语言函数，在创建block时实际上它就是在方法声实现中声明一个结构体，并初始化该结构体的成员变量。而在执行block时，会去调用这个单独的C语言函数，并把该结构体的指针传递过去</strong></p>\n</blockquote>\n<p>于是全局的block就由此而生，其效果就相当于C语言中的匿名函数，因为全局的block是当一个block内部没有捕获任何外部变量时，就会使一个全局的block类型，此时，他就是一个函数，所以他也具备函数的一些特性，当调用block是后面会加上小括号：block()。</p>\n<p>那么既然全局的block具有函数的特性，就不必在考虑其生命周期（函数是一执行完就被释放）</p>\n<hr>\n<h2 id=\"栈中的block\"><a href=\"#栈中的block\" class=\"headerlink\" title=\"栈中的block\"></a>栈中的block</h2><p>这个block其实是在编译器发现block内部调用或者说引用了外部的一些变量之后才生成的block。</p>\n<blockquote>\n<p><strong>在block内部有引用外部变量是，当block内部的结构体第一次被创建时，它会存在与该函数的函数调用栈中，其捕获的变量是会赋值到结构体的成员变量中的，所以当block完成初始化之后是不能更改其内部变量的，所以就知道为什么需要改变block内部的变量需要用到 __block了。</strong></p>\n</blockquote>\n<blockquote>\n<p><strong>当函数调用结束或者返回时，函数的调用栈就会被销毁，这时block的内存也会被销毁，所以如果后续仍然需要使用这个block的时候，就必须将block以Block_Copy()的方法拷贝到堆上。也就是直接在堆上面申请内存，将block复制过去，最后在捕获到的对象发送retain，增加block的引用计数，保证block在堆上不被释放掉。</strong></p>\n</blockquote>\n<p>举个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    int a = 100;</span><br><span class=\"line\">    void (^block2)(void) = ^&#123;</span><br><span class=\"line\">        printf(&quot;%d\\n&quot;, a);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    block2();</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>让clang反编译重写之后：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct __main_block_impl_0 &#123;</span><br><span class=\"line\">    struct __block_impl impl;</span><br><span class=\"line\">    struct __main_block_desc_0* Desc;</span><br><span class=\"line\">    int a;</span><br><span class=\"line\">    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _a, int flags=0) : a(_a) &#123;</span><br><span class=\"line\">        impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class=\"line\">        impl.Flags = flags;</span><br><span class=\"line\">        impl.FuncPtr = fp;</span><br><span class=\"line\">        Desc = desc;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class=\"line\">    int a = __cself-&gt;a; // bound by copy</span><br><span class=\"line\">    printf(&quot;%d\\n&quot;, a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">static struct __main_block_desc_0 &#123;</span><br><span class=\"line\">    size_t reserved;</span><br><span class=\"line\">    size_t Block_size;</span><br><span class=\"line\">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int a = 100;</span><br><span class=\"line\">    void (*block2)(void) = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a);</span><br><span class=\"line\">    ((void (*)(__block_impl *))((__block_impl *)block2)-&gt;FuncPtr)((__block_impl *)block2);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"堆中的block\"><a href=\"#堆中的block\" class=\"headerlink\" title=\"堆中的block\"></a>堆中的block</h2><blockquote>\n<p><strong>在栈中的block提到过，当函数调用结束，函数的调用栈会被销毁，那么栈中的block也会被销毁，但是我们一般都需要在函数结束之后任然使用这个block，所以就需要把栈中的block拷贝到堆上，在copy的同时，栈上的block的类型就转换成了堆上的block。</strong></p>\n</blockquote>\n<blockquote>\n<p><strong>所以，在MRC时代，block的属性关键字必须是copy。这样就能保证再给block的属性复制的时候，能把栈上的block复制到堆上。</strong></p>\n</blockquote>\n<hr>\n<h1 id=\"ARC时代的block之循环引用\"><a href=\"#ARC时代的block之循环引用\" class=\"headerlink\" title=\"ARC时代的block之循环引用\"></a>ARC时代的block之循环引用</h1><p>在开启ARC后，block的内存会比较微妙。ARC会自动处理block的内存，不用手动copy&#x2F;release。</p>\n<p>但是，和非ARC的情况有所不同：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void (^aBlock)(void);</span><br><span class=\"line\">aBlock = ^&#123; </span><br><span class=\"line\">\tprintf(&quot;ok&quot;); </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>block是对象，所以aBlock默认是有__strong修饰符的，即aBlock对该block有strong references。即aBlock在被赋值的那一刻，这个block会被copy。所以，ARC开启后，所能接触到的block基本都是在堆上的。。</p>\n<p>当block被copy之后(如开启了ARC、或把block放入dispatch queue)，该block对它捕获的对象产生strong references (非ARC下是retain)，所以有时需要避免block copy后产生的循环引用。</p>\n<p>如果用self引用了block，block又捕获了self，这样就会有循环引用。<br>因此，需要用weak来声明self</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)configureBlock &#123;</span><br><span class=\"line\">    XYZBlockKeeper * __weak weakSelf = self;</span><br><span class=\"line\">    self.block = ^&#123;</span><br><span class=\"line\">        [weakSelf doSomething]; //捕获到的是弱引用</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果捕获到的是当前对象的成员变量对象，同样也会造成对self的引用，同样也要避免。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)configureBlock &#123;</span><br><span class=\"line\">    id tmpIvar = _ivar; //临时变量,避免了self引用</span><br><span class=\"line\">    self.block = ^&#123;</span><br><span class=\"line\">        [tmpIvar msg];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了避免循环引用，可以这样理解block：block就是一个对象，它捕获到的值就是这个对象的@property (strong)。</p>\n","site":{"data":{}},"length":5822,"excerpt":"<ul>\n<li>在此之前需要先了解一个概念 - 闭包（swift中叫闭包），在维基百科中，闭包的定义如下：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In programming languages, a closure is a function or reference to a function together with a referencing</span><br><span class=\"line\">environment—a table storing a reference to each of the non-local variables (also called free variables </span><br><span class=\"line\">or upvalues) of that function.</span><br></pre></td></tr></table></figure>\n\n<p>实际上就是一个指向函数的指针。而block实际上就是一个闭包。</p>\n<hr>","more":"<h1 id=\"block的数据结构\"><a href=\"#block的数据结构\" class=\"headerlink\" title=\"block的数据结构\"></a>block的数据结构</h1><ul>\n<li>在讲解block之前，我们先需要知道block的数据结构，鉴于苹果block和runtime的开源，block的源代码可以再<br><a href=\"https://opensource.apple.com/tarballs/libclosure/\">libclosure</a><br>找得到，大约在源码中的runtime.c的第44行可以找到如下定义：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define BLOCK_DESCRIPTOR_1 1</span><br><span class=\"line\">struct Block_descriptor_1 &#123;</span><br><span class=\"line\">    uintptr_t reserved;</span><br><span class=\"line\">    uintptr_t size;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>第64行中找到block的数据布局：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Block_layout &#123;</span><br><span class=\"line\">    void *isa;</span><br><span class=\"line\">    volatile int32_t flags; // contains ref count</span><br><span class=\"line\">    int32_t reserved; </span><br><span class=\"line\">    void (*invoke)(void *, ...);</span><br><span class=\"line\">    struct Block_descriptor_1 *descriptor;</span><br><span class=\"line\">    // imported variables</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>根据runtime.c中的对象定义，凡是首地址为*isa的结构体指针，都认为是对象。然而在OC中，block其实也被默认定义为对象。</p>\n<p>通过上面的2附图其实我们可以知道，一个block实际上是由6部分组成：</p>\n<blockquote>\n<p>1、isa指针，所有对象都有一个isa指针，上面也讲到过了，它用于实现对象的一些相关的功能；<br>2、flags，用于按bit位表示的block的附加信息，后面讲block为什么要用copy的时候会讲到；<br>3、reserved，保留的变量；<br>4、invoke，函数指针，用于具体指向block内部实现的函数的调用地址；<br>5、descriptor，表示该block的附加描述信息；<br>6、variables，捕获过来的变量，block之所以能够访问外部的局部变量，是因为将这些变量或者变量的地址拷贝到了这个block的结构体中</p>\n</blockquote>\n<p>写一个简单的例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void foo_()&#123;</span><br><span class=\"line\">    int i = 2;</span><br><span class=\"line\">    NSNumber *num = @3;</span><br><span class=\"line\"></span><br><span class=\"line\">    long (^myBlock)(void) = ^long() &#123;</span><br><span class=\"line\">        return i * num.intValue;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    long r = myBlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在终端中用clang进行反编译会得到如下的代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct __block_impl &#123;</span><br><span class=\"line\">    void *isa;</span><br><span class=\"line\">    int Flags;</span><br><span class=\"line\">    int Reserved;</span><br><span class=\"line\">    void *FuncPtr;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">struct __foo_block_desc_0 &#123;</span><br><span class=\"line\">    size_t reserved;</span><br><span class=\"line\">    size_t Block_size;</span><br><span class=\"line\">    void (*copy)(struct __foo_block_impl_0*, struct __foo_block_impl_0*);</span><br><span class=\"line\">    void (*dispose)(struct __foo_block_impl_0*);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">//myBlock的数据结构定义</span><br><span class=\"line\">struct __foo_block_impl_0 &#123;</span><br><span class=\"line\">    struct __block_impl impl;</span><br><span class=\"line\">    struct __foo_block_desc_0* Desc;</span><br><span class=\"line\">    int i;</span><br><span class=\"line\">    NSNumber *num;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">//block数据的描述</span><br><span class=\"line\">static struct __foo_block_desc_0 __foo_block_desc_0_DATA = &#123;</span><br><span class=\"line\">    0,</span><br><span class=\"line\">    sizeof(struct __foo_block_impl_0),</span><br><span class=\"line\">    __foo_block_copy_0,</span><br><span class=\"line\">    __foo_block_dispose_0</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">//block中的方法</span><br><span class=\"line\">static long __foo_block_func_0(struct __foo_block_impl_0 *__cself) &#123;</span><br><span class=\"line\">    int i = __cself-&gt;i; // bound by copy</span><br><span class=\"line\">    NSNumber *num = __cself-&gt;num; // bound by copy</span><br><span class=\"line\">    return i * num.intValue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void foo()&#123;</span><br><span class=\"line\">    int i = 2;</span><br><span class=\"line\">    NSNumber *num = @3;</span><br><span class=\"line\">    struct __foo_block_impl_0 myBlockT;</span><br><span class=\"line\">    struct __foo_block_impl_0 *myBlock = &amp;myBlockT;</span><br><span class=\"line\">    myBlock-&gt;impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class=\"line\">    myBlock-&gt;impl.Flags = 570425344;</span><br><span class=\"line\">    myBlock-&gt;impl.FuncPtr = __foo_block_func_0;</span><br><span class=\"line\">    myBlock-&gt;Desc = &amp;__foo_block_desc_0_DATA;</span><br><span class=\"line\">    myBlock-&gt;i = i;</span><br><span class=\"line\">    myBlock-&gt;num = num;</span><br><span class=\"line\">    long r = myBlock-&gt;impl.FuncPtr(myBlock);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>编译器会根据block捕获的变量，生成具体的结构体定义。block内部的代码将会提取出来，成为一个单独的C函数，创建block时实际上会在实现方法中声明一个结构体（struct），并且初始化该结构体的成员变量。而在执行block时会去调用这个单独的C函数，并把该结构体的指针传递过去。</strong></p>\n</blockquote>\n<hr>\n<h1 id=\"block定义的类型\"><a href=\"#block定义的类型\" class=\"headerlink\" title=\"block定义的类型\"></a>block定义的类型</h1><p>在libclosure的block.h（在data.c中也可以找得到）的源码中，我们可以找到block定义的类型：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void * _NSConcreteStackBlock[32] = &#123; 0 &#125;;</span><br><span class=\"line\">void * _NSConcreteMallocBlock[32] = &#123; 0 &#125;;</span><br><span class=\"line\">void * _NSConcreteAutoBlock[32] = &#123; 0 &#125;;</span><br><span class=\"line\">void * _NSConcreteFinalizingBlock[32] = &#123; 0 &#125;;</span><br><span class=\"line\">void * _NSConcreteGlobalBlock[32] = &#123; 0 &#125;;</span><br><span class=\"line\">void * _NSConcreteWeakBlockVariable[32] = &#123; 0 &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在C语言中定义了6中block，然而在OC当中的block只有3种类型，即：</p>\n<ul>\n<li><p>NSConcreteStackBlock 定义为栈上创建的block</p>\n</li>\n<li><p>NSConcreteMallocBlock 定义为堆上创建的block</p>\n</li>\n<li><p>NSConcreteGlobalBlock 作为全局变量的block</p>\n</li>\n</ul>\n<p>PS：在最新的源码中_NSConcreteStackBlock和_NSConcreteGlobalBlock已经被废弃，取而代之的是是_NSConcreteAutoBlock,可能是由于ARC自动管理block内存的原因。</p>\n<h2 id=\"全局的block\"><a href=\"#全局的block\" class=\"headerlink\" title=\"全局的block\"></a>全局的block</h2><p>前面已经提到过</p>\n<blockquote>\n<p><strong>在编译器完成编译之后，block会将其内部的代码全部提取出来，形成一个单独的C语言函数，在创建block时实际上它就是在方法声实现中声明一个结构体，并初始化该结构体的成员变量。而在执行block时，会去调用这个单独的C语言函数，并把该结构体的指针传递过去</strong></p>\n</blockquote>\n<p>于是全局的block就由此而生，其效果就相当于C语言中的匿名函数，因为全局的block是当一个block内部没有捕获任何外部变量时，就会使一个全局的block类型，此时，他就是一个函数，所以他也具备函数的一些特性，当调用block是后面会加上小括号：block()。</p>\n<p>那么既然全局的block具有函数的特性，就不必在考虑其生命周期（函数是一执行完就被释放）</p>\n<hr>\n<h2 id=\"栈中的block\"><a href=\"#栈中的block\" class=\"headerlink\" title=\"栈中的block\"></a>栈中的block</h2><p>这个block其实是在编译器发现block内部调用或者说引用了外部的一些变量之后才生成的block。</p>\n<blockquote>\n<p><strong>在block内部有引用外部变量是，当block内部的结构体第一次被创建时，它会存在与该函数的函数调用栈中，其捕获的变量是会赋值到结构体的成员变量中的，所以当block完成初始化之后是不能更改其内部变量的，所以就知道为什么需要改变block内部的变量需要用到 __block了。</strong></p>\n</blockquote>\n<blockquote>\n<p><strong>当函数调用结束或者返回时，函数的调用栈就会被销毁，这时block的内存也会被销毁，所以如果后续仍然需要使用这个block的时候，就必须将block以Block_Copy()的方法拷贝到堆上。也就是直接在堆上面申请内存，将block复制过去，最后在捕获到的对象发送retain，增加block的引用计数，保证block在堆上不被释放掉。</strong></p>\n</blockquote>\n<p>举个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    int a = 100;</span><br><span class=\"line\">    void (^block2)(void) = ^&#123;</span><br><span class=\"line\">        printf(&quot;%d\\n&quot;, a);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    block2();</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>让clang反编译重写之后：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct __main_block_impl_0 &#123;</span><br><span class=\"line\">    struct __block_impl impl;</span><br><span class=\"line\">    struct __main_block_desc_0* Desc;</span><br><span class=\"line\">    int a;</span><br><span class=\"line\">    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _a, int flags=0) : a(_a) &#123;</span><br><span class=\"line\">        impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class=\"line\">        impl.Flags = flags;</span><br><span class=\"line\">        impl.FuncPtr = fp;</span><br><span class=\"line\">        Desc = desc;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class=\"line\">    int a = __cself-&gt;a; // bound by copy</span><br><span class=\"line\">    printf(&quot;%d\\n&quot;, a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">static struct __main_block_desc_0 &#123;</span><br><span class=\"line\">    size_t reserved;</span><br><span class=\"line\">    size_t Block_size;</span><br><span class=\"line\">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int a = 100;</span><br><span class=\"line\">    void (*block2)(void) = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a);</span><br><span class=\"line\">    ((void (*)(__block_impl *))((__block_impl *)block2)-&gt;FuncPtr)((__block_impl *)block2);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"堆中的block\"><a href=\"#堆中的block\" class=\"headerlink\" title=\"堆中的block\"></a>堆中的block</h2><blockquote>\n<p><strong>在栈中的block提到过，当函数调用结束，函数的调用栈会被销毁，那么栈中的block也会被销毁，但是我们一般都需要在函数结束之后任然使用这个block，所以就需要把栈中的block拷贝到堆上，在copy的同时，栈上的block的类型就转换成了堆上的block。</strong></p>\n</blockquote>\n<blockquote>\n<p><strong>所以，在MRC时代，block的属性关键字必须是copy。这样就能保证再给block的属性复制的时候，能把栈上的block复制到堆上。</strong></p>\n</blockquote>\n<hr>\n<h1 id=\"ARC时代的block之循环引用\"><a href=\"#ARC时代的block之循环引用\" class=\"headerlink\" title=\"ARC时代的block之循环引用\"></a>ARC时代的block之循环引用</h1><p>在开启ARC后，block的内存会比较微妙。ARC会自动处理block的内存，不用手动copy&#x2F;release。</p>\n<p>但是，和非ARC的情况有所不同：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void (^aBlock)(void);</span><br><span class=\"line\">aBlock = ^&#123; </span><br><span class=\"line\">\tprintf(&quot;ok&quot;); </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>block是对象，所以aBlock默认是有__strong修饰符的，即aBlock对该block有strong references。即aBlock在被赋值的那一刻，这个block会被copy。所以，ARC开启后，所能接触到的block基本都是在堆上的。。</p>\n<p>当block被copy之后(如开启了ARC、或把block放入dispatch queue)，该block对它捕获的对象产生strong references (非ARC下是retain)，所以有时需要避免block copy后产生的循环引用。</p>\n<p>如果用self引用了block，block又捕获了self，这样就会有循环引用。<br>因此，需要用weak来声明self</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)configureBlock &#123;</span><br><span class=\"line\">    XYZBlockKeeper * __weak weakSelf = self;</span><br><span class=\"line\">    self.block = ^&#123;</span><br><span class=\"line\">        [weakSelf doSomething]; //捕获到的是弱引用</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果捕获到的是当前对象的成员变量对象，同样也会造成对self的引用，同样也要避免。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)configureBlock &#123;</span><br><span class=\"line\">    id tmpIvar = _ivar; //临时变量,避免了self引用</span><br><span class=\"line\">    self.block = ^&#123;</span><br><span class=\"line\">        [tmpIvar msg];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了避免循环引用，可以这样理解block：block就是一个对象，它捕获到的值就是这个对象的@property (strong)。</p>"},{"title":"iOS底层之RunLoop","top":0,"need_not_copyright":true,"date":"2018-04-20T09:38:52.000Z","banner_img":null,"_content":"\nrunloop在iOS开发中是一个十分基础的概念，本文将从CFRunLoop入手，介绍runloop的概念和底层实现原理。然后介绍Apple是如何通过runloop在处理一些列的触摸事件和方法回调以及自动释放池等功能的。文中部分内容来自[此博客](http://blog.ibireme.com/2015/05/18/runloop/)。\n\n<!-- more -->\n---\n\n# RunLoop的概念\n\n一般来讲，一个线程一次只能执行一次任务，任务完成之后线程就会退出，但是如果一种这种机制，让一条线程既能处理事件又不退出，通常会设置一个无线的死循环，让这条线程在里面跑而不退出，一般的代码可以这样写：\n\n```\nfunction loop() {\n    initialize();\n    do {\n        var message = get_next_message();\n        process_message(message);\n    } while (message != quit);\n}\n```\n\n上面这种模型我们通常称之为event loop。这种事件的处理模型在很多开发中都有，比如安卓开发中也有类似的loop循环，Windows的程序的循环消息，iOS/OSX的runloop等等。\n\n所以runloop实际上也是一个对象，这个对象处理了很多东西，触摸事件和方法回调，并提供一个入口函数来执行event loop逻辑，线程执行完毕之后会一直处于“接收消息 - 等待 - 处理”的循环之中，直到这个循环结束，函数返回。\n\n在iOS/OSX中提供了两种这样的对象：NSRunLoop和CFRunLoopRef。其中NSRunLoop是基于CFRunLoopRef的第二层封装，更加面向对象，但是NSRunLoop的API的线程是不安全的。\n\n而CFRunLoopRef是在CoreFoundation的框架内的，它提供了纯C语言的API，所以这些API的线程是安全的。CFRunLoopRef 的代码是[开源](http://opensource.apple.com/source/CF/CF-855.17/CFRunLoop.c)的，你可以在这里[http://opensource.apple.com/tarballs/CF/](http://opensource.apple.com/tarballs/CF/)下载到整个CoreFoundation 的源码来查看。\n\n---\n\n# RunLoop与线程的关系\n\n线程和RunLoop是一一对应的关系，每一条线程都有与之对应的RunLoop，主线程的RunLoop是在程序启动时就已经开启，而其他线程在被创建时并不会开启RunLoop，如果子线程不主动去开启RunLoop，那他将一直不会有。RunLoop的创建发生在第一次获取时，销毁时发生在线程结束时。只能在一条线程内部获取其RunLoop。\n\n---\n\n# RunLoop对外的接口\n\n在CoreFoundation框架中，提供了RunLoop的5种类：\n\n* CFRunLoopRef\n* CFRunLoopModeRef\n* CFRunLoopSourceRef\n* CFRunLoopTimerRef\n\n## CFRunLoopModeRef\n\n其中，CFRunLoopModeRef并没有对外暴露接口，只是通过CFRunLoopRef对其接口进行封装，其关系如下：\n\n![](RunLoop_0.png)\n\n一个RunLoop的包含若干个Mode，每个Mode又包含若干个source/timer/observer，每次调用RunLoop的主函数时，只能指定其中一个Mode，而这个Mode又被称之为currentMode。如果需要切换Mode只能退出当前的loop再重新指定一个Mode进入。这样做的目的是为了分隔开不同的source/timer/observer，让其相互之间互不影响。\n\n## CFRunLoopSourceRef\n\nCFRunLoopSourceRef是事件产生的地方。source主要有2个版本：source0和source1，\n\n* Source0 只包含了一个函数指针的回调，它并不能主动触发事件。使用时，你需要先调用CFRunLoopSourceSignal\\(source\\)，将这个Source标记为待处理，然后手动调用CFRunLoopWakeUp\\(runloop\\)来唤醒RunLoop，让其处理这个事件。\n* Source1 包含了 一个mach\\_port和一个函数的回调指针，被用于通过内核和其他线程相互发送消息。source1可以主动唤醒RunLoop的线程。\n\n### CFRunLoopTimerRef\n\nCFRunLoopTimerRef是基于时间的触时发器，它和NSTimer可以混用。其中包含了一个时间的长度和一个函数的指针回调。当加入RunLoop时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行此回调。\n\n> 这里补充一个知识点，就是为什么NSTimer会不准的原因\n>\n> 首先我们知道，NSTimer是基于toll-free bridged的，严格来说NSTimer不是一个基于真实时间的机制，NSTimer被触发需要满足以下3个条件，\n>\n> 第一、NSTimer被添加到指定的RunLoop的Mode中；\n>\n> 第二、该Mode在RunLoop中正在运行；\n>\n> 第三、达到触发的时间，因为RunLoop需要管理大量的资源，为了提高NSTimer的效率，时间的间隔被限制为50-100毫秒比较合理，直到下一次RunLoop检测到NSTimer才会被触发\n>\n> 在苹果开发者文档中可以查看到，[参考](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-131281)\n>\n> 即使NSTimer会基于时间发出通知，但是由于NSTimer不是一个基于真实时间的机制。和输入源一样，timer和指定Mode的RunLoop紧密相连。如果没有被当前的Mode的RunLoop监测到，timer就不会被触发，直到timer指定的Mode的RunLoop运行时才会被触发。类似的，当timer被触发的时间达到，而RunLoop却又恰好正在执行一个handler句柄，那么timer就不会被触发，而是等到下次的触发时间点通过RunLoop来唤醒timer执行回调操作。如果RunLoop不再运行，那么timer就永远不会被触发\n\n### CFRunLoopObserverRef\n\nCFRunLoopObserverRef是RunLoop的观察者，每一个Observer都包含一个回调的函数指针，当RunLoop的状态发生变化时，观察者j就能通过回调接收到这个变化，在CFRunLoopRef的源码中，可以发现观察RunLoop的还时间点主要有以下几种：\n\n```\ntypedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {\n    kCFRunLoopEntry         = (1UL << 0), // 即将进入Loop\n    kCFRunLoopBeforeTimers  = (1UL << 1), // 即将处理 Timer\n    kCFRunLoopBeforeSources = (1UL << 2), // 即将处理 Source\n    kCFRunLoopBeforeWaiting = (1UL << 5), // 即将进入休眠\n    kCFRunLoopAfterWaiting  = (1UL << 6), // 刚从休眠中唤醒\n    kCFRunLoopExit          = (1UL << 7), // 即将退出Loop\n};\n```\n\n上面的Source/Timer/Observer被统称为Mode item，一个item可以同时加入多个Mode，但是一个item被重复加入同一个Mode将不会有效果。如果一个Mode中不包含其中任何一个item则RunLoop会直接退出，不再循环。\n\n---\n\n## RunLoop的Mode\n\nCFRunLoopMode和CFRunLoop的结构大致如下：\n\n```\nstruct __CFRunLoopMode {\n    CFStringRef _name;            // Mode Name, 例如 @\"kCFRunLoopDefaultMode\"\n    CFMutableSetRef _sources0;    // Set\n    CFMutableSetRef _sources1;    // Set\n    CFMutableArrayRef _observers; // Array\n    CFMutableArrayRef _timers;    // Array\n    ...\n};\n\nstruct __CFRunLoop {\n    CFMutableSetRef _commonModes;     // Set\n    CFMutableSetRef _commonModeItems; // Set<Source/Observer/Timer>\n    CFRunLoopModeRef _currentMode;    // Current Runloop Mode\n    CFMutableSetRef _modes;           // Set\n    ...\n};\n```\n\n此处有个概念叫“CommonModes”：一个Mode可以将自己标记为“Common”属性（通过将它的ModeName添加到RunLoop的commonModes中）。每个RunLoop的内容发生变化时，RunLoop都会自动将\\_commonModeItems里的Source/Observer/Timer同步到具有common标记的Mode里。\n\n例如：主线程的RunLoop里面有两个预置的Mode，即kCFRunLoopDefaultMode和UITrackingRunLoopMode。这两个Mode都已经被标记为common属性。defaultMode是APP平时所处的状态，TrackingRunLoopMode是已经追到ScrollView的滑动时的状态。当你创建一个Timer，并且添加到DefaultMode时，timer会得到重复的回调，但当此时滑动一个tableview或者scrollview时，RunLoop会将Mode切换为trackingRunLoopMode，此时这个timer将不会再被回调，并且也不会影响到滑动的操作。\n\n所以，有时候你需要一个timer，在这两种Mode之间回调，一种办法就是将这个timer分别加入到这两种Mode。另外一种方式就是将这个timer加入到顶层的RunLoop的commonModeitems中。这个commonModeItems将会被更新到所有具有common的标记的属性的Mode中。\n\nCFRunLoop对外暴露的接口只有以下2个：\n\n```\nCFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);\nCFRunLoopRunInMode(CFStringRef modeName, ...);\n```\n\nMode 暴露的管理 mode item 的接口有下面几个：\n\n```\nCFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);\nCFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);\nCFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);\nCFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);\nCFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);\nCFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);\n```\n\n你只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop会自动帮你创建对应的 CFRunLoopModeRef。对于一个 RunLoop 来说，其内部的 mode 只能增加不能删除。\n\n苹果公开提供的 Mode 有两个：kCFRunLoopDefaultMode \\(NSDefaultRunLoopMode\\) 和 UITrackingRunLoopMode，你可以用这两个 Mode Name 来操作其对应的 Mode。\n\n同时苹果还提供了一个操作 Common 标记的字符串：kCFRunLoopCommonModes \\(NSRunLoopCommonModes\\)，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 \"Common\"。使用时注意区分这个字符串和其他 mode name。\n\n---\n\n# RunLoop 的内部逻辑\n\n根据苹果在[文档](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW23)里的说明，RunLoop 内部的逻辑大致如下:\n\n![](RunLoop_1.png)\n\n```\n/// 用DefaultMode启动\nvoid CFRunLoopRun(void) {\n    CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);\n}\n\n/// 用指定的Mode启动，允许设置RunLoop超时时间\nint CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) {\n    return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);\n}\n\n/// RunLoop的实现\nint CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) {\n\n    /// 首先根据modeName找到对应mode\n    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false);\n    /// 如果mode里没有source/timer/observer, 直接返回。\n    if (__CFRunLoopModeIsEmpty(currentMode)) return;\n\n    /// 1. 通知 Observers: RunLoop 即将进入 loop。\n    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);\n\n    /// 内部函数，进入loop\n    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) {\n\n        Boolean sourceHandledThisLoop = NO;\n        int retVal = 0;\n        do {\n\n            /// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。\n            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);\n            /// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。\n            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);\n            /// 执行被加入的block\n            __CFRunLoopDoBlocks(runloop, currentMode);\n\n            /// 4. RunLoop 触发 Source0 (非port) 回调。\n            sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);\n            /// 执行被加入的block\n            __CFRunLoopDoBlocks(runloop, currentMode);\n\n            /// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。\n            if (__Source0DidDispatchPortLastTime) {\n                Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &msg)\n                if (hasMsg) goto handle_msg;\n            }\n\n            /// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。\n            if (!sourceHandledThisLoop) {\n                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);\n            }\n\n            /// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。\n            /// • 一个基于 port 的Source 的事件。\n            /// • 一个 Timer 到时间了\n            /// • RunLoop 自身的超时时间到了\n            /// • 被其他什么调用者手动唤醒\n            __CFRunLoopServiceMachPort(waitSet, &msg, sizeof(msg_buffer), &livePort) {\n                mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg\n            }\n\n            /// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。\n            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);\n\n            /// 收到消息，处理消息。\n            handle_msg:\n\n            /// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。\n            if (msg_is_timer) {\n                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())\n            } \n\n            /// 9.2 如果有dispatch到main_queue的block，执行block。\n            else if (msg_is_dispatch) {\n                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);\n            } \n\n            /// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件\n            else {\n                CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);\n                sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);\n                if (sourceHandledThisLoop) {\n                    mach_msg(reply, MACH_SEND_MSG, reply);\n                }\n            }\n\n            /// 执行加入到Loop的block\n            __CFRunLoopDoBlocks(runloop, currentMode);\n\n\n            if (sourceHandledThisLoop && stopAfterHandle) {\n                /// 进入loop时参数说处理完事件就返回。\n                retVal = kCFRunLoopRunHandledSource;\n            } else if (timeout) {\n                /// 超出传入参数标记的超时时间了\n                retVal = kCFRunLoopRunTimedOut;\n            } else if (__CFRunLoopIsStopped(runloop)) {\n                /// 被外部调用者强制停止了\n                retVal = kCFRunLoopRunStopped;\n            } else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) {\n                /// source/timer/observer一个都没有了\n                retVal = kCFRunLoopRunFinished;\n            }\n\n            /// 如果没超时，mode里没空，loop也没被停止，那继续loop。\n        } while (retVal == 0);\n    }\n\n    /// 10. 通知 Observers: RunLoop 即将退出。\n    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);\n}\n```\n\n可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun\\(\\) 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。\n\n---\n\n# RunLoop 的底层实现\n\n从上面代码可以看到，RunLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 mach\\_msg\\(\\)。为了解释这个逻辑，下面稍微介绍一下 OSX/iOS 的系统架构。\n\n![](RunLoop_3.png)\n\n苹果官方将整个系统大致划分为上述4个层次：  \n应用层包括用户能接触到的图形应用，例如 Spotlight、Aqua、SpringBoard 等。  \n应用框架层即开发人员接触到的 Cocoa 等框架。  \n核心框架层包括各种核心框架、OpenGL 等内容。  \nDarwin 即操作系统的核心，包括系统内核、驱动、Shell 等内容，这一层是开源的，其所有源码都可以在[opensource.apple.com](http://opensource.apple.com/)里找到。\n\n我们在深入看一下 Darwin 这个核心的架构：\n\n![](RunLoop_4.png)\n\n其中，在硬件层上面的三个组成部分：Mach、BSD、IOKit \\(还包括一些上面没标注的内容\\)，共同组成了 XNU 内核。  \nXNU 内核的内环被称作 Mach，其作为一个微内核，仅提供了诸如处理器调度、IPC \\(进程间通信\\)等非常少量的基础服务。  \nBSD 层可以看作围绕 Mach 层的一个外环，其提供了诸如进程管理、文件系统和网络等功能。  \nIOKit 层是为设备驱动提供了一个面向对象\\(C++\\)的一个框架。\n\nMach 本身提供的 API 非常有限，而且苹果也不鼓励使用 Mach 的 API，但是这些API非常基础，如果没有这些API的话，其他任何工作都无法实施。在 Mach 中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为\"对象\"。和其他架构不同， Mach 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。\"消息\"是 Mach 中最基础的概念，消息在两个端口 \\(port\\) 之间传递，这就是 Mach 的 IPC \\(进程间通信\\) 的核心。\n\nMach 的消息定义是在 &lt;mach/message.h&gt;头文件的，很简单：\n\n```\ntypedef struct {\n  mach_msg_header_t header;\n  mach_msg_body_t body;\n} mach_msg_base_t;\n\ntypedef struct {\n  mach_msg_bits_t msgh_bits;\n  mach_msg_size_t msgh_size;\n  mach_port_t msgh_remote_port;\n  mach_port_t msgh_local_port;\n  mach_port_name_t msgh_voucher_port;\n  mach_msg_id_t msgh_id;\n} mach_msg_header_t;\n```\n\n一条 Mach 消息实际上就是一个二进制数据包 \\(BLOB\\)，其头部定义了当前端口 local\\_port 和目标端口 remote\\_port，发送和接受消息是通过同一个 API 进行的，其 option 标记了消息传递的方向：\n\n```\nmach_msg_return_t mach_msg(\n            mach_msg_header_t *msg,\n            mach_msg_option_t option,\n            mach_msg_size_t send_size,\n            mach_msg_size_t rcv_size,\n            mach_port_name_t rcv_name,\n            mach_msg_timeout_t timeout,\n            mach_port_name_t notify);\n```\n\n为了实现消息的发送和接收，mach\\_msg\\(\\) 函数实际上是调用了一个 Mach 陷阱 \\(trap\\)，即函数mach\\_msg\\_trap\\(\\)，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 mach\\_msg\\_trap\\(\\) 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach\\_msg\\(\\) 函数会完成实际的工作，\n\nRunLoop 的核心就是一个 mach\\_msg\\(\\) \\(见上面代码的第7步\\)，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 mach\\_msg\\_trap\\(\\) 这个地方。\n\n关于具体的如何利用 mach port 发送信息，可以看看[NSHipster 这一篇文章](http://nshipster.com/inter-process-communication/)，或者[这里](http://segmentfault.com/a/1190000002400329)的中文翻译 。\n\n关于Mach的历史可以看看这篇很有趣的文章：[Mac OS X 背后的故事（三）Mach 之父 Avie Tevanian](http://www.programmer.com.cn/8121/)。\n\n---\n\n# 苹果用 RunLoop 实现的功能\n\n首先我们可以看一下 App 启动后 RunLoop 的状态：\n\n```\nCFRunLoop {\n    current mode = kCFRunLoopDefaultMode\n    common modes = {\n        UITrackingRunLoopMode\n        kCFRunLoopDefaultMode\n    }\n\n    common mode items = {\n\n        // source0 (manual)\n        CFRunLoopSource {order =-1, {\n            callout = _UIApplicationHandleEventQueue}}\n        CFRunLoopSource {order =-1, {\n            callout = PurpleEventSignalCallback }}\n        CFRunLoopSource {order = 0, {\n            callout = FBSSerialQueueRunLoopSourceHandler}}\n\n        // source1 (mach port)\n        CFRunLoopSource {order = 0,  {port = 17923}}\n        CFRunLoopSource {order = 0,  {port = 12039}}\n        CFRunLoopSource {order = 0,  {port = 16647}}\n        CFRunLoopSource {order =-1, {\n            callout = PurpleEventCallback}}\n        CFRunLoopSource {order = 0, {port = 2407,\n            callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_}}\n        CFRunLoopSource {order = 0, {port = 1c03,\n            callout = __IOHIDEventSystemClientAvailabilityCallback}}\n        CFRunLoopSource {order = 0, {port = 1b03,\n            callout = __IOHIDEventSystemClientQueueCallback}}\n        CFRunLoopSource {order = 1, {port = 1903,\n            callout = __IOMIGMachPortPortCallback}}\n\n        // Ovserver\n        CFRunLoopObserver {order = -2147483647, activities = 0x1, // Entry\n            callout = _wrapRunLoopWithAutoreleasePoolHandler}\n        CFRunLoopObserver {order = 0, activities = 0x20,          // BeforeWaiting\n            callout = _UIGestureRecognizerUpdateObserver}\n        CFRunLoopObserver {order = 1999000, activities = 0xa0,    // BeforeWaiting | Exit\n            callout = _afterCACommitHandler}\n        CFRunLoopObserver {order = 2000000, activities = 0xa0,    // BeforeWaiting | Exit\n            callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv}\n        CFRunLoopObserver {order = 2147483647, activities = 0xa0, // BeforeWaiting | Exit\n            callout = _wrapRunLoopWithAutoreleasePoolHandler}\n\n        // Timer\n        CFRunLoopTimer {firing = No, interval = 3.1536e+09, tolerance = 0,\n            next fire date = 453098071 (-4421.76019 @ 96223387169499),\n            callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)}\n    },\n\n    modes ＝ {\n        CFRunLoopMode  {\n            sources0 =  { /* same as 'common mode items' */ },\n            sources1 =  { /* same as 'common mode items' */ },\n            observers = { /* same as 'common mode items' */ },\n            timers =    { /* same as 'common mode items' */ },\n        },\n\n        CFRunLoopMode  {\n            sources0 =  { /* same as 'common mode items' */ },\n            sources1 =  { /* same as 'common mode items' */ },\n            observers = { /* same as 'common mode items' */ },\n            timers =    { /* same as 'common mode items' */ },\n        },\n\n        CFRunLoopMode  {\n            sources0 = {\n                CFRunLoopSource {order = 0, {\n                    callout = FBSSerialQueueRunLoopSourceHandler}}\n            },\n            sources1 = (null),\n            observers = {\n                CFRunLoopObserver >{activities = 0xa0, order = 2000000,\n                    callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv}\n            )},\n            timers = (null),\n        },\n\n        CFRunLoopMode  {\n            sources0 = {\n                CFRunLoopSource {order = -1, {\n                    callout = PurpleEventSignalCallback}}\n            },\n            sources1 = {\n                CFRunLoopSource {order = -1, {\n                    callout = PurpleEventCallback}}\n            },\n            observers = (null),\n            timers = (null),\n        },\n\n        CFRunLoopMode  {\n            sources0 = (null),\n            sources1 = (null),\n            observers = (null),\n            timers = (null),\n        }\n    }\n}\n```\n\n可以看到，系统默认注册了5个Mode:\n\n1. kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。\n\n2. UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。\n\n3. UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。\n\n4: GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。\n\n5: kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。\n\n你可以在[这里](http://iphonedevwiki.net/index.php/CFRunLoop)看到更多的苹果内部的 Mode，但那些 Mode 在开发中就很难遇到了。\n\n当 RunLoop 进行回调时，一般都是通过一个很长的函数调用出去 \\(call out\\), 当你在你的代码中下断点调试时，通常能在调用栈上看到这些函数。下面是这几个函数的整理版本，如果你在调用栈中看到这些长函数名，在这里查找一下就能定位到具体的调用地点了：\n\n```\n{\n    /// 1. 通知Observers，即将进入RunLoop\n    /// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();\n    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry);\n    do {\n\n        /// 2. 通知 Observers: 即将触发 Timer 回调。\n        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers);\n        /// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。\n        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources);\n        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);\n\n        /// 4. 触发 Source0 (非基于port的) 回调。\n        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0);\n        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);\n\n        /// 6. 通知Observers，即将进入休眠\n        /// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();\n        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting);\n\n        /// 7. sleep to wait msg.\n        mach_msg() -> mach_msg_trap();\n\n\n        /// 8. 通知Observers，线程被唤醒\n        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting);\n\n        /// 9. 如果是被Timer唤醒的，回调Timer\n        __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer);\n\n        /// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block\n        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block);\n\n        /// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件\n        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1);\n\n\n    } while (...);\n\n    /// 10. 通知Observers，即将退出RunLoop\n    /// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();\n    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);\n}\n```\n\n---\n\n# AutoreleasePool\n\nApp启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 \\_wrapRunLoopWithAutoreleasePoolHandler\\(\\)。\n\n第一个 Observer 监视的事件是 Entry\\(即将进入Loop\\)，其回调内会调用 \\_objc\\_autoreleasePoolPush\\(\\) 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。\n\n第二个 Observer 监视了两个事件： BeforeWaiting\\(准备进入休眠\\) 时调用\\_objc\\_autoreleasePoolPop\\(\\) 和 \\_objc\\_autoreleasePoolPush\\(\\) 释放旧的池并创建新池；Exit\\(即将退出Loop\\) 时调用 \\_objc\\_autoreleasePoolPop\\(\\) 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。\n\n在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。\n\n---\n\n# 事件响应\n\n苹果注册了一个 Source1 \\(基于 mach port 的\\) 用来接收系统事件，其回调函数为 \\_\\_IOHIDEventSystemClientQueueCallback\\(\\)。\n\n当一个硬件事件\\(触摸/锁屏/摇晃等\\)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考[这里](http://iphonedevwiki.net/index.php/IOHIDFamily)。SpringBoard 只接收按键\\(锁屏/静音等\\)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 \\_UIApplicationHandleEventQueue\\(\\) 进行应用内部的分发。\n\n\\_UIApplicationHandleEventQueue\\(\\) 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。\n\n---\n\n# 手势识别\n\n当上面的 \\_UIApplicationHandleEventQueue\\(\\) 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。\n\n苹果注册了一个 Observer 监测 BeforeWaiting \\(Loop即将进入休眠\\) 事件，这个Observer的回调函数是 \\_UIGestureRecognizerUpdateObserver\\(\\)，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。\n\n当有 UIGestureRecognizer 的变化\\(创建/销毁/状态改变\\)时，这个回调都会进行相应处理。\n\n---\n\n# 界面更新\n\n当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。\n\n苹果注册了一个 Observer 监听 BeforeWaiting\\(即将进入休眠\\) 和 Exit \\(即将退出Loop\\) 事件，回调去执行一个很长的函数：  \n\\_ZN2CA11Transaction17observer\\_callbackEP19\\_\\_CFRunLoopObservermPv\\(\\)。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。\n\n这个函数内部的调用栈大概是这样的：\n\n```\n_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()\n    QuartzCore:CA::Transaction::observer_callback:\n        CA::Transaction::commit();\n            CA::Context::commit_transaction();\n                CA::Layer::layout_and_display_if_needed();\n                    CA::Layer::layout_if_needed();\n                        [CALayer layoutSublayers];\n                            [UIView layoutSubviews];\n                    CA::Layer::display_if_needed();\n                        [CALayer display];\n                            [UIView drawRect];\n```\n\n---\n\n# 定时器\n\nNSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance \\(宽容度\\)，标示了当时间点到后，容许有多少最大误差。\n\n如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。\n\nCADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。\n\n---\n\n# PerformSelecter\n\n当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。\n\n当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。\n\n---\n\n# GCD\n\n实际上 RunLoop 底层也会用到 GCD 的东西，~~比如 RunLoop 是用 dispatch\\_source\\_t 实现的 Timer~~（评论中有人提醒，NSTimer 是用了 XNU 内核的 mk\\_timer，我也仔细调试了一下，发现 NSTimer 确实是由 mk\\_timer 驱动，而非 GCD 驱动的）。但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch\\_async\\(\\)。\n\n当调用 dispatch\\_async\\(dispatch\\_get\\_main\\_queue\\(\\), block\\) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 \\_\\_CFRUNLOOP\\_IS\\_SERVICING\\_THE\\_MAIN\\_DISPATCH\\_QUEUE\\_\\_\\(\\) 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。\n\n---\n\n# 网络请求\n\niOS 中，关于网络请求的接口自下至上有如下几层:\n\n```\nCFSocket\nCFNetwork       ->ASIHttpRequest\nNSURLConnection ->AFNetworking\nNSURLSession    ->AFNetworking2, Alamofire\n```\n\nCFSocket 是最底层的接口，只负责 socket 通信。\n\n* CFNetwork 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作于这一层。\n* NSURLConnection 是基于 CFNetwork 的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层。\n* NSURLSession 是 iOS7 中新增的接口，表面上是和 NSURLConnection 并列的，但底层仍然用到了 NSURLConnection 的部分功能 \\(比如 com.apple.NSURLConnectionLoader 线程\\)，AFNetworking2 和 Alamofire 工作于这一层。\n\n下面主要介绍下 NSURLConnection 的工作过程。\n\n通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 \\[connection start\\] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 \\(即需要手动触发的Source\\)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。\n\n当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。\n\n![](RunLoop_network.png)NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。\n\n","source":"_posts/iOS底层之RunLoop.md","raw":"---\ntitle: iOS底层之RunLoop\ntags: [RunLoop, 底层原理]\ntop: 0\nneed_not_copyright: true\ndate: 2018-04-20 17:38:52\ncategories: 底层原理\nbanner_img:\n---\n\nrunloop在iOS开发中是一个十分基础的概念，本文将从CFRunLoop入手，介绍runloop的概念和底层实现原理。然后介绍Apple是如何通过runloop在处理一些列的触摸事件和方法回调以及自动释放池等功能的。文中部分内容来自[此博客](http://blog.ibireme.com/2015/05/18/runloop/)。\n\n<!-- more -->\n---\n\n# RunLoop的概念\n\n一般来讲，一个线程一次只能执行一次任务，任务完成之后线程就会退出，但是如果一种这种机制，让一条线程既能处理事件又不退出，通常会设置一个无线的死循环，让这条线程在里面跑而不退出，一般的代码可以这样写：\n\n```\nfunction loop() {\n    initialize();\n    do {\n        var message = get_next_message();\n        process_message(message);\n    } while (message != quit);\n}\n```\n\n上面这种模型我们通常称之为event loop。这种事件的处理模型在很多开发中都有，比如安卓开发中也有类似的loop循环，Windows的程序的循环消息，iOS/OSX的runloop等等。\n\n所以runloop实际上也是一个对象，这个对象处理了很多东西，触摸事件和方法回调，并提供一个入口函数来执行event loop逻辑，线程执行完毕之后会一直处于“接收消息 - 等待 - 处理”的循环之中，直到这个循环结束，函数返回。\n\n在iOS/OSX中提供了两种这样的对象：NSRunLoop和CFRunLoopRef。其中NSRunLoop是基于CFRunLoopRef的第二层封装，更加面向对象，但是NSRunLoop的API的线程是不安全的。\n\n而CFRunLoopRef是在CoreFoundation的框架内的，它提供了纯C语言的API，所以这些API的线程是安全的。CFRunLoopRef 的代码是[开源](http://opensource.apple.com/source/CF/CF-855.17/CFRunLoop.c)的，你可以在这里[http://opensource.apple.com/tarballs/CF/](http://opensource.apple.com/tarballs/CF/)下载到整个CoreFoundation 的源码来查看。\n\n---\n\n# RunLoop与线程的关系\n\n线程和RunLoop是一一对应的关系，每一条线程都有与之对应的RunLoop，主线程的RunLoop是在程序启动时就已经开启，而其他线程在被创建时并不会开启RunLoop，如果子线程不主动去开启RunLoop，那他将一直不会有。RunLoop的创建发生在第一次获取时，销毁时发生在线程结束时。只能在一条线程内部获取其RunLoop。\n\n---\n\n# RunLoop对外的接口\n\n在CoreFoundation框架中，提供了RunLoop的5种类：\n\n* CFRunLoopRef\n* CFRunLoopModeRef\n* CFRunLoopSourceRef\n* CFRunLoopTimerRef\n\n## CFRunLoopModeRef\n\n其中，CFRunLoopModeRef并没有对外暴露接口，只是通过CFRunLoopRef对其接口进行封装，其关系如下：\n\n![](RunLoop_0.png)\n\n一个RunLoop的包含若干个Mode，每个Mode又包含若干个source/timer/observer，每次调用RunLoop的主函数时，只能指定其中一个Mode，而这个Mode又被称之为currentMode。如果需要切换Mode只能退出当前的loop再重新指定一个Mode进入。这样做的目的是为了分隔开不同的source/timer/observer，让其相互之间互不影响。\n\n## CFRunLoopSourceRef\n\nCFRunLoopSourceRef是事件产生的地方。source主要有2个版本：source0和source1，\n\n* Source0 只包含了一个函数指针的回调，它并不能主动触发事件。使用时，你需要先调用CFRunLoopSourceSignal\\(source\\)，将这个Source标记为待处理，然后手动调用CFRunLoopWakeUp\\(runloop\\)来唤醒RunLoop，让其处理这个事件。\n* Source1 包含了 一个mach\\_port和一个函数的回调指针，被用于通过内核和其他线程相互发送消息。source1可以主动唤醒RunLoop的线程。\n\n### CFRunLoopTimerRef\n\nCFRunLoopTimerRef是基于时间的触时发器，它和NSTimer可以混用。其中包含了一个时间的长度和一个函数的指针回调。当加入RunLoop时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行此回调。\n\n> 这里补充一个知识点，就是为什么NSTimer会不准的原因\n>\n> 首先我们知道，NSTimer是基于toll-free bridged的，严格来说NSTimer不是一个基于真实时间的机制，NSTimer被触发需要满足以下3个条件，\n>\n> 第一、NSTimer被添加到指定的RunLoop的Mode中；\n>\n> 第二、该Mode在RunLoop中正在运行；\n>\n> 第三、达到触发的时间，因为RunLoop需要管理大量的资源，为了提高NSTimer的效率，时间的间隔被限制为50-100毫秒比较合理，直到下一次RunLoop检测到NSTimer才会被触发\n>\n> 在苹果开发者文档中可以查看到，[参考](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-131281)\n>\n> 即使NSTimer会基于时间发出通知，但是由于NSTimer不是一个基于真实时间的机制。和输入源一样，timer和指定Mode的RunLoop紧密相连。如果没有被当前的Mode的RunLoop监测到，timer就不会被触发，直到timer指定的Mode的RunLoop运行时才会被触发。类似的，当timer被触发的时间达到，而RunLoop却又恰好正在执行一个handler句柄，那么timer就不会被触发，而是等到下次的触发时间点通过RunLoop来唤醒timer执行回调操作。如果RunLoop不再运行，那么timer就永远不会被触发\n\n### CFRunLoopObserverRef\n\nCFRunLoopObserverRef是RunLoop的观察者，每一个Observer都包含一个回调的函数指针，当RunLoop的状态发生变化时，观察者j就能通过回调接收到这个变化，在CFRunLoopRef的源码中，可以发现观察RunLoop的还时间点主要有以下几种：\n\n```\ntypedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {\n    kCFRunLoopEntry         = (1UL << 0), // 即将进入Loop\n    kCFRunLoopBeforeTimers  = (1UL << 1), // 即将处理 Timer\n    kCFRunLoopBeforeSources = (1UL << 2), // 即将处理 Source\n    kCFRunLoopBeforeWaiting = (1UL << 5), // 即将进入休眠\n    kCFRunLoopAfterWaiting  = (1UL << 6), // 刚从休眠中唤醒\n    kCFRunLoopExit          = (1UL << 7), // 即将退出Loop\n};\n```\n\n上面的Source/Timer/Observer被统称为Mode item，一个item可以同时加入多个Mode，但是一个item被重复加入同一个Mode将不会有效果。如果一个Mode中不包含其中任何一个item则RunLoop会直接退出，不再循环。\n\n---\n\n## RunLoop的Mode\n\nCFRunLoopMode和CFRunLoop的结构大致如下：\n\n```\nstruct __CFRunLoopMode {\n    CFStringRef _name;            // Mode Name, 例如 @\"kCFRunLoopDefaultMode\"\n    CFMutableSetRef _sources0;    // Set\n    CFMutableSetRef _sources1;    // Set\n    CFMutableArrayRef _observers; // Array\n    CFMutableArrayRef _timers;    // Array\n    ...\n};\n\nstruct __CFRunLoop {\n    CFMutableSetRef _commonModes;     // Set\n    CFMutableSetRef _commonModeItems; // Set<Source/Observer/Timer>\n    CFRunLoopModeRef _currentMode;    // Current Runloop Mode\n    CFMutableSetRef _modes;           // Set\n    ...\n};\n```\n\n此处有个概念叫“CommonModes”：一个Mode可以将自己标记为“Common”属性（通过将它的ModeName添加到RunLoop的commonModes中）。每个RunLoop的内容发生变化时，RunLoop都会自动将\\_commonModeItems里的Source/Observer/Timer同步到具有common标记的Mode里。\n\n例如：主线程的RunLoop里面有两个预置的Mode，即kCFRunLoopDefaultMode和UITrackingRunLoopMode。这两个Mode都已经被标记为common属性。defaultMode是APP平时所处的状态，TrackingRunLoopMode是已经追到ScrollView的滑动时的状态。当你创建一个Timer，并且添加到DefaultMode时，timer会得到重复的回调，但当此时滑动一个tableview或者scrollview时，RunLoop会将Mode切换为trackingRunLoopMode，此时这个timer将不会再被回调，并且也不会影响到滑动的操作。\n\n所以，有时候你需要一个timer，在这两种Mode之间回调，一种办法就是将这个timer分别加入到这两种Mode。另外一种方式就是将这个timer加入到顶层的RunLoop的commonModeitems中。这个commonModeItems将会被更新到所有具有common的标记的属性的Mode中。\n\nCFRunLoop对外暴露的接口只有以下2个：\n\n```\nCFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);\nCFRunLoopRunInMode(CFStringRef modeName, ...);\n```\n\nMode 暴露的管理 mode item 的接口有下面几个：\n\n```\nCFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);\nCFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);\nCFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);\nCFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);\nCFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);\nCFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);\n```\n\n你只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop会自动帮你创建对应的 CFRunLoopModeRef。对于一个 RunLoop 来说，其内部的 mode 只能增加不能删除。\n\n苹果公开提供的 Mode 有两个：kCFRunLoopDefaultMode \\(NSDefaultRunLoopMode\\) 和 UITrackingRunLoopMode，你可以用这两个 Mode Name 来操作其对应的 Mode。\n\n同时苹果还提供了一个操作 Common 标记的字符串：kCFRunLoopCommonModes \\(NSRunLoopCommonModes\\)，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 \"Common\"。使用时注意区分这个字符串和其他 mode name。\n\n---\n\n# RunLoop 的内部逻辑\n\n根据苹果在[文档](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW23)里的说明，RunLoop 内部的逻辑大致如下:\n\n![](RunLoop_1.png)\n\n```\n/// 用DefaultMode启动\nvoid CFRunLoopRun(void) {\n    CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);\n}\n\n/// 用指定的Mode启动，允许设置RunLoop超时时间\nint CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) {\n    return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);\n}\n\n/// RunLoop的实现\nint CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) {\n\n    /// 首先根据modeName找到对应mode\n    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false);\n    /// 如果mode里没有source/timer/observer, 直接返回。\n    if (__CFRunLoopModeIsEmpty(currentMode)) return;\n\n    /// 1. 通知 Observers: RunLoop 即将进入 loop。\n    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);\n\n    /// 内部函数，进入loop\n    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) {\n\n        Boolean sourceHandledThisLoop = NO;\n        int retVal = 0;\n        do {\n\n            /// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。\n            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);\n            /// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。\n            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);\n            /// 执行被加入的block\n            __CFRunLoopDoBlocks(runloop, currentMode);\n\n            /// 4. RunLoop 触发 Source0 (非port) 回调。\n            sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);\n            /// 执行被加入的block\n            __CFRunLoopDoBlocks(runloop, currentMode);\n\n            /// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。\n            if (__Source0DidDispatchPortLastTime) {\n                Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &msg)\n                if (hasMsg) goto handle_msg;\n            }\n\n            /// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。\n            if (!sourceHandledThisLoop) {\n                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);\n            }\n\n            /// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。\n            /// • 一个基于 port 的Source 的事件。\n            /// • 一个 Timer 到时间了\n            /// • RunLoop 自身的超时时间到了\n            /// • 被其他什么调用者手动唤醒\n            __CFRunLoopServiceMachPort(waitSet, &msg, sizeof(msg_buffer), &livePort) {\n                mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg\n            }\n\n            /// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。\n            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);\n\n            /// 收到消息，处理消息。\n            handle_msg:\n\n            /// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。\n            if (msg_is_timer) {\n                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())\n            } \n\n            /// 9.2 如果有dispatch到main_queue的block，执行block。\n            else if (msg_is_dispatch) {\n                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);\n            } \n\n            /// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件\n            else {\n                CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);\n                sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);\n                if (sourceHandledThisLoop) {\n                    mach_msg(reply, MACH_SEND_MSG, reply);\n                }\n            }\n\n            /// 执行加入到Loop的block\n            __CFRunLoopDoBlocks(runloop, currentMode);\n\n\n            if (sourceHandledThisLoop && stopAfterHandle) {\n                /// 进入loop时参数说处理完事件就返回。\n                retVal = kCFRunLoopRunHandledSource;\n            } else if (timeout) {\n                /// 超出传入参数标记的超时时间了\n                retVal = kCFRunLoopRunTimedOut;\n            } else if (__CFRunLoopIsStopped(runloop)) {\n                /// 被外部调用者强制停止了\n                retVal = kCFRunLoopRunStopped;\n            } else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) {\n                /// source/timer/observer一个都没有了\n                retVal = kCFRunLoopRunFinished;\n            }\n\n            /// 如果没超时，mode里没空，loop也没被停止，那继续loop。\n        } while (retVal == 0);\n    }\n\n    /// 10. 通知 Observers: RunLoop 即将退出。\n    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);\n}\n```\n\n可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun\\(\\) 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。\n\n---\n\n# RunLoop 的底层实现\n\n从上面代码可以看到，RunLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 mach\\_msg\\(\\)。为了解释这个逻辑，下面稍微介绍一下 OSX/iOS 的系统架构。\n\n![](RunLoop_3.png)\n\n苹果官方将整个系统大致划分为上述4个层次：  \n应用层包括用户能接触到的图形应用，例如 Spotlight、Aqua、SpringBoard 等。  \n应用框架层即开发人员接触到的 Cocoa 等框架。  \n核心框架层包括各种核心框架、OpenGL 等内容。  \nDarwin 即操作系统的核心，包括系统内核、驱动、Shell 等内容，这一层是开源的，其所有源码都可以在[opensource.apple.com](http://opensource.apple.com/)里找到。\n\n我们在深入看一下 Darwin 这个核心的架构：\n\n![](RunLoop_4.png)\n\n其中，在硬件层上面的三个组成部分：Mach、BSD、IOKit \\(还包括一些上面没标注的内容\\)，共同组成了 XNU 内核。  \nXNU 内核的内环被称作 Mach，其作为一个微内核，仅提供了诸如处理器调度、IPC \\(进程间通信\\)等非常少量的基础服务。  \nBSD 层可以看作围绕 Mach 层的一个外环，其提供了诸如进程管理、文件系统和网络等功能。  \nIOKit 层是为设备驱动提供了一个面向对象\\(C++\\)的一个框架。\n\nMach 本身提供的 API 非常有限，而且苹果也不鼓励使用 Mach 的 API，但是这些API非常基础，如果没有这些API的话，其他任何工作都无法实施。在 Mach 中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为\"对象\"。和其他架构不同， Mach 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。\"消息\"是 Mach 中最基础的概念，消息在两个端口 \\(port\\) 之间传递，这就是 Mach 的 IPC \\(进程间通信\\) 的核心。\n\nMach 的消息定义是在 &lt;mach/message.h&gt;头文件的，很简单：\n\n```\ntypedef struct {\n  mach_msg_header_t header;\n  mach_msg_body_t body;\n} mach_msg_base_t;\n\ntypedef struct {\n  mach_msg_bits_t msgh_bits;\n  mach_msg_size_t msgh_size;\n  mach_port_t msgh_remote_port;\n  mach_port_t msgh_local_port;\n  mach_port_name_t msgh_voucher_port;\n  mach_msg_id_t msgh_id;\n} mach_msg_header_t;\n```\n\n一条 Mach 消息实际上就是一个二进制数据包 \\(BLOB\\)，其头部定义了当前端口 local\\_port 和目标端口 remote\\_port，发送和接受消息是通过同一个 API 进行的，其 option 标记了消息传递的方向：\n\n```\nmach_msg_return_t mach_msg(\n            mach_msg_header_t *msg,\n            mach_msg_option_t option,\n            mach_msg_size_t send_size,\n            mach_msg_size_t rcv_size,\n            mach_port_name_t rcv_name,\n            mach_msg_timeout_t timeout,\n            mach_port_name_t notify);\n```\n\n为了实现消息的发送和接收，mach\\_msg\\(\\) 函数实际上是调用了一个 Mach 陷阱 \\(trap\\)，即函数mach\\_msg\\_trap\\(\\)，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 mach\\_msg\\_trap\\(\\) 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach\\_msg\\(\\) 函数会完成实际的工作，\n\nRunLoop 的核心就是一个 mach\\_msg\\(\\) \\(见上面代码的第7步\\)，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 mach\\_msg\\_trap\\(\\) 这个地方。\n\n关于具体的如何利用 mach port 发送信息，可以看看[NSHipster 这一篇文章](http://nshipster.com/inter-process-communication/)，或者[这里](http://segmentfault.com/a/1190000002400329)的中文翻译 。\n\n关于Mach的历史可以看看这篇很有趣的文章：[Mac OS X 背后的故事（三）Mach 之父 Avie Tevanian](http://www.programmer.com.cn/8121/)。\n\n---\n\n# 苹果用 RunLoop 实现的功能\n\n首先我们可以看一下 App 启动后 RunLoop 的状态：\n\n```\nCFRunLoop {\n    current mode = kCFRunLoopDefaultMode\n    common modes = {\n        UITrackingRunLoopMode\n        kCFRunLoopDefaultMode\n    }\n\n    common mode items = {\n\n        // source0 (manual)\n        CFRunLoopSource {order =-1, {\n            callout = _UIApplicationHandleEventQueue}}\n        CFRunLoopSource {order =-1, {\n            callout = PurpleEventSignalCallback }}\n        CFRunLoopSource {order = 0, {\n            callout = FBSSerialQueueRunLoopSourceHandler}}\n\n        // source1 (mach port)\n        CFRunLoopSource {order = 0,  {port = 17923}}\n        CFRunLoopSource {order = 0,  {port = 12039}}\n        CFRunLoopSource {order = 0,  {port = 16647}}\n        CFRunLoopSource {order =-1, {\n            callout = PurpleEventCallback}}\n        CFRunLoopSource {order = 0, {port = 2407,\n            callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_}}\n        CFRunLoopSource {order = 0, {port = 1c03,\n            callout = __IOHIDEventSystemClientAvailabilityCallback}}\n        CFRunLoopSource {order = 0, {port = 1b03,\n            callout = __IOHIDEventSystemClientQueueCallback}}\n        CFRunLoopSource {order = 1, {port = 1903,\n            callout = __IOMIGMachPortPortCallback}}\n\n        // Ovserver\n        CFRunLoopObserver {order = -2147483647, activities = 0x1, // Entry\n            callout = _wrapRunLoopWithAutoreleasePoolHandler}\n        CFRunLoopObserver {order = 0, activities = 0x20,          // BeforeWaiting\n            callout = _UIGestureRecognizerUpdateObserver}\n        CFRunLoopObserver {order = 1999000, activities = 0xa0,    // BeforeWaiting | Exit\n            callout = _afterCACommitHandler}\n        CFRunLoopObserver {order = 2000000, activities = 0xa0,    // BeforeWaiting | Exit\n            callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv}\n        CFRunLoopObserver {order = 2147483647, activities = 0xa0, // BeforeWaiting | Exit\n            callout = _wrapRunLoopWithAutoreleasePoolHandler}\n\n        // Timer\n        CFRunLoopTimer {firing = No, interval = 3.1536e+09, tolerance = 0,\n            next fire date = 453098071 (-4421.76019 @ 96223387169499),\n            callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)}\n    },\n\n    modes ＝ {\n        CFRunLoopMode  {\n            sources0 =  { /* same as 'common mode items' */ },\n            sources1 =  { /* same as 'common mode items' */ },\n            observers = { /* same as 'common mode items' */ },\n            timers =    { /* same as 'common mode items' */ },\n        },\n\n        CFRunLoopMode  {\n            sources0 =  { /* same as 'common mode items' */ },\n            sources1 =  { /* same as 'common mode items' */ },\n            observers = { /* same as 'common mode items' */ },\n            timers =    { /* same as 'common mode items' */ },\n        },\n\n        CFRunLoopMode  {\n            sources0 = {\n                CFRunLoopSource {order = 0, {\n                    callout = FBSSerialQueueRunLoopSourceHandler}}\n            },\n            sources1 = (null),\n            observers = {\n                CFRunLoopObserver >{activities = 0xa0, order = 2000000,\n                    callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv}\n            )},\n            timers = (null),\n        },\n\n        CFRunLoopMode  {\n            sources0 = {\n                CFRunLoopSource {order = -1, {\n                    callout = PurpleEventSignalCallback}}\n            },\n            sources1 = {\n                CFRunLoopSource {order = -1, {\n                    callout = PurpleEventCallback}}\n            },\n            observers = (null),\n            timers = (null),\n        },\n\n        CFRunLoopMode  {\n            sources0 = (null),\n            sources1 = (null),\n            observers = (null),\n            timers = (null),\n        }\n    }\n}\n```\n\n可以看到，系统默认注册了5个Mode:\n\n1. kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。\n\n2. UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。\n\n3. UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。\n\n4: GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。\n\n5: kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。\n\n你可以在[这里](http://iphonedevwiki.net/index.php/CFRunLoop)看到更多的苹果内部的 Mode，但那些 Mode 在开发中就很难遇到了。\n\n当 RunLoop 进行回调时，一般都是通过一个很长的函数调用出去 \\(call out\\), 当你在你的代码中下断点调试时，通常能在调用栈上看到这些函数。下面是这几个函数的整理版本，如果你在调用栈中看到这些长函数名，在这里查找一下就能定位到具体的调用地点了：\n\n```\n{\n    /// 1. 通知Observers，即将进入RunLoop\n    /// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();\n    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry);\n    do {\n\n        /// 2. 通知 Observers: 即将触发 Timer 回调。\n        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers);\n        /// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。\n        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources);\n        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);\n\n        /// 4. 触发 Source0 (非基于port的) 回调。\n        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0);\n        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);\n\n        /// 6. 通知Observers，即将进入休眠\n        /// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();\n        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting);\n\n        /// 7. sleep to wait msg.\n        mach_msg() -> mach_msg_trap();\n\n\n        /// 8. 通知Observers，线程被唤醒\n        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting);\n\n        /// 9. 如果是被Timer唤醒的，回调Timer\n        __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer);\n\n        /// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block\n        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block);\n\n        /// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件\n        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1);\n\n\n    } while (...);\n\n    /// 10. 通知Observers，即将退出RunLoop\n    /// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();\n    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);\n}\n```\n\n---\n\n# AutoreleasePool\n\nApp启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 \\_wrapRunLoopWithAutoreleasePoolHandler\\(\\)。\n\n第一个 Observer 监视的事件是 Entry\\(即将进入Loop\\)，其回调内会调用 \\_objc\\_autoreleasePoolPush\\(\\) 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。\n\n第二个 Observer 监视了两个事件： BeforeWaiting\\(准备进入休眠\\) 时调用\\_objc\\_autoreleasePoolPop\\(\\) 和 \\_objc\\_autoreleasePoolPush\\(\\) 释放旧的池并创建新池；Exit\\(即将退出Loop\\) 时调用 \\_objc\\_autoreleasePoolPop\\(\\) 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。\n\n在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。\n\n---\n\n# 事件响应\n\n苹果注册了一个 Source1 \\(基于 mach port 的\\) 用来接收系统事件，其回调函数为 \\_\\_IOHIDEventSystemClientQueueCallback\\(\\)。\n\n当一个硬件事件\\(触摸/锁屏/摇晃等\\)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考[这里](http://iphonedevwiki.net/index.php/IOHIDFamily)。SpringBoard 只接收按键\\(锁屏/静音等\\)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 \\_UIApplicationHandleEventQueue\\(\\) 进行应用内部的分发。\n\n\\_UIApplicationHandleEventQueue\\(\\) 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。\n\n---\n\n# 手势识别\n\n当上面的 \\_UIApplicationHandleEventQueue\\(\\) 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。\n\n苹果注册了一个 Observer 监测 BeforeWaiting \\(Loop即将进入休眠\\) 事件，这个Observer的回调函数是 \\_UIGestureRecognizerUpdateObserver\\(\\)，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。\n\n当有 UIGestureRecognizer 的变化\\(创建/销毁/状态改变\\)时，这个回调都会进行相应处理。\n\n---\n\n# 界面更新\n\n当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。\n\n苹果注册了一个 Observer 监听 BeforeWaiting\\(即将进入休眠\\) 和 Exit \\(即将退出Loop\\) 事件，回调去执行一个很长的函数：  \n\\_ZN2CA11Transaction17observer\\_callbackEP19\\_\\_CFRunLoopObservermPv\\(\\)。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。\n\n这个函数内部的调用栈大概是这样的：\n\n```\n_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()\n    QuartzCore:CA::Transaction::observer_callback:\n        CA::Transaction::commit();\n            CA::Context::commit_transaction();\n                CA::Layer::layout_and_display_if_needed();\n                    CA::Layer::layout_if_needed();\n                        [CALayer layoutSublayers];\n                            [UIView layoutSubviews];\n                    CA::Layer::display_if_needed();\n                        [CALayer display];\n                            [UIView drawRect];\n```\n\n---\n\n# 定时器\n\nNSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance \\(宽容度\\)，标示了当时间点到后，容许有多少最大误差。\n\n如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。\n\nCADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。\n\n---\n\n# PerformSelecter\n\n当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。\n\n当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。\n\n---\n\n# GCD\n\n实际上 RunLoop 底层也会用到 GCD 的东西，~~比如 RunLoop 是用 dispatch\\_source\\_t 实现的 Timer~~（评论中有人提醒，NSTimer 是用了 XNU 内核的 mk\\_timer，我也仔细调试了一下，发现 NSTimer 确实是由 mk\\_timer 驱动，而非 GCD 驱动的）。但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch\\_async\\(\\)。\n\n当调用 dispatch\\_async\\(dispatch\\_get\\_main\\_queue\\(\\), block\\) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 \\_\\_CFRUNLOOP\\_IS\\_SERVICING\\_THE\\_MAIN\\_DISPATCH\\_QUEUE\\_\\_\\(\\) 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。\n\n---\n\n# 网络请求\n\niOS 中，关于网络请求的接口自下至上有如下几层:\n\n```\nCFSocket\nCFNetwork       ->ASIHttpRequest\nNSURLConnection ->AFNetworking\nNSURLSession    ->AFNetworking2, Alamofire\n```\n\nCFSocket 是最底层的接口，只负责 socket 通信。\n\n* CFNetwork 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作于这一层。\n* NSURLConnection 是基于 CFNetwork 的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层。\n* NSURLSession 是 iOS7 中新增的接口，表面上是和 NSURLConnection 并列的，但底层仍然用到了 NSURLConnection 的部分功能 \\(比如 com.apple.NSURLConnectionLoader 线程\\)，AFNetworking2 和 Alamofire 工作于这一层。\n\n下面主要介绍下 NSURLConnection 的工作过程。\n\n通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 \\[connection start\\] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 \\(即需要手动触发的Source\\)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。\n\n当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。\n\n![](RunLoop_network.png)NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。\n\n","slug":"iOS底层之RunLoop","published":1,"updated":"2023-07-21T09:10:33.574Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clkcgbp5h0017pfo72n062gmt","content":"<p>runloop在iOS开发中是一个十分基础的概念，本文将从CFRunLoop入手，介绍runloop的概念和底层实现原理。然后介绍Apple是如何通过runloop在处理一些列的触摸事件和方法回调以及自动释放池等功能的。文中部分内容来自<a href=\"http://blog.ibireme.com/2015/05/18/runloop/\">此博客</a>。</p>\n<span id=\"more\"></span>\n<hr>\n<h1 id=\"RunLoop的概念\"><a href=\"#RunLoop的概念\" class=\"headerlink\" title=\"RunLoop的概念\"></a>RunLoop的概念</h1><p>一般来讲，一个线程一次只能执行一次任务，任务完成之后线程就会退出，但是如果一种这种机制，让一条线程既能处理事件又不退出，通常会设置一个无线的死循环，让这条线程在里面跑而不退出，一般的代码可以这样写：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function loop() &#123;</span><br><span class=\"line\">    initialize();</span><br><span class=\"line\">    do &#123;</span><br><span class=\"line\">        var message = get_next_message();</span><br><span class=\"line\">        process_message(message);</span><br><span class=\"line\">    &#125; while (message != quit);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面这种模型我们通常称之为event loop。这种事件的处理模型在很多开发中都有，比如安卓开发中也有类似的loop循环，Windows的程序的循环消息，iOS&#x2F;OSX的runloop等等。</p>\n<p>所以runloop实际上也是一个对象，这个对象处理了很多东西，触摸事件和方法回调，并提供一个入口函数来执行event loop逻辑，线程执行完毕之后会一直处于“接收消息 - 等待 - 处理”的循环之中，直到这个循环结束，函数返回。</p>\n<p>在iOS&#x2F;OSX中提供了两种这样的对象：NSRunLoop和CFRunLoopRef。其中NSRunLoop是基于CFRunLoopRef的第二层封装，更加面向对象，但是NSRunLoop的API的线程是不安全的。</p>\n<p>而CFRunLoopRef是在CoreFoundation的框架内的，它提供了纯C语言的API，所以这些API的线程是安全的。CFRunLoopRef 的代码是<a href=\"http://opensource.apple.com/source/CF/CF-855.17/CFRunLoop.c\">开源</a>的，你可以在这里<a href=\"http://opensource.apple.com/tarballs/CF/\">http://opensource.apple.com/tarballs/CF/</a>下载到整个CoreFoundation 的源码来查看。</p>\n<hr>\n<h1 id=\"RunLoop与线程的关系\"><a href=\"#RunLoop与线程的关系\" class=\"headerlink\" title=\"RunLoop与线程的关系\"></a>RunLoop与线程的关系</h1><p>线程和RunLoop是一一对应的关系，每一条线程都有与之对应的RunLoop，主线程的RunLoop是在程序启动时就已经开启，而其他线程在被创建时并不会开启RunLoop，如果子线程不主动去开启RunLoop，那他将一直不会有。RunLoop的创建发生在第一次获取时，销毁时发生在线程结束时。只能在一条线程内部获取其RunLoop。</p>\n<hr>\n<h1 id=\"RunLoop对外的接口\"><a href=\"#RunLoop对外的接口\" class=\"headerlink\" title=\"RunLoop对外的接口\"></a>RunLoop对外的接口</h1><p>在CoreFoundation框架中，提供了RunLoop的5种类：</p>\n<ul>\n<li>CFRunLoopRef</li>\n<li>CFRunLoopModeRef</li>\n<li>CFRunLoopSourceRef</li>\n<li>CFRunLoopTimerRef</li>\n</ul>\n<h2 id=\"CFRunLoopModeRef\"><a href=\"#CFRunLoopModeRef\" class=\"headerlink\" title=\"CFRunLoopModeRef\"></a>CFRunLoopModeRef</h2><p>其中，CFRunLoopModeRef并没有对外暴露接口，只是通过CFRunLoopRef对其接口进行封装，其关系如下：</p>\n<p><img src=\"/2018/04/20/iOS%E5%BA%95%E5%B1%82%E4%B9%8BRunLoop/RunLoop_0.png\"></p>\n<p>一个RunLoop的包含若干个Mode，每个Mode又包含若干个source&#x2F;timer&#x2F;observer，每次调用RunLoop的主函数时，只能指定其中一个Mode，而这个Mode又被称之为currentMode。如果需要切换Mode只能退出当前的loop再重新指定一个Mode进入。这样做的目的是为了分隔开不同的source&#x2F;timer&#x2F;observer，让其相互之间互不影响。</p>\n<h2 id=\"CFRunLoopSourceRef\"><a href=\"#CFRunLoopSourceRef\" class=\"headerlink\" title=\"CFRunLoopSourceRef\"></a>CFRunLoopSourceRef</h2><p>CFRunLoopSourceRef是事件产生的地方。source主要有2个版本：source0和source1，</p>\n<ul>\n<li>Source0 只包含了一个函数指针的回调，它并不能主动触发事件。使用时，你需要先调用CFRunLoopSourceSignal(source)，将这个Source标记为待处理，然后手动调用CFRunLoopWakeUp(runloop)来唤醒RunLoop，让其处理这个事件。</li>\n<li>Source1 包含了 一个mach_port和一个函数的回调指针，被用于通过内核和其他线程相互发送消息。source1可以主动唤醒RunLoop的线程。</li>\n</ul>\n<h3 id=\"CFRunLoopTimerRef\"><a href=\"#CFRunLoopTimerRef\" class=\"headerlink\" title=\"CFRunLoopTimerRef\"></a>CFRunLoopTimerRef</h3><p>CFRunLoopTimerRef是基于时间的触时发器，它和NSTimer可以混用。其中包含了一个时间的长度和一个函数的指针回调。当加入RunLoop时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行此回调。</p>\n<blockquote>\n<p>这里补充一个知识点，就是为什么NSTimer会不准的原因</p>\n<p>首先我们知道，NSTimer是基于toll-free bridged的，严格来说NSTimer不是一个基于真实时间的机制，NSTimer被触发需要满足以下3个条件，</p>\n<p>第一、NSTimer被添加到指定的RunLoop的Mode中；</p>\n<p>第二、该Mode在RunLoop中正在运行；</p>\n<p>第三、达到触发的时间，因为RunLoop需要管理大量的资源，为了提高NSTimer的效率，时间的间隔被限制为50-100毫秒比较合理，直到下一次RunLoop检测到NSTimer才会被触发</p>\n<p>在苹果开发者文档中可以查看到，<a href=\"https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-131281\">参考</a></p>\n<p>即使NSTimer会基于时间发出通知，但是由于NSTimer不是一个基于真实时间的机制。和输入源一样，timer和指定Mode的RunLoop紧密相连。如果没有被当前的Mode的RunLoop监测到，timer就不会被触发，直到timer指定的Mode的RunLoop运行时才会被触发。类似的，当timer被触发的时间达到，而RunLoop却又恰好正在执行一个handler句柄，那么timer就不会被触发，而是等到下次的触发时间点通过RunLoop来唤醒timer执行回调操作。如果RunLoop不再运行，那么timer就永远不会被触发</p>\n</blockquote>\n<h3 id=\"CFRunLoopObserverRef\"><a href=\"#CFRunLoopObserverRef\" class=\"headerlink\" title=\"CFRunLoopObserverRef\"></a>CFRunLoopObserverRef</h3><p>CFRunLoopObserverRef是RunLoop的观察者，每一个Observer都包含一个回调的函数指针，当RunLoop的状态发生变化时，观察者j就能通过回调接收到这个变化，在CFRunLoopRef的源码中，可以发现观察RunLoop的还时间点主要有以下几种：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class=\"line\">    kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入Loop</span><br><span class=\"line\">    kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 Timer</span><br><span class=\"line\">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source</span><br><span class=\"line\">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠</span><br><span class=\"line\">    kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒</span><br><span class=\"line\">    kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出Loop</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>上面的Source&#x2F;Timer&#x2F;Observer被统称为Mode item，一个item可以同时加入多个Mode，但是一个item被重复加入同一个Mode将不会有效果。如果一个Mode中不包含其中任何一个item则RunLoop会直接退出，不再循环。</p>\n<hr>\n<h2 id=\"RunLoop的Mode\"><a href=\"#RunLoop的Mode\" class=\"headerlink\" title=\"RunLoop的Mode\"></a>RunLoop的Mode</h2><p>CFRunLoopMode和CFRunLoop的结构大致如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct __CFRunLoopMode &#123;</span><br><span class=\"line\">    CFStringRef _name;            // Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot;</span><br><span class=\"line\">    CFMutableSetRef _sources0;    // Set</span><br><span class=\"line\">    CFMutableSetRef _sources1;    // Set</span><br><span class=\"line\">    CFMutableArrayRef _observers; // Array</span><br><span class=\"line\">    CFMutableArrayRef _timers;    // Array</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">struct __CFRunLoop &#123;</span><br><span class=\"line\">    CFMutableSetRef _commonModes;     // Set</span><br><span class=\"line\">    CFMutableSetRef _commonModeItems; // Set&lt;Source/Observer/Timer&gt;</span><br><span class=\"line\">    CFRunLoopModeRef _currentMode;    // Current Runloop Mode</span><br><span class=\"line\">    CFMutableSetRef _modes;           // Set</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>此处有个概念叫“CommonModes”：一个Mode可以将自己标记为“Common”属性（通过将它的ModeName添加到RunLoop的commonModes中）。每个RunLoop的内容发生变化时，RunLoop都会自动将_commonModeItems里的Source&#x2F;Observer&#x2F;Timer同步到具有common标记的Mode里。</p>\n<p>例如：主线程的RunLoop里面有两个预置的Mode，即kCFRunLoopDefaultMode和UITrackingRunLoopMode。这两个Mode都已经被标记为common属性。defaultMode是APP平时所处的状态，TrackingRunLoopMode是已经追到ScrollView的滑动时的状态。当你创建一个Timer，并且添加到DefaultMode时，timer会得到重复的回调，但当此时滑动一个tableview或者scrollview时，RunLoop会将Mode切换为trackingRunLoopMode，此时这个timer将不会再被回调，并且也不会影响到滑动的操作。</p>\n<p>所以，有时候你需要一个timer，在这两种Mode之间回调，一种办法就是将这个timer分别加入到这两种Mode。另外一种方式就是将这个timer加入到顶层的RunLoop的commonModeitems中。这个commonModeItems将会被更新到所有具有common的标记的属性的Mode中。</p>\n<p>CFRunLoop对外暴露的接口只有以下2个：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);</span><br><span class=\"line\">CFRunLoopRunInMode(CFStringRef modeName, ...);</span><br></pre></td></tr></table></figure>\n\n<p>Mode 暴露的管理 mode item 的接口有下面几个：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</span><br><span class=\"line\">CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</span><br><span class=\"line\">CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</span><br><span class=\"line\">CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</span><br><span class=\"line\">CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</span><br><span class=\"line\">CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</span><br></pre></td></tr></table></figure>\n\n<p>你只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop会自动帮你创建对应的 CFRunLoopModeRef。对于一个 RunLoop 来说，其内部的 mode 只能增加不能删除。</p>\n<p>苹果公开提供的 Mode 有两个：kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 和 UITrackingRunLoopMode，你可以用这两个 Mode Name 来操作其对应的 Mode。</p>\n<p>同时苹果还提供了一个操作 Common 标记的字符串：kCFRunLoopCommonModes (NSRunLoopCommonModes)，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common”。使用时注意区分这个字符串和其他 mode name。</p>\n<hr>\n<h1 id=\"RunLoop-的内部逻辑\"><a href=\"#RunLoop-的内部逻辑\" class=\"headerlink\" title=\"RunLoop 的内部逻辑\"></a>RunLoop 的内部逻辑</h1><p>根据苹果在<a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW23\">文档</a>里的说明，RunLoop 内部的逻辑大致如下:</p>\n<p><img src=\"/2018/04/20/iOS%E5%BA%95%E5%B1%82%E4%B9%8BRunLoop/RunLoop_1.png\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/// 用DefaultMode启动</span><br><span class=\"line\">void CFRunLoopRun(void) &#123;</span><br><span class=\"line\">    CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/// 用指定的Mode启动，允许设置RunLoop超时时间</span><br><span class=\"line\">int CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) &#123;</span><br><span class=\"line\">    return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/// RunLoop的实现</span><br><span class=\"line\">int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /// 首先根据modeName找到对应mode</span><br><span class=\"line\">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false);</span><br><span class=\"line\">    /// 如果mode里没有source/timer/observer, 直接返回。</span><br><span class=\"line\">    if (__CFRunLoopModeIsEmpty(currentMode)) return;</span><br><span class=\"line\"></span><br><span class=\"line\">    /// 1. 通知 Observers: RunLoop 即将进入 loop。</span><br><span class=\"line\">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);</span><br><span class=\"line\"></span><br><span class=\"line\">    /// 内部函数，进入loop</span><br><span class=\"line\">    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Boolean sourceHandledThisLoop = NO;</span><br><span class=\"line\">        int retVal = 0;</span><br><span class=\"line\">        do &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            /// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span><br><span class=\"line\">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</span><br><span class=\"line\">            /// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span><br><span class=\"line\">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</span><br><span class=\"line\">            /// 执行被加入的block</span><br><span class=\"line\">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class=\"line\"></span><br><span class=\"line\">            /// 4. RunLoop 触发 Source0 (非port) 回调。</span><br><span class=\"line\">            sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);</span><br><span class=\"line\">            /// 执行被加入的block</span><br><span class=\"line\">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class=\"line\"></span><br><span class=\"line\">            /// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span><br><span class=\"line\">            if (__Source0DidDispatchPortLastTime) &#123;</span><br><span class=\"line\">                Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)</span><br><span class=\"line\">                if (hasMsg) goto handle_msg;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            /// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span><br><span class=\"line\">            if (!sourceHandledThisLoop) &#123;</span><br><span class=\"line\">                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            /// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span><br><span class=\"line\">            /// • 一个基于 port 的Source 的事件。</span><br><span class=\"line\">            /// • 一个 Timer 到时间了</span><br><span class=\"line\">            /// • RunLoop 自身的超时时间到了</span><br><span class=\"line\">            /// • 被其他什么调用者手动唤醒</span><br><span class=\"line\">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123;</span><br><span class=\"line\">                mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            /// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span><br><span class=\"line\">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</span><br><span class=\"line\"></span><br><span class=\"line\">            /// 收到消息，处理消息。</span><br><span class=\"line\">            handle_msg:</span><br><span class=\"line\"></span><br><span class=\"line\">            /// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span><br><span class=\"line\">            if (msg_is_timer) &#123;</span><br><span class=\"line\">                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">            /// 9.2 如果有dispatch到main_queue的block，执行block。</span><br><span class=\"line\">            else if (msg_is_dispatch) &#123;</span><br><span class=\"line\">                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">            /// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span><br><span class=\"line\">            else &#123;</span><br><span class=\"line\">                CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</span><br><span class=\"line\">                sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);</span><br><span class=\"line\">                if (sourceHandledThisLoop) &#123;</span><br><span class=\"line\">                    mach_msg(reply, MACH_SEND_MSG, reply);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            /// 执行加入到Loop的block</span><br><span class=\"line\">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">            if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class=\"line\">                /// 进入loop时参数说处理完事件就返回。</span><br><span class=\"line\">                retVal = kCFRunLoopRunHandledSource;</span><br><span class=\"line\">            &#125; else if (timeout) &#123;</span><br><span class=\"line\">                /// 超出传入参数标记的超时时间了</span><br><span class=\"line\">                retVal = kCFRunLoopRunTimedOut;</span><br><span class=\"line\">            &#125; else if (__CFRunLoopIsStopped(runloop)) &#123;</span><br><span class=\"line\">                /// 被外部调用者强制停止了</span><br><span class=\"line\">                retVal = kCFRunLoopRunStopped;</span><br><span class=\"line\">            &#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</span><br><span class=\"line\">                /// source/timer/observer一个都没有了</span><br><span class=\"line\">                retVal = kCFRunLoopRunFinished;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            /// 如果没超时，mode里没空，loop也没被停止，那继续loop。</span><br><span class=\"line\">        &#125; while (retVal == 0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /// 10. 通知 Observers: RunLoop 即将退出。</span><br><span class=\"line\">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。</p>\n<hr>\n<h1 id=\"RunLoop-的底层实现\"><a href=\"#RunLoop-的底层实现\" class=\"headerlink\" title=\"RunLoop 的底层实现\"></a>RunLoop 的底层实现</h1><p>从上面代码可以看到，RunLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 mach_msg()。为了解释这个逻辑，下面稍微介绍一下 OSX&#x2F;iOS 的系统架构。</p>\n<p><img src=\"/2018/04/20/iOS%E5%BA%95%E5%B1%82%E4%B9%8BRunLoop/RunLoop_3.png\"></p>\n<p>苹果官方将整个系统大致划分为上述4个层次：<br>应用层包括用户能接触到的图形应用，例如 Spotlight、Aqua、SpringBoard 等。<br>应用框架层即开发人员接触到的 Cocoa 等框架。<br>核心框架层包括各种核心框架、OpenGL 等内容。<br>Darwin 即操作系统的核心，包括系统内核、驱动、Shell 等内容，这一层是开源的，其所有源码都可以在<a href=\"http://opensource.apple.com/\">opensource.apple.com</a>里找到。</p>\n<p>我们在深入看一下 Darwin 这个核心的架构：</p>\n<p><img src=\"/2018/04/20/iOS%E5%BA%95%E5%B1%82%E4%B9%8BRunLoop/RunLoop_4.png\"></p>\n<p>其中，在硬件层上面的三个组成部分：Mach、BSD、IOKit (还包括一些上面没标注的内容)，共同组成了 XNU 内核。<br>XNU 内核的内环被称作 Mach，其作为一个微内核，仅提供了诸如处理器调度、IPC (进程间通信)等非常少量的基础服务。<br>BSD 层可以看作围绕 Mach 层的一个外环，其提供了诸如进程管理、文件系统和网络等功能。<br>IOKit 层是为设备驱动提供了一个面向对象(C++)的一个框架。</p>\n<p>Mach 本身提供的 API 非常有限，而且苹果也不鼓励使用 Mach 的 API，但是这些API非常基础，如果没有这些API的话，其他任何工作都无法实施。在 Mach 中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为”对象”。和其他架构不同， Mach 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。”消息”是 Mach 中最基础的概念，消息在两个端口 (port) 之间传递，这就是 Mach 的 IPC (进程间通信) 的核心。</p>\n<p>Mach 的消息定义是在 &lt;mach&#x2F;message.h&gt;头文件的，很简单：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct &#123;</span><br><span class=\"line\">  mach_msg_header_t header;</span><br><span class=\"line\">  mach_msg_body_t body;</span><br><span class=\"line\">&#125; mach_msg_base_t;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct &#123;</span><br><span class=\"line\">  mach_msg_bits_t msgh_bits;</span><br><span class=\"line\">  mach_msg_size_t msgh_size;</span><br><span class=\"line\">  mach_port_t msgh_remote_port;</span><br><span class=\"line\">  mach_port_t msgh_local_port;</span><br><span class=\"line\">  mach_port_name_t msgh_voucher_port;</span><br><span class=\"line\">  mach_msg_id_t msgh_id;</span><br><span class=\"line\">&#125; mach_msg_header_t;</span><br></pre></td></tr></table></figure>\n\n<p>一条 Mach 消息实际上就是一个二进制数据包 (BLOB)，其头部定义了当前端口 local_port 和目标端口 remote_port，发送和接受消息是通过同一个 API 进行的，其 option 标记了消息传递的方向：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mach_msg_return_t mach_msg(</span><br><span class=\"line\">            mach_msg_header_t *msg,</span><br><span class=\"line\">            mach_msg_option_t option,</span><br><span class=\"line\">            mach_msg_size_t send_size,</span><br><span class=\"line\">            mach_msg_size_t rcv_size,</span><br><span class=\"line\">            mach_port_name_t rcv_name,</span><br><span class=\"line\">            mach_msg_timeout_t timeout,</span><br><span class=\"line\">            mach_port_name_t notify);</span><br></pre></td></tr></table></figure>\n\n<p>为了实现消息的发送和接收，mach_msg() 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数mach_msg_trap()，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 mach_msg_trap() 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg() 函数会完成实际的工作，</p>\n<p>RunLoop 的核心就是一个 mach_msg() (见上面代码的第7步)，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 mach_msg_trap() 这个地方。</p>\n<p>关于具体的如何利用 mach port 发送信息，可以看看<a href=\"http://nshipster.com/inter-process-communication/\">NSHipster 这一篇文章</a>，或者<a href=\"http://segmentfault.com/a/1190000002400329\">这里</a>的中文翻译 。</p>\n<p>关于Mach的历史可以看看这篇很有趣的文章：<a href=\"http://www.programmer.com.cn/8121/\">Mac OS X 背后的故事（三）Mach 之父 Avie Tevanian</a>。</p>\n<hr>\n<h1 id=\"苹果用-RunLoop-实现的功能\"><a href=\"#苹果用-RunLoop-实现的功能\" class=\"headerlink\" title=\"苹果用 RunLoop 实现的功能\"></a>苹果用 RunLoop 实现的功能</h1><p>首先我们可以看一下 App 启动后 RunLoop 的状态：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CFRunLoop &#123;</span><br><span class=\"line\">    current mode = kCFRunLoopDefaultMode</span><br><span class=\"line\">    common modes = &#123;</span><br><span class=\"line\">        UITrackingRunLoopMode</span><br><span class=\"line\">        kCFRunLoopDefaultMode</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    common mode items = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        // source0 (manual)</span><br><span class=\"line\">        CFRunLoopSource &#123;order =-1, &#123;</span><br><span class=\"line\">            callout = _UIApplicationHandleEventQueue&#125;&#125;</span><br><span class=\"line\">        CFRunLoopSource &#123;order =-1, &#123;</span><br><span class=\"line\">            callout = PurpleEventSignalCallback &#125;&#125;</span><br><span class=\"line\">        CFRunLoopSource &#123;order = 0, &#123;</span><br><span class=\"line\">            callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // source1 (mach port)</span><br><span class=\"line\">        CFRunLoopSource &#123;order = 0,  &#123;port = 17923&#125;&#125;</span><br><span class=\"line\">        CFRunLoopSource &#123;order = 0,  &#123;port = 12039&#125;&#125;</span><br><span class=\"line\">        CFRunLoopSource &#123;order = 0,  &#123;port = 16647&#125;&#125;</span><br><span class=\"line\">        CFRunLoopSource &#123;order =-1, &#123;</span><br><span class=\"line\">            callout = PurpleEventCallback&#125;&#125;</span><br><span class=\"line\">        CFRunLoopSource &#123;order = 0, &#123;port = 2407,</span><br><span class=\"line\">            callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125;</span><br><span class=\"line\">        CFRunLoopSource &#123;order = 0, &#123;port = 1c03,</span><br><span class=\"line\">            callout = __IOHIDEventSystemClientAvailabilityCallback&#125;&#125;</span><br><span class=\"line\">        CFRunLoopSource &#123;order = 0, &#123;port = 1b03,</span><br><span class=\"line\">            callout = __IOHIDEventSystemClientQueueCallback&#125;&#125;</span><br><span class=\"line\">        CFRunLoopSource &#123;order = 1, &#123;port = 1903,</span><br><span class=\"line\">            callout = __IOMIGMachPortPortCallback&#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // Ovserver</span><br><span class=\"line\">        CFRunLoopObserver &#123;order = -2147483647, activities = 0x1, // Entry</span><br><span class=\"line\">            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class=\"line\">        CFRunLoopObserver &#123;order = 0, activities = 0x20,          // BeforeWaiting</span><br><span class=\"line\">            callout = _UIGestureRecognizerUpdateObserver&#125;</span><br><span class=\"line\">        CFRunLoopObserver &#123;order = 1999000, activities = 0xa0,    // BeforeWaiting | Exit</span><br><span class=\"line\">            callout = _afterCACommitHandler&#125;</span><br><span class=\"line\">        CFRunLoopObserver &#123;order = 2000000, activities = 0xa0,    // BeforeWaiting | Exit</span><br><span class=\"line\">            callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br><span class=\"line\">        CFRunLoopObserver &#123;order = 2147483647, activities = 0xa0, // BeforeWaiting | Exit</span><br><span class=\"line\">            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // Timer</span><br><span class=\"line\">        CFRunLoopTimer &#123;firing = No, interval = 3.1536e+09, tolerance = 0,</span><br><span class=\"line\">            next fire date = 453098071 (-4421.76019 @ 96223387169499),</span><br><span class=\"line\">            callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    modes ＝ &#123;</span><br><span class=\"line\">        CFRunLoopMode  &#123;</span><br><span class=\"line\">            sources0 =  &#123; /* same as &#x27;common mode items&#x27; */ &#125;,</span><br><span class=\"line\">            sources1 =  &#123; /* same as &#x27;common mode items&#x27; */ &#125;,</span><br><span class=\"line\">            observers = &#123; /* same as &#x27;common mode items&#x27; */ &#125;,</span><br><span class=\"line\">            timers =    &#123; /* same as &#x27;common mode items&#x27; */ &#125;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        CFRunLoopMode  &#123;</span><br><span class=\"line\">            sources0 =  &#123; /* same as &#x27;common mode items&#x27; */ &#125;,</span><br><span class=\"line\">            sources1 =  &#123; /* same as &#x27;common mode items&#x27; */ &#125;,</span><br><span class=\"line\">            observers = &#123; /* same as &#x27;common mode items&#x27; */ &#125;,</span><br><span class=\"line\">            timers =    &#123; /* same as &#x27;common mode items&#x27; */ &#125;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        CFRunLoopMode  &#123;</span><br><span class=\"line\">            sources0 = &#123;</span><br><span class=\"line\">                CFRunLoopSource &#123;order = 0, &#123;</span><br><span class=\"line\">                    callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            sources1 = (null),</span><br><span class=\"line\">            observers = &#123;</span><br><span class=\"line\">                CFRunLoopObserver &gt;&#123;activities = 0xa0, order = 2000000,</span><br><span class=\"line\">                    callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br><span class=\"line\">            )&#125;,</span><br><span class=\"line\">            timers = (null),</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        CFRunLoopMode  &#123;</span><br><span class=\"line\">            sources0 = &#123;</span><br><span class=\"line\">                CFRunLoopSource &#123;order = -1, &#123;</span><br><span class=\"line\">                    callout = PurpleEventSignalCallback&#125;&#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            sources1 = &#123;</span><br><span class=\"line\">                CFRunLoopSource &#123;order = -1, &#123;</span><br><span class=\"line\">                    callout = PurpleEventCallback&#125;&#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            observers = (null),</span><br><span class=\"line\">            timers = (null),</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        CFRunLoopMode  &#123;</span><br><span class=\"line\">            sources0 = (null),</span><br><span class=\"line\">            sources1 = (null),</span><br><span class=\"line\">            observers = (null),</span><br><span class=\"line\">            timers = (null),</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，系统默认注册了5个Mode:</p>\n<ol>\n<li><p>kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。</p>\n</li>\n<li><p>UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</p>\n</li>\n<li><p>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。</p>\n</li>\n</ol>\n<p>4: GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。</p>\n<p>5: kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。</p>\n<p>你可以在<a href=\"http://iphonedevwiki.net/index.php/CFRunLoop\">这里</a>看到更多的苹果内部的 Mode，但那些 Mode 在开发中就很难遇到了。</p>\n<p>当 RunLoop 进行回调时，一般都是通过一个很长的函数调用出去 (call out), 当你在你的代码中下断点调试时，通常能在调用栈上看到这些函数。下面是这几个函数的整理版本，如果你在调用栈中看到这些长函数名，在这里查找一下就能定位到具体的调用地点了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    /// 1. 通知Observers，即将进入RunLoop</span><br><span class=\"line\">    /// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();</span><br><span class=\"line\">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry);</span><br><span class=\"line\">    do &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        /// 2. 通知 Observers: 即将触发 Timer 回调。</span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers);</span><br><span class=\"line\">        /// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。</span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources);</span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</span><br><span class=\"line\"></span><br><span class=\"line\">        /// 4. 触发 Source0 (非基于port的) 回调。</span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0);</span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</span><br><span class=\"line\"></span><br><span class=\"line\">        /// 6. 通知Observers，即将进入休眠</span><br><span class=\"line\">        /// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();</span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting);</span><br><span class=\"line\"></span><br><span class=\"line\">        /// 7. sleep to wait msg.</span><br><span class=\"line\">        mach_msg() -&gt; mach_msg_trap();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        /// 8. 通知Observers，线程被唤醒</span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting);</span><br><span class=\"line\"></span><br><span class=\"line\">        /// 9. 如果是被Timer唤醒的，回调Timer</span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer);</span><br><span class=\"line\"></span><br><span class=\"line\">        /// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block</span><br><span class=\"line\">        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block);</span><br><span class=\"line\"></span><br><span class=\"line\">        /// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件</span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; while (...);</span><br><span class=\"line\"></span><br><span class=\"line\">    /// 10. 通知Observers，即将退出RunLoop</span><br><span class=\"line\">    /// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();</span><br><span class=\"line\">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"AutoreleasePool\"><a href=\"#AutoreleasePool\" class=\"headerlink\" title=\"AutoreleasePool\"></a>AutoreleasePool</h1><p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p>\n<p>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p>\n<p>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p>\n<p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p>\n<hr>\n<h1 id=\"事件响应\"><a href=\"#事件响应\" class=\"headerlink\" title=\"事件响应\"></a>事件响应</h1><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。</p>\n<p>当一个硬件事件(触摸&#x2F;锁屏&#x2F;摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考<a href=\"http://iphonedevwiki.net/index.php/IOHIDFamily\">这里</a>。SpringBoard 只接收按键(锁屏&#x2F;静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。</p>\n<p>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture&#x2F;处理屏幕旋转&#x2F;发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin&#x2F;Move&#x2F;End&#x2F;Cancel 事件都是在这个回调中完成的。</p>\n<hr>\n<h1 id=\"手势识别\"><a href=\"#手势识别\" class=\"headerlink\" title=\"手势识别\"></a>手势识别</h1><p>当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin&#x2F;Move&#x2F;End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p>\n<p>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。</p>\n<p>当有 UIGestureRecognizer 的变化(创建&#x2F;销毁&#x2F;状态改变)时，这个回调都会进行相应处理。</p>\n<hr>\n<h1 id=\"界面更新\"><a href=\"#界面更新\" class=\"headerlink\" title=\"界面更新\"></a>界面更新</h1><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView&#x2F;CALayer 的层次时，或者手动调用了 UIView&#x2F;CALayer 的 setNeedsLayout&#x2F;setNeedsDisplay方法后，这个 UIView&#x2F;CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p>\n<p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：<br>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView&#x2F;CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p>\n<p>这个函数内部的调用栈大概是这样的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</span><br><span class=\"line\">    QuartzCore:CA::Transaction::observer_callback:</span><br><span class=\"line\">        CA::Transaction::commit();</span><br><span class=\"line\">            CA::Context::commit_transaction();</span><br><span class=\"line\">                CA::Layer::layout_and_display_if_needed();</span><br><span class=\"line\">                    CA::Layer::layout_if_needed();</span><br><span class=\"line\">                        [CALayer layoutSublayers];</span><br><span class=\"line\">                            [UIView layoutSubviews];</span><br><span class=\"line\">                    CA::Layer::display_if_needed();</span><br><span class=\"line\">                        [CALayer display];</span><br><span class=\"line\">                            [UIView drawRect];</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"定时器\"><a href=\"#定时器\" class=\"headerlink\" title=\"定时器\"></a>定时器</h1><p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p>\n<p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p>\n<p>CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。</p>\n<hr>\n<h1 id=\"PerformSelecter\"><a href=\"#PerformSelecter\" class=\"headerlink\" title=\"PerformSelecter\"></a>PerformSelecter</h1><p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p>\n<p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p>\n<hr>\n<h1 id=\"GCD\"><a href=\"#GCD\" class=\"headerlink\" title=\"GCD\"></a>GCD</h1><p>实际上 RunLoop 底层也会用到 GCD 的东西，<del>比如 RunLoop 是用 dispatch_source_t 实现的 Timer</del>（评论中有人提醒，NSTimer 是用了 XNU 内核的 mk_timer，我也仔细调试了一下，发现 NSTimer 确实是由 mk_timer 驱动，而非 GCD 驱动的）。但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。</p>\n<p>当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p>\n<hr>\n<h1 id=\"网络请求\"><a href=\"#网络请求\" class=\"headerlink\" title=\"网络请求\"></a>网络请求</h1><p>iOS 中，关于网络请求的接口自下至上有如下几层:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CFSocket</span><br><span class=\"line\">CFNetwork       -&gt;ASIHttpRequest</span><br><span class=\"line\">NSURLConnection -&gt;AFNetworking</span><br><span class=\"line\">NSURLSession    -&gt;AFNetworking2, Alamofire</span><br></pre></td></tr></table></figure>\n\n<p>CFSocket 是最底层的接口，只负责 socket 通信。</p>\n<ul>\n<li>CFNetwork 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作于这一层。</li>\n<li>NSURLConnection 是基于 CFNetwork 的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层。</li>\n<li>NSURLSession 是 iOS7 中新增的接口，表面上是和 NSURLConnection 并列的，但底层仍然用到了 NSURLConnection 的部分功能 (比如 com.apple.NSURLConnectionLoader 线程)，AFNetworking2 和 Alamofire 工作于这一层。</li>\n</ul>\n<p>下面主要介绍下 NSURLConnection 的工作过程。</p>\n<p>通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。</p>\n<p>当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。</p>\n<p><img src=\"/2018/04/20/iOS%E5%BA%95%E5%B1%82%E4%B9%8BRunLoop/RunLoop_network.png\">NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。</p>\n","site":{"data":{}},"length":20276,"excerpt":"<p>runloop在iOS开发中是一个十分基础的概念，本文将从CFRunLoop入手，介绍runloop的概念和底层实现原理。然后介绍Apple是如何通过runloop在处理一些列的触摸事件和方法回调以及自动释放池等功能的。文中部分内容来自<a href=\"http://blog.ibireme.com/2015/05/18/runloop/\">此博客</a>。</p>","more":"<hr>\n<h1 id=\"RunLoop的概念\"><a href=\"#RunLoop的概念\" class=\"headerlink\" title=\"RunLoop的概念\"></a>RunLoop的概念</h1><p>一般来讲，一个线程一次只能执行一次任务，任务完成之后线程就会退出，但是如果一种这种机制，让一条线程既能处理事件又不退出，通常会设置一个无线的死循环，让这条线程在里面跑而不退出，一般的代码可以这样写：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function loop() &#123;</span><br><span class=\"line\">    initialize();</span><br><span class=\"line\">    do &#123;</span><br><span class=\"line\">        var message = get_next_message();</span><br><span class=\"line\">        process_message(message);</span><br><span class=\"line\">    &#125; while (message != quit);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面这种模型我们通常称之为event loop。这种事件的处理模型在很多开发中都有，比如安卓开发中也有类似的loop循环，Windows的程序的循环消息，iOS&#x2F;OSX的runloop等等。</p>\n<p>所以runloop实际上也是一个对象，这个对象处理了很多东西，触摸事件和方法回调，并提供一个入口函数来执行event loop逻辑，线程执行完毕之后会一直处于“接收消息 - 等待 - 处理”的循环之中，直到这个循环结束，函数返回。</p>\n<p>在iOS&#x2F;OSX中提供了两种这样的对象：NSRunLoop和CFRunLoopRef。其中NSRunLoop是基于CFRunLoopRef的第二层封装，更加面向对象，但是NSRunLoop的API的线程是不安全的。</p>\n<p>而CFRunLoopRef是在CoreFoundation的框架内的，它提供了纯C语言的API，所以这些API的线程是安全的。CFRunLoopRef 的代码是<a href=\"http://opensource.apple.com/source/CF/CF-855.17/CFRunLoop.c\">开源</a>的，你可以在这里<a href=\"http://opensource.apple.com/tarballs/CF/\">http://opensource.apple.com/tarballs/CF/</a>下载到整个CoreFoundation 的源码来查看。</p>\n<hr>\n<h1 id=\"RunLoop与线程的关系\"><a href=\"#RunLoop与线程的关系\" class=\"headerlink\" title=\"RunLoop与线程的关系\"></a>RunLoop与线程的关系</h1><p>线程和RunLoop是一一对应的关系，每一条线程都有与之对应的RunLoop，主线程的RunLoop是在程序启动时就已经开启，而其他线程在被创建时并不会开启RunLoop，如果子线程不主动去开启RunLoop，那他将一直不会有。RunLoop的创建发生在第一次获取时，销毁时发生在线程结束时。只能在一条线程内部获取其RunLoop。</p>\n<hr>\n<h1 id=\"RunLoop对外的接口\"><a href=\"#RunLoop对外的接口\" class=\"headerlink\" title=\"RunLoop对外的接口\"></a>RunLoop对外的接口</h1><p>在CoreFoundation框架中，提供了RunLoop的5种类：</p>\n<ul>\n<li>CFRunLoopRef</li>\n<li>CFRunLoopModeRef</li>\n<li>CFRunLoopSourceRef</li>\n<li>CFRunLoopTimerRef</li>\n</ul>\n<h2 id=\"CFRunLoopModeRef\"><a href=\"#CFRunLoopModeRef\" class=\"headerlink\" title=\"CFRunLoopModeRef\"></a>CFRunLoopModeRef</h2><p>其中，CFRunLoopModeRef并没有对外暴露接口，只是通过CFRunLoopRef对其接口进行封装，其关系如下：</p>\n<p><img src=\"/2018/04/20/iOS%E5%BA%95%E5%B1%82%E4%B9%8BRunLoop/RunLoop_0.png\"></p>\n<p>一个RunLoop的包含若干个Mode，每个Mode又包含若干个source&#x2F;timer&#x2F;observer，每次调用RunLoop的主函数时，只能指定其中一个Mode，而这个Mode又被称之为currentMode。如果需要切换Mode只能退出当前的loop再重新指定一个Mode进入。这样做的目的是为了分隔开不同的source&#x2F;timer&#x2F;observer，让其相互之间互不影响。</p>\n<h2 id=\"CFRunLoopSourceRef\"><a href=\"#CFRunLoopSourceRef\" class=\"headerlink\" title=\"CFRunLoopSourceRef\"></a>CFRunLoopSourceRef</h2><p>CFRunLoopSourceRef是事件产生的地方。source主要有2个版本：source0和source1，</p>\n<ul>\n<li>Source0 只包含了一个函数指针的回调，它并不能主动触发事件。使用时，你需要先调用CFRunLoopSourceSignal(source)，将这个Source标记为待处理，然后手动调用CFRunLoopWakeUp(runloop)来唤醒RunLoop，让其处理这个事件。</li>\n<li>Source1 包含了 一个mach_port和一个函数的回调指针，被用于通过内核和其他线程相互发送消息。source1可以主动唤醒RunLoop的线程。</li>\n</ul>\n<h3 id=\"CFRunLoopTimerRef\"><a href=\"#CFRunLoopTimerRef\" class=\"headerlink\" title=\"CFRunLoopTimerRef\"></a>CFRunLoopTimerRef</h3><p>CFRunLoopTimerRef是基于时间的触时发器，它和NSTimer可以混用。其中包含了一个时间的长度和一个函数的指针回调。当加入RunLoop时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行此回调。</p>\n<blockquote>\n<p>这里补充一个知识点，就是为什么NSTimer会不准的原因</p>\n<p>首先我们知道，NSTimer是基于toll-free bridged的，严格来说NSTimer不是一个基于真实时间的机制，NSTimer被触发需要满足以下3个条件，</p>\n<p>第一、NSTimer被添加到指定的RunLoop的Mode中；</p>\n<p>第二、该Mode在RunLoop中正在运行；</p>\n<p>第三、达到触发的时间，因为RunLoop需要管理大量的资源，为了提高NSTimer的效率，时间的间隔被限制为50-100毫秒比较合理，直到下一次RunLoop检测到NSTimer才会被触发</p>\n<p>在苹果开发者文档中可以查看到，<a href=\"https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-131281\">参考</a></p>\n<p>即使NSTimer会基于时间发出通知，但是由于NSTimer不是一个基于真实时间的机制。和输入源一样，timer和指定Mode的RunLoop紧密相连。如果没有被当前的Mode的RunLoop监测到，timer就不会被触发，直到timer指定的Mode的RunLoop运行时才会被触发。类似的，当timer被触发的时间达到，而RunLoop却又恰好正在执行一个handler句柄，那么timer就不会被触发，而是等到下次的触发时间点通过RunLoop来唤醒timer执行回调操作。如果RunLoop不再运行，那么timer就永远不会被触发</p>\n</blockquote>\n<h3 id=\"CFRunLoopObserverRef\"><a href=\"#CFRunLoopObserverRef\" class=\"headerlink\" title=\"CFRunLoopObserverRef\"></a>CFRunLoopObserverRef</h3><p>CFRunLoopObserverRef是RunLoop的观察者，每一个Observer都包含一个回调的函数指针，当RunLoop的状态发生变化时，观察者j就能通过回调接收到这个变化，在CFRunLoopRef的源码中，可以发现观察RunLoop的还时间点主要有以下几种：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class=\"line\">    kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入Loop</span><br><span class=\"line\">    kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 Timer</span><br><span class=\"line\">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source</span><br><span class=\"line\">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠</span><br><span class=\"line\">    kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒</span><br><span class=\"line\">    kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出Loop</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>上面的Source&#x2F;Timer&#x2F;Observer被统称为Mode item，一个item可以同时加入多个Mode，但是一个item被重复加入同一个Mode将不会有效果。如果一个Mode中不包含其中任何一个item则RunLoop会直接退出，不再循环。</p>\n<hr>\n<h2 id=\"RunLoop的Mode\"><a href=\"#RunLoop的Mode\" class=\"headerlink\" title=\"RunLoop的Mode\"></a>RunLoop的Mode</h2><p>CFRunLoopMode和CFRunLoop的结构大致如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct __CFRunLoopMode &#123;</span><br><span class=\"line\">    CFStringRef _name;            // Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot;</span><br><span class=\"line\">    CFMutableSetRef _sources0;    // Set</span><br><span class=\"line\">    CFMutableSetRef _sources1;    // Set</span><br><span class=\"line\">    CFMutableArrayRef _observers; // Array</span><br><span class=\"line\">    CFMutableArrayRef _timers;    // Array</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">struct __CFRunLoop &#123;</span><br><span class=\"line\">    CFMutableSetRef _commonModes;     // Set</span><br><span class=\"line\">    CFMutableSetRef _commonModeItems; // Set&lt;Source/Observer/Timer&gt;</span><br><span class=\"line\">    CFRunLoopModeRef _currentMode;    // Current Runloop Mode</span><br><span class=\"line\">    CFMutableSetRef _modes;           // Set</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>此处有个概念叫“CommonModes”：一个Mode可以将自己标记为“Common”属性（通过将它的ModeName添加到RunLoop的commonModes中）。每个RunLoop的内容发生变化时，RunLoop都会自动将_commonModeItems里的Source&#x2F;Observer&#x2F;Timer同步到具有common标记的Mode里。</p>\n<p>例如：主线程的RunLoop里面有两个预置的Mode，即kCFRunLoopDefaultMode和UITrackingRunLoopMode。这两个Mode都已经被标记为common属性。defaultMode是APP平时所处的状态，TrackingRunLoopMode是已经追到ScrollView的滑动时的状态。当你创建一个Timer，并且添加到DefaultMode时，timer会得到重复的回调，但当此时滑动一个tableview或者scrollview时，RunLoop会将Mode切换为trackingRunLoopMode，此时这个timer将不会再被回调，并且也不会影响到滑动的操作。</p>\n<p>所以，有时候你需要一个timer，在这两种Mode之间回调，一种办法就是将这个timer分别加入到这两种Mode。另外一种方式就是将这个timer加入到顶层的RunLoop的commonModeitems中。这个commonModeItems将会被更新到所有具有common的标记的属性的Mode中。</p>\n<p>CFRunLoop对外暴露的接口只有以下2个：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);</span><br><span class=\"line\">CFRunLoopRunInMode(CFStringRef modeName, ...);</span><br></pre></td></tr></table></figure>\n\n<p>Mode 暴露的管理 mode item 的接口有下面几个：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</span><br><span class=\"line\">CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</span><br><span class=\"line\">CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</span><br><span class=\"line\">CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</span><br><span class=\"line\">CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</span><br><span class=\"line\">CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</span><br></pre></td></tr></table></figure>\n\n<p>你只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop会自动帮你创建对应的 CFRunLoopModeRef。对于一个 RunLoop 来说，其内部的 mode 只能增加不能删除。</p>\n<p>苹果公开提供的 Mode 有两个：kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 和 UITrackingRunLoopMode，你可以用这两个 Mode Name 来操作其对应的 Mode。</p>\n<p>同时苹果还提供了一个操作 Common 标记的字符串：kCFRunLoopCommonModes (NSRunLoopCommonModes)，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common”。使用时注意区分这个字符串和其他 mode name。</p>\n<hr>\n<h1 id=\"RunLoop-的内部逻辑\"><a href=\"#RunLoop-的内部逻辑\" class=\"headerlink\" title=\"RunLoop 的内部逻辑\"></a>RunLoop 的内部逻辑</h1><p>根据苹果在<a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW23\">文档</a>里的说明，RunLoop 内部的逻辑大致如下:</p>\n<p><img src=\"/2018/04/20/iOS%E5%BA%95%E5%B1%82%E4%B9%8BRunLoop/RunLoop_1.png\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/// 用DefaultMode启动</span><br><span class=\"line\">void CFRunLoopRun(void) &#123;</span><br><span class=\"line\">    CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/// 用指定的Mode启动，允许设置RunLoop超时时间</span><br><span class=\"line\">int CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) &#123;</span><br><span class=\"line\">    return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/// RunLoop的实现</span><br><span class=\"line\">int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /// 首先根据modeName找到对应mode</span><br><span class=\"line\">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false);</span><br><span class=\"line\">    /// 如果mode里没有source/timer/observer, 直接返回。</span><br><span class=\"line\">    if (__CFRunLoopModeIsEmpty(currentMode)) return;</span><br><span class=\"line\"></span><br><span class=\"line\">    /// 1. 通知 Observers: RunLoop 即将进入 loop。</span><br><span class=\"line\">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);</span><br><span class=\"line\"></span><br><span class=\"line\">    /// 内部函数，进入loop</span><br><span class=\"line\">    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Boolean sourceHandledThisLoop = NO;</span><br><span class=\"line\">        int retVal = 0;</span><br><span class=\"line\">        do &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            /// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span><br><span class=\"line\">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</span><br><span class=\"line\">            /// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span><br><span class=\"line\">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</span><br><span class=\"line\">            /// 执行被加入的block</span><br><span class=\"line\">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class=\"line\"></span><br><span class=\"line\">            /// 4. RunLoop 触发 Source0 (非port) 回调。</span><br><span class=\"line\">            sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);</span><br><span class=\"line\">            /// 执行被加入的block</span><br><span class=\"line\">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class=\"line\"></span><br><span class=\"line\">            /// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span><br><span class=\"line\">            if (__Source0DidDispatchPortLastTime) &#123;</span><br><span class=\"line\">                Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)</span><br><span class=\"line\">                if (hasMsg) goto handle_msg;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            /// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span><br><span class=\"line\">            if (!sourceHandledThisLoop) &#123;</span><br><span class=\"line\">                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            /// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span><br><span class=\"line\">            /// • 一个基于 port 的Source 的事件。</span><br><span class=\"line\">            /// • 一个 Timer 到时间了</span><br><span class=\"line\">            /// • RunLoop 自身的超时时间到了</span><br><span class=\"line\">            /// • 被其他什么调用者手动唤醒</span><br><span class=\"line\">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123;</span><br><span class=\"line\">                mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            /// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span><br><span class=\"line\">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</span><br><span class=\"line\"></span><br><span class=\"line\">            /// 收到消息，处理消息。</span><br><span class=\"line\">            handle_msg:</span><br><span class=\"line\"></span><br><span class=\"line\">            /// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span><br><span class=\"line\">            if (msg_is_timer) &#123;</span><br><span class=\"line\">                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">            /// 9.2 如果有dispatch到main_queue的block，执行block。</span><br><span class=\"line\">            else if (msg_is_dispatch) &#123;</span><br><span class=\"line\">                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">            /// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span><br><span class=\"line\">            else &#123;</span><br><span class=\"line\">                CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</span><br><span class=\"line\">                sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);</span><br><span class=\"line\">                if (sourceHandledThisLoop) &#123;</span><br><span class=\"line\">                    mach_msg(reply, MACH_SEND_MSG, reply);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            /// 执行加入到Loop的block</span><br><span class=\"line\">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">            if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class=\"line\">                /// 进入loop时参数说处理完事件就返回。</span><br><span class=\"line\">                retVal = kCFRunLoopRunHandledSource;</span><br><span class=\"line\">            &#125; else if (timeout) &#123;</span><br><span class=\"line\">                /// 超出传入参数标记的超时时间了</span><br><span class=\"line\">                retVal = kCFRunLoopRunTimedOut;</span><br><span class=\"line\">            &#125; else if (__CFRunLoopIsStopped(runloop)) &#123;</span><br><span class=\"line\">                /// 被外部调用者强制停止了</span><br><span class=\"line\">                retVal = kCFRunLoopRunStopped;</span><br><span class=\"line\">            &#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</span><br><span class=\"line\">                /// source/timer/observer一个都没有了</span><br><span class=\"line\">                retVal = kCFRunLoopRunFinished;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            /// 如果没超时，mode里没空，loop也没被停止，那继续loop。</span><br><span class=\"line\">        &#125; while (retVal == 0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /// 10. 通知 Observers: RunLoop 即将退出。</span><br><span class=\"line\">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。</p>\n<hr>\n<h1 id=\"RunLoop-的底层实现\"><a href=\"#RunLoop-的底层实现\" class=\"headerlink\" title=\"RunLoop 的底层实现\"></a>RunLoop 的底层实现</h1><p>从上面代码可以看到，RunLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 mach_msg()。为了解释这个逻辑，下面稍微介绍一下 OSX&#x2F;iOS 的系统架构。</p>\n<p><img src=\"/2018/04/20/iOS%E5%BA%95%E5%B1%82%E4%B9%8BRunLoop/RunLoop_3.png\"></p>\n<p>苹果官方将整个系统大致划分为上述4个层次：<br>应用层包括用户能接触到的图形应用，例如 Spotlight、Aqua、SpringBoard 等。<br>应用框架层即开发人员接触到的 Cocoa 等框架。<br>核心框架层包括各种核心框架、OpenGL 等内容。<br>Darwin 即操作系统的核心，包括系统内核、驱动、Shell 等内容，这一层是开源的，其所有源码都可以在<a href=\"http://opensource.apple.com/\">opensource.apple.com</a>里找到。</p>\n<p>我们在深入看一下 Darwin 这个核心的架构：</p>\n<p><img src=\"/2018/04/20/iOS%E5%BA%95%E5%B1%82%E4%B9%8BRunLoop/RunLoop_4.png\"></p>\n<p>其中，在硬件层上面的三个组成部分：Mach、BSD、IOKit (还包括一些上面没标注的内容)，共同组成了 XNU 内核。<br>XNU 内核的内环被称作 Mach，其作为一个微内核，仅提供了诸如处理器调度、IPC (进程间通信)等非常少量的基础服务。<br>BSD 层可以看作围绕 Mach 层的一个外环，其提供了诸如进程管理、文件系统和网络等功能。<br>IOKit 层是为设备驱动提供了一个面向对象(C++)的一个框架。</p>\n<p>Mach 本身提供的 API 非常有限，而且苹果也不鼓励使用 Mach 的 API，但是这些API非常基础，如果没有这些API的话，其他任何工作都无法实施。在 Mach 中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为”对象”。和其他架构不同， Mach 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。”消息”是 Mach 中最基础的概念，消息在两个端口 (port) 之间传递，这就是 Mach 的 IPC (进程间通信) 的核心。</p>\n<p>Mach 的消息定义是在 &lt;mach&#x2F;message.h&gt;头文件的，很简单：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct &#123;</span><br><span class=\"line\">  mach_msg_header_t header;</span><br><span class=\"line\">  mach_msg_body_t body;</span><br><span class=\"line\">&#125; mach_msg_base_t;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct &#123;</span><br><span class=\"line\">  mach_msg_bits_t msgh_bits;</span><br><span class=\"line\">  mach_msg_size_t msgh_size;</span><br><span class=\"line\">  mach_port_t msgh_remote_port;</span><br><span class=\"line\">  mach_port_t msgh_local_port;</span><br><span class=\"line\">  mach_port_name_t msgh_voucher_port;</span><br><span class=\"line\">  mach_msg_id_t msgh_id;</span><br><span class=\"line\">&#125; mach_msg_header_t;</span><br></pre></td></tr></table></figure>\n\n<p>一条 Mach 消息实际上就是一个二进制数据包 (BLOB)，其头部定义了当前端口 local_port 和目标端口 remote_port，发送和接受消息是通过同一个 API 进行的，其 option 标记了消息传递的方向：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mach_msg_return_t mach_msg(</span><br><span class=\"line\">            mach_msg_header_t *msg,</span><br><span class=\"line\">            mach_msg_option_t option,</span><br><span class=\"line\">            mach_msg_size_t send_size,</span><br><span class=\"line\">            mach_msg_size_t rcv_size,</span><br><span class=\"line\">            mach_port_name_t rcv_name,</span><br><span class=\"line\">            mach_msg_timeout_t timeout,</span><br><span class=\"line\">            mach_port_name_t notify);</span><br></pre></td></tr></table></figure>\n\n<p>为了实现消息的发送和接收，mach_msg() 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数mach_msg_trap()，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 mach_msg_trap() 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg() 函数会完成实际的工作，</p>\n<p>RunLoop 的核心就是一个 mach_msg() (见上面代码的第7步)，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 mach_msg_trap() 这个地方。</p>\n<p>关于具体的如何利用 mach port 发送信息，可以看看<a href=\"http://nshipster.com/inter-process-communication/\">NSHipster 这一篇文章</a>，或者<a href=\"http://segmentfault.com/a/1190000002400329\">这里</a>的中文翻译 。</p>\n<p>关于Mach的历史可以看看这篇很有趣的文章：<a href=\"http://www.programmer.com.cn/8121/\">Mac OS X 背后的故事（三）Mach 之父 Avie Tevanian</a>。</p>\n<hr>\n<h1 id=\"苹果用-RunLoop-实现的功能\"><a href=\"#苹果用-RunLoop-实现的功能\" class=\"headerlink\" title=\"苹果用 RunLoop 实现的功能\"></a>苹果用 RunLoop 实现的功能</h1><p>首先我们可以看一下 App 启动后 RunLoop 的状态：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CFRunLoop &#123;</span><br><span class=\"line\">    current mode = kCFRunLoopDefaultMode</span><br><span class=\"line\">    common modes = &#123;</span><br><span class=\"line\">        UITrackingRunLoopMode</span><br><span class=\"line\">        kCFRunLoopDefaultMode</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    common mode items = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        // source0 (manual)</span><br><span class=\"line\">        CFRunLoopSource &#123;order =-1, &#123;</span><br><span class=\"line\">            callout = _UIApplicationHandleEventQueue&#125;&#125;</span><br><span class=\"line\">        CFRunLoopSource &#123;order =-1, &#123;</span><br><span class=\"line\">            callout = PurpleEventSignalCallback &#125;&#125;</span><br><span class=\"line\">        CFRunLoopSource &#123;order = 0, &#123;</span><br><span class=\"line\">            callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // source1 (mach port)</span><br><span class=\"line\">        CFRunLoopSource &#123;order = 0,  &#123;port = 17923&#125;&#125;</span><br><span class=\"line\">        CFRunLoopSource &#123;order = 0,  &#123;port = 12039&#125;&#125;</span><br><span class=\"line\">        CFRunLoopSource &#123;order = 0,  &#123;port = 16647&#125;&#125;</span><br><span class=\"line\">        CFRunLoopSource &#123;order =-1, &#123;</span><br><span class=\"line\">            callout = PurpleEventCallback&#125;&#125;</span><br><span class=\"line\">        CFRunLoopSource &#123;order = 0, &#123;port = 2407,</span><br><span class=\"line\">            callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125;</span><br><span class=\"line\">        CFRunLoopSource &#123;order = 0, &#123;port = 1c03,</span><br><span class=\"line\">            callout = __IOHIDEventSystemClientAvailabilityCallback&#125;&#125;</span><br><span class=\"line\">        CFRunLoopSource &#123;order = 0, &#123;port = 1b03,</span><br><span class=\"line\">            callout = __IOHIDEventSystemClientQueueCallback&#125;&#125;</span><br><span class=\"line\">        CFRunLoopSource &#123;order = 1, &#123;port = 1903,</span><br><span class=\"line\">            callout = __IOMIGMachPortPortCallback&#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // Ovserver</span><br><span class=\"line\">        CFRunLoopObserver &#123;order = -2147483647, activities = 0x1, // Entry</span><br><span class=\"line\">            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class=\"line\">        CFRunLoopObserver &#123;order = 0, activities = 0x20,          // BeforeWaiting</span><br><span class=\"line\">            callout = _UIGestureRecognizerUpdateObserver&#125;</span><br><span class=\"line\">        CFRunLoopObserver &#123;order = 1999000, activities = 0xa0,    // BeforeWaiting | Exit</span><br><span class=\"line\">            callout = _afterCACommitHandler&#125;</span><br><span class=\"line\">        CFRunLoopObserver &#123;order = 2000000, activities = 0xa0,    // BeforeWaiting | Exit</span><br><span class=\"line\">            callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br><span class=\"line\">        CFRunLoopObserver &#123;order = 2147483647, activities = 0xa0, // BeforeWaiting | Exit</span><br><span class=\"line\">            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // Timer</span><br><span class=\"line\">        CFRunLoopTimer &#123;firing = No, interval = 3.1536e+09, tolerance = 0,</span><br><span class=\"line\">            next fire date = 453098071 (-4421.76019 @ 96223387169499),</span><br><span class=\"line\">            callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    modes ＝ &#123;</span><br><span class=\"line\">        CFRunLoopMode  &#123;</span><br><span class=\"line\">            sources0 =  &#123; /* same as &#x27;common mode items&#x27; */ &#125;,</span><br><span class=\"line\">            sources1 =  &#123; /* same as &#x27;common mode items&#x27; */ &#125;,</span><br><span class=\"line\">            observers = &#123; /* same as &#x27;common mode items&#x27; */ &#125;,</span><br><span class=\"line\">            timers =    &#123; /* same as &#x27;common mode items&#x27; */ &#125;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        CFRunLoopMode  &#123;</span><br><span class=\"line\">            sources0 =  &#123; /* same as &#x27;common mode items&#x27; */ &#125;,</span><br><span class=\"line\">            sources1 =  &#123; /* same as &#x27;common mode items&#x27; */ &#125;,</span><br><span class=\"line\">            observers = &#123; /* same as &#x27;common mode items&#x27; */ &#125;,</span><br><span class=\"line\">            timers =    &#123; /* same as &#x27;common mode items&#x27; */ &#125;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        CFRunLoopMode  &#123;</span><br><span class=\"line\">            sources0 = &#123;</span><br><span class=\"line\">                CFRunLoopSource &#123;order = 0, &#123;</span><br><span class=\"line\">                    callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            sources1 = (null),</span><br><span class=\"line\">            observers = &#123;</span><br><span class=\"line\">                CFRunLoopObserver &gt;&#123;activities = 0xa0, order = 2000000,</span><br><span class=\"line\">                    callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br><span class=\"line\">            )&#125;,</span><br><span class=\"line\">            timers = (null),</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        CFRunLoopMode  &#123;</span><br><span class=\"line\">            sources0 = &#123;</span><br><span class=\"line\">                CFRunLoopSource &#123;order = -1, &#123;</span><br><span class=\"line\">                    callout = PurpleEventSignalCallback&#125;&#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            sources1 = &#123;</span><br><span class=\"line\">                CFRunLoopSource &#123;order = -1, &#123;</span><br><span class=\"line\">                    callout = PurpleEventCallback&#125;&#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            observers = (null),</span><br><span class=\"line\">            timers = (null),</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        CFRunLoopMode  &#123;</span><br><span class=\"line\">            sources0 = (null),</span><br><span class=\"line\">            sources1 = (null),</span><br><span class=\"line\">            observers = (null),</span><br><span class=\"line\">            timers = (null),</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，系统默认注册了5个Mode:</p>\n<ol>\n<li><p>kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。</p>\n</li>\n<li><p>UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</p>\n</li>\n<li><p>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。</p>\n</li>\n</ol>\n<p>4: GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。</p>\n<p>5: kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。</p>\n<p>你可以在<a href=\"http://iphonedevwiki.net/index.php/CFRunLoop\">这里</a>看到更多的苹果内部的 Mode，但那些 Mode 在开发中就很难遇到了。</p>\n<p>当 RunLoop 进行回调时，一般都是通过一个很长的函数调用出去 (call out), 当你在你的代码中下断点调试时，通常能在调用栈上看到这些函数。下面是这几个函数的整理版本，如果你在调用栈中看到这些长函数名，在这里查找一下就能定位到具体的调用地点了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    /// 1. 通知Observers，即将进入RunLoop</span><br><span class=\"line\">    /// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();</span><br><span class=\"line\">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry);</span><br><span class=\"line\">    do &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        /// 2. 通知 Observers: 即将触发 Timer 回调。</span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers);</span><br><span class=\"line\">        /// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。</span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources);</span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</span><br><span class=\"line\"></span><br><span class=\"line\">        /// 4. 触发 Source0 (非基于port的) 回调。</span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0);</span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</span><br><span class=\"line\"></span><br><span class=\"line\">        /// 6. 通知Observers，即将进入休眠</span><br><span class=\"line\">        /// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();</span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting);</span><br><span class=\"line\"></span><br><span class=\"line\">        /// 7. sleep to wait msg.</span><br><span class=\"line\">        mach_msg() -&gt; mach_msg_trap();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        /// 8. 通知Observers，线程被唤醒</span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting);</span><br><span class=\"line\"></span><br><span class=\"line\">        /// 9. 如果是被Timer唤醒的，回调Timer</span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer);</span><br><span class=\"line\"></span><br><span class=\"line\">        /// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block</span><br><span class=\"line\">        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block);</span><br><span class=\"line\"></span><br><span class=\"line\">        /// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件</span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; while (...);</span><br><span class=\"line\"></span><br><span class=\"line\">    /// 10. 通知Observers，即将退出RunLoop</span><br><span class=\"line\">    /// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();</span><br><span class=\"line\">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"AutoreleasePool\"><a href=\"#AutoreleasePool\" class=\"headerlink\" title=\"AutoreleasePool\"></a>AutoreleasePool</h1><p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p>\n<p>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p>\n<p>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p>\n<p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p>\n<hr>\n<h1 id=\"事件响应\"><a href=\"#事件响应\" class=\"headerlink\" title=\"事件响应\"></a>事件响应</h1><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。</p>\n<p>当一个硬件事件(触摸&#x2F;锁屏&#x2F;摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考<a href=\"http://iphonedevwiki.net/index.php/IOHIDFamily\">这里</a>。SpringBoard 只接收按键(锁屏&#x2F;静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。</p>\n<p>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture&#x2F;处理屏幕旋转&#x2F;发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin&#x2F;Move&#x2F;End&#x2F;Cancel 事件都是在这个回调中完成的。</p>\n<hr>\n<h1 id=\"手势识别\"><a href=\"#手势识别\" class=\"headerlink\" title=\"手势识别\"></a>手势识别</h1><p>当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin&#x2F;Move&#x2F;End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p>\n<p>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。</p>\n<p>当有 UIGestureRecognizer 的变化(创建&#x2F;销毁&#x2F;状态改变)时，这个回调都会进行相应处理。</p>\n<hr>\n<h1 id=\"界面更新\"><a href=\"#界面更新\" class=\"headerlink\" title=\"界面更新\"></a>界面更新</h1><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView&#x2F;CALayer 的层次时，或者手动调用了 UIView&#x2F;CALayer 的 setNeedsLayout&#x2F;setNeedsDisplay方法后，这个 UIView&#x2F;CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p>\n<p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：<br>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView&#x2F;CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p>\n<p>这个函数内部的调用栈大概是这样的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</span><br><span class=\"line\">    QuartzCore:CA::Transaction::observer_callback:</span><br><span class=\"line\">        CA::Transaction::commit();</span><br><span class=\"line\">            CA::Context::commit_transaction();</span><br><span class=\"line\">                CA::Layer::layout_and_display_if_needed();</span><br><span class=\"line\">                    CA::Layer::layout_if_needed();</span><br><span class=\"line\">                        [CALayer layoutSublayers];</span><br><span class=\"line\">                            [UIView layoutSubviews];</span><br><span class=\"line\">                    CA::Layer::display_if_needed();</span><br><span class=\"line\">                        [CALayer display];</span><br><span class=\"line\">                            [UIView drawRect];</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"定时器\"><a href=\"#定时器\" class=\"headerlink\" title=\"定时器\"></a>定时器</h1><p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p>\n<p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p>\n<p>CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。</p>\n<hr>\n<h1 id=\"PerformSelecter\"><a href=\"#PerformSelecter\" class=\"headerlink\" title=\"PerformSelecter\"></a>PerformSelecter</h1><p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p>\n<p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p>\n<hr>\n<h1 id=\"GCD\"><a href=\"#GCD\" class=\"headerlink\" title=\"GCD\"></a>GCD</h1><p>实际上 RunLoop 底层也会用到 GCD 的东西，<del>比如 RunLoop 是用 dispatch_source_t 实现的 Timer</del>（评论中有人提醒，NSTimer 是用了 XNU 内核的 mk_timer，我也仔细调试了一下，发现 NSTimer 确实是由 mk_timer 驱动，而非 GCD 驱动的）。但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。</p>\n<p>当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p>\n<hr>\n<h1 id=\"网络请求\"><a href=\"#网络请求\" class=\"headerlink\" title=\"网络请求\"></a>网络请求</h1><p>iOS 中，关于网络请求的接口自下至上有如下几层:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CFSocket</span><br><span class=\"line\">CFNetwork       -&gt;ASIHttpRequest</span><br><span class=\"line\">NSURLConnection -&gt;AFNetworking</span><br><span class=\"line\">NSURLSession    -&gt;AFNetworking2, Alamofire</span><br></pre></td></tr></table></figure>\n\n<p>CFSocket 是最底层的接口，只负责 socket 通信。</p>\n<ul>\n<li>CFNetwork 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作于这一层。</li>\n<li>NSURLConnection 是基于 CFNetwork 的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层。</li>\n<li>NSURLSession 是 iOS7 中新增的接口，表面上是和 NSURLConnection 并列的，但底层仍然用到了 NSURLConnection 的部分功能 (比如 com.apple.NSURLConnectionLoader 线程)，AFNetworking2 和 Alamofire 工作于这一层。</li>\n</ul>\n<p>下面主要介绍下 NSURLConnection 的工作过程。</p>\n<p>通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。</p>\n<p>当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。</p>\n<p><img src=\"/2018/04/20/iOS%E5%BA%95%E5%B1%82%E4%B9%8BRunLoop/RunLoop_network.png\">NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。</p>"},{"title":"如何利用RunLoop的知识来监测APP卡顿?","date":"2019-09-11T09:50:48.000Z","top":0,"need_not_copyright":true,"banner_img":null,"_content":"\n卡顿问题，就是在主线程上无法响应用户交互的问题。如果一个 App 时不时地就给你卡一下，有时还长时间无响应，这时你还愿意继续用它吗？所以说，卡顿问题对 App 的伤害是巨大的\n\n## <!-- more -->\n\n## 前言\n\n用runloop来监测卡顿其实并不是什么比较前沿的技术，也不算什么新奇的技术，实际上开发者也用的比较少。一来，应为 `XCode` 的`instrument`足够的优秀，几乎所有的监控操作都有对应的工具。二来，大多数项目上都是集成第三方的统计工具，比如Bugly、友盟之类的等等。但是这样也暴露了一些问题，集成第三方会担心自己的APP信息泄露，那怎么办呢？所以这套自己通过runloop的检测也就营运而生。\n\n## 卡顿可能产生的原因\n\n一般来讲卡顿产生的原因可以大致分为以下几种类型：\n\n1、复杂 UI 、图文混排的绘制量过大；\n\n2、在主线程上做网络同步请求；\n\n4、在主线程做大量的 IO 操作；\n\n4、运算量过大，CPU 持续高占用；死锁和主子线程抢锁\n\n那么问题来了，我们如何来做卡顿的监测呢？只是单纯的检测FPS的波动吗？FPS又是什么呢？维基百科显示FPS，即每秒显示帧数 或者 每秒显示张数 - [影格率](https://zh.wikipedia.org/wiki/帧率)测量单位（这里牵扯到CPU和GPU同步的问题，相关只是点就不在陈述了）。也就是说简单地通过监视 FPS 是很难确定是否会出现卡顿，所以FPS是不能作为用来检测卡顿的标准的。那我们应该通过什么来监测卡顿呢？\n\n## 关于RunLoop\n\n对于iOS开发人员来说，runloop相信大家一定不会陌生，因为他是在日常开发中的一个基础概念，我们都知道，线程的消息事件是依赖于 RunLoop 的，所以从 RunLoop 入手，就可以知道主线程上都调用了哪些方法。我们通过监听 RunLoop 的状态，就能够发现调用方法是否执行时间过长，从而判断出是否会出现卡顿。\n\n当然，如果你要在RunLoop中监测哪些方法的运行时间过长，首先你必须得清楚RunLoop的运行原理，知道了运行原理之后才能知道我们要在RunLoop的哪个环节进行监测。\n\n### 第一步：通知Observers：即将进入RunLoop\n\n我们在[CFRunLoop-1153.18](http://opensource.apple.com/tarballs/CF/CF-1153.18.tar.gz)的源码的第2676行中的`CFRunLoopRun(void)`中，开启一个`do..while`循环来保活\n\n```objective-c\nvoid CFRunLoopRun(void) {\t/* DOES CALLOUT */\n    int32_t result;\n    do {\n        result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);\n        CHECK_FOR_FORK();\n    } while (kCFRunLoopRunStopped != result && kCFRunLoopRunFinished != result);\n}\n```\n\n那我们的重点就在`CFRunLoopRunSpecific`这个方法内部是如何实现的了，我们接下来往下看。`CFRunLoopRunSpecific`是`runloop`的启动入口\n\n```objective-c\n//即将进入runloop\nif (currentMode->_observerMask & kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);\nresult = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);\nif (currentMode->_observerMask & kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);\n```\n\n### 第二步：通知Observers：即将处理Timers和即将处理Sources和blocks\n\n触发times、source0\n\n```objective-c\n__CFRunLoopUnsetIgnoreWakeUps(rl);\nif (rlm->_observerMask & kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);//即将处理Timers\nif (rlm->_observerMask & kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);//即将处理Sources\n__CFRunLoopDoBlocks(rl, rlm);//处理blocks\n```\n\n### 第三步：处理 Source0 \n\n到了这一步可能会再次处理一遍blocks\n\n如果有 Source1 是 ready 状态的话，就会跳转到 handle_msg 去处理消息。代码如下：\n\n```objective-c\n Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);\n    if (sourceHandledThisLoop) {\n    __CFRunLoopDoBlocks(rl, rlm);\n}\n    Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context->termTSR);\n\n    if (MACH_PORT_NULL != dispatchPort && !didDispatchPortLastTime) {\n#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI\n       msg = (mach_msg_header_t *)msg_buffer;\n      //MachPort处于等待中，runloop则会去处理handle_msg\n       if (__CFRunLoopServiceMachPort(dispatchPort, &msg, sizeof(msg_buffer), &livePort, 0, &voucherState, NULL)) {\n           goto handle_msg;\n       }\n#elif DEPLOYMENT_TARGET_WINDOWS\n       if (__CFRunLoopWaitForMultipleObjects(NULL, &dispatchPort, 0, 0, &livePort, NULL)) {\n           goto handle_msg;\n       }\n#endif\n    }\n    didDispatchPortLastTime = false;\n```\n\n### 第四步：通知Observers：开始休眠（等待消息唤醒）\n\n```objective-c\n//通知Observers：开始休眠\nif (!poll && (rlm->_observerMask & kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);\n__CFRunLoopSetSleeping(rl);\n```\n\n### 第五步：通知Observers：结束休眠（被某个消息唤醒）\n\nRunLoop 被唤醒后就要开始处理消息了：（这一段代码太长，就不直接贴出来了）\n\n- 如果是 Timer 时间到的话，就触发 Timer 的回调；\n\n- 处理 GCD Async To Main Queue；\n\n- 如果是 source1(MachPor) 事件的话，就处理这个事件。\n- 再次处理Blocks\n\n```objc\n#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI\n#if USE_DISPATCH_SOURCE_FOR_TIMERS\n        do {\n            if (kCFUseCollectableAllocator) {\n                // objc_clear_stack(0);\n                // <rdar://problem/16393959>\n                memset(msg_buffer, 0, sizeof(msg_buffer));\n            }\n            msg = (mach_msg_header_t *)msg_buffer;\n            __CFRunLoopServiceMachPort(waitSet, &msg, sizeof(msg_buffer), &livePort, poll ? 0 : TIMEOUT_INFINITY, &voucherState, &voucherCopy);\n            \n            if (modeQueuePort != MACH_PORT_NULL && livePort == modeQueuePort) {\n                // Drain the internal queue. If one of the callout blocks sets the timerFired flag, break out and service the timer.\n                while (_dispatch_runloop_root_queue_perform_4CF(rlm->_queue));\n                if (rlm->_timerFired) {\n                    // Leave livePort as the queue port, and service timers below\n                    rlm->_timerFired = false;\n                    break;\n                } else {\n                    if (msg && msg != (mach_msg_header_t *)msg_buffer) free(msg);\n                }\n            } else {\n                // Go ahead and leave the inner loop.\n                break;\n            }\n        } while (1);\n(省略)........\n```\n\n### 第六步：根据上一步的操作决定是退出runloop还是继续执行runloop\n\n根据上一步的操作决定是退出runloop还是继续执行runloop\n\n```objc\nif (sourceHandledThisLoop && stopAfterHandle) {\n\t    retVal = kCFRunLoopRunHandledSource;\n        } else if (timeout_context->termTSR < mach_absolute_time()) {\n            retVal = kCFRunLoopRunTimedOut;\n\t} else if (__CFRunLoopIsStopped(rl)) {\n            __CFRunLoopUnsetStopped(rl);\n\t    retVal = kCFRunLoopRunStopped;\n\t} else if (rlm->_stopped) {\n\t    rlm->_stopped = false;\n\t    retVal = kCFRunLoopRunStopped;\n\t} else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) {\n\t    retVal = kCFRunLoopRunFinished;\n\t}\n```\n\n\n\n### RunLoop的六个状态\n\n```objc\ntypedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {\n    kCFRunLoopEntry = (1UL << 0),\t\t\t\t\t\t//即将进入RunLoop\n    kCFRunLoopBeforeTimers = (1UL << 1),\t\t//即将处理Timers\n    kCFRunLoopBeforeSources = (1UL << 2),\t\t//即将处理Source\n    kCFRunLoopBeforeWaiting = (1UL << 5),\t\t//即将休眠\n    kCFRunLoopAfterWaiting = (1UL << 6),\t\t//即将唤醒\n    kCFRunLoopExit = (1UL << 7),\t\t\t\t\t\t//退出RunLoop\n    kCFRunLoopAllActivities = 0x0FFFFFFFU\n};\n```\n\n用一张图概括RunLoop的运行轨迹\n\n![runloop](5f51c5e05085badb689f01b1e63e1c7d.png)\n\n## 思路\n\n通过上面的runloop运行轨迹我们能够知道，RunLoop`处理事件的时间主要出在两个阶段：\n\n- `kCFRunLoopBeforeSources`和`kCFRunLoopBeforeWaiting`之间\n- `kCFRunLoopAfterWaiting`之后\n\n试想如果 RunLoop 的线程，进入睡眠前方法的执行时间过长而导致无法进入睡眠，或者线程唤醒后接收消息时间过长而无法进入下一步的话，就可以认为是线程受阻了。如果这个线程是主线程的话，表现出来的就是出现了卡顿。所以，如果我们要利用 RunLoop 原理来监控卡顿的话，就是要关注这三个阶段。\n\n接下来，我们就一起分析一下，如何对 loop 的这两个状态进行监听，以及监控的时间值如何设置才合理。\n\n## 监控RunLoop状态检测超时\n\n通过`RunLoop`的源码我们已经知道了主线程处理事件的时间，那么如何检测应用是否发生了卡顿呢？为了找到合理的处理方案，我们得先在项目中得到runloop的监听状态。\n\n```objc\nstatic void runLoopObserverCallback(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void * info) {\n    [RunloopMonitor shareInstance].currentActivity = activity;\n    dispatch_semaphore_signal([RunloopMonitor shareInstance].semphore);\n    switch (activity) {\n        case kCFRunLoopEntry:\n            NSLog(@\"runloop entry\");\n            break;\n        case kCFRunLoopExit:\n            NSLog(@\"runloop exit\");\n            break;\n        case kCFRunLoopAfterWaiting:\n            NSLog(@\"runloop after waiting\");\n            break;\n        case kCFRunLoopBeforeTimers:\n            NSLog(@\"runloop before timers\");\n            break;\n        case kCFRunLoopBeforeSources:\n            NSLog(@\"runloop before sources\");\n            break;\n        case kCFRunLoopBeforeWaiting:\n            NSLog(@\"runloop before waiting\");\n            break;\n        default:\n            break;\n    }\n};\n```\n\nUITableView代理代码：\n\n```objc\n- (NSInteger)tableView: (UITableView *)tableView numberOfRowsInSection: (NSInteger)section {\n    return 500;\n}\n\n- (UITableViewCell *)tableView: (UITableView *)tableView cellForRowAtIndexPath: (NSIndexPath *)indexPath {\n    UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier: @\"cell\"];\n    cell.textLabel.text = [NSString stringWithFormat: @\"第%lu行\", indexPath.row];\n    if (indexPath.row > 0 && indexPath.row % 30 == 0) {\n        sleep(2.0);\n    }\n    return cell;\n}\n\n- (void)tableView: (UITableView *)tableView didSelectRowAtIndexPath: (NSIndexPath *)indexPath {\n    sleep(2.0);\n}\n```\n\n运行之后输出的结果是滚动引发的`Sources`事件总是被快速的执行完成，然后进入到`kCFRunLoopBeforeWaiting`状态下。假如在滚动过程中发生了卡顿现象，那么`RunLoop`必然会保持`kCFRunLoopAfterWaiting`或者`kCFRunLoopBeforeSources`这两个状态之一。\n\n为了实现卡顿的检测，首先需要注册`RunLoop`的监听回调，保存`RunLoop`状态；其次，通过创建子线程循环监听主线程`RunLoop`的状态来检测是否存在停留卡顿现象: `收到Sources相关的事件时，将超时阙值时间内分割成多个时间片段，重复去获取当前RunLoop的状态。如果多次处在处理事件的状态下，那么可以视作发生了卡顿现象`\n\n```objc\n- (void)startMonitoring {\n    if (_isMonitoring) { return; }\n    _isMonitoring = YES;\n    CFRunLoopObserverContext context = { 0, (__bridge void *)self, NULL, NULL};\n    _observer = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, &runLoopObserverCallback, &context);\n    CFRunLoopAddObserver(CFRunLoopGetMain(), _observer, kCFRunLoopCommonModes);\n    \n    dispatch_async(event_monitor_queue(), ^{\n        while ([RunloopMonitor shareInstance].isMonitoring) {\n            if ([RunloopMonitor shareInstance].currentActivity == kCFRunLoopBeforeWaiting) {\n                __block BOOL timeOut = YES;\n                dispatch_async(dispatch_get_main_queue(), ^{\n                    timeOut = NO;\n                    dispatch_semaphore_signal([RunloopMonitor shareInstance].eventSemphore);\n                });\n                [NSThread sleepForTimeInterval: time_out_interval];\n                if (timeOut) {\n                }\n                dispatch_wait([RunloopMonitor shareInstance].eventSemphore, DISPATCH_TIME_FOREVER);\n            }\n        }\n    });\n    \n    dispatch_async(fluecy_monitor_queue(), ^{\n        while ([RunloopMonitor shareInstance].isMonitoring) {\n            long waitTime = dispatch_semaphore_wait(self.semphore, dispatch_time(DISPATCH_TIME_NOW, wait_interval));\n            if (waitTime != 0) {\n                if (![RunloopMonitor shareInstance].observer) {\n                    [RunloopMonitor shareInstance].outTime = 0;\n                    [[RunloopMonitor shareInstance] stopMonitoring];\n                    continue;\n                }\n                if ([RunloopMonitor shareInstance].currentActivity == kCFRunLoopBeforeSources || [RunloopMonitor shareInstance].currentActivity == kCFRunLoopAfterWaiting) {\n                    if (++[RunloopMonitor shareInstance].outTime < 5) {\n                        continue;\n                    }\n                    [NSThread sleepForTimeInterval: restore_interval];\n                }\n            }\n            [RunloopMonitor shareInstance].outTime = 0;\n        }\n    });\n}\n```\n\n\n\n## 标记位检测线程超时\n\n与UI卡顿不同的事，事件处理往往是处在`kCFRunLoopBeforeWaiting`的状态下收到了`Sources`事件源，最开始笔者尝试同样以多个时间片段查询的方式处理。但是由于主线程的`RunLoop`在闲置时基本处于`Before Waiting`状态，这就导致了即便没有发生任何卡顿，这种检测方式也总能认定主线程处在卡顿状态。\n\n于是github上查看了下卡顿检测第三方监测卡顿的工具，他们的卡顿监控方案大致思路为：创建一个子线程进行循环检测，每次检测时设置标记位为`YES`，然后派发任务到主线程中将标记位设置为`NO`。接着子线程沉睡超时阙值时长，判断标志位是否成功设置成`NO`。如果没有说明主线程发生了卡顿，无法处理派发任务：\n\n![图片 1](图片 1.png)\n\n## 获取堆栈\n\n子线程监控发现卡顿后，还需要记录当前出现卡顿的方法堆栈信息，并适时推送到服务端供开发者分析，从而解决卡顿问题。那么，在这个过程中，如何获取卡顿的方法堆栈信息呢？\n\n这里我选择了魔改[BSBacktraceLogger](https://github.com/bestswifter/BSBacktraceLogger)\n\n## 小结\n\n多数开发者对于`RunLoop`可能并没有进行实际的应用开发过，或者说即便了解`RunLoop`也只是处在理论的认知上。本文仅仅是对采用runloop来进行APP卡顿的一些个人观点，有纰漏还望指出。\n\n[Demo](https://github.com/eziochiu/RunLoopMonitor.git)","source":"_posts/如何利用RunLoop的知识来监测APP卡顿.md","raw":"---\ntitle: 如何利用RunLoop的知识来监测APP卡顿?\ndate: 2019-09-11 17:50:48\ntags: [RunLoop]\ntop: 0\nneed_not_copyright: true\ncategories: RunLoop\nbanner_img:\n---\n\n卡顿问题，就是在主线程上无法响应用户交互的问题。如果一个 App 时不时地就给你卡一下，有时还长时间无响应，这时你还愿意继续用它吗？所以说，卡顿问题对 App 的伤害是巨大的\n\n## <!-- more -->\n\n## 前言\n\n用runloop来监测卡顿其实并不是什么比较前沿的技术，也不算什么新奇的技术，实际上开发者也用的比较少。一来，应为 `XCode` 的`instrument`足够的优秀，几乎所有的监控操作都有对应的工具。二来，大多数项目上都是集成第三方的统计工具，比如Bugly、友盟之类的等等。但是这样也暴露了一些问题，集成第三方会担心自己的APP信息泄露，那怎么办呢？所以这套自己通过runloop的检测也就营运而生。\n\n## 卡顿可能产生的原因\n\n一般来讲卡顿产生的原因可以大致分为以下几种类型：\n\n1、复杂 UI 、图文混排的绘制量过大；\n\n2、在主线程上做网络同步请求；\n\n4、在主线程做大量的 IO 操作；\n\n4、运算量过大，CPU 持续高占用；死锁和主子线程抢锁\n\n那么问题来了，我们如何来做卡顿的监测呢？只是单纯的检测FPS的波动吗？FPS又是什么呢？维基百科显示FPS，即每秒显示帧数 或者 每秒显示张数 - [影格率](https://zh.wikipedia.org/wiki/帧率)测量单位（这里牵扯到CPU和GPU同步的问题，相关只是点就不在陈述了）。也就是说简单地通过监视 FPS 是很难确定是否会出现卡顿，所以FPS是不能作为用来检测卡顿的标准的。那我们应该通过什么来监测卡顿呢？\n\n## 关于RunLoop\n\n对于iOS开发人员来说，runloop相信大家一定不会陌生，因为他是在日常开发中的一个基础概念，我们都知道，线程的消息事件是依赖于 RunLoop 的，所以从 RunLoop 入手，就可以知道主线程上都调用了哪些方法。我们通过监听 RunLoop 的状态，就能够发现调用方法是否执行时间过长，从而判断出是否会出现卡顿。\n\n当然，如果你要在RunLoop中监测哪些方法的运行时间过长，首先你必须得清楚RunLoop的运行原理，知道了运行原理之后才能知道我们要在RunLoop的哪个环节进行监测。\n\n### 第一步：通知Observers：即将进入RunLoop\n\n我们在[CFRunLoop-1153.18](http://opensource.apple.com/tarballs/CF/CF-1153.18.tar.gz)的源码的第2676行中的`CFRunLoopRun(void)`中，开启一个`do..while`循环来保活\n\n```objective-c\nvoid CFRunLoopRun(void) {\t/* DOES CALLOUT */\n    int32_t result;\n    do {\n        result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);\n        CHECK_FOR_FORK();\n    } while (kCFRunLoopRunStopped != result && kCFRunLoopRunFinished != result);\n}\n```\n\n那我们的重点就在`CFRunLoopRunSpecific`这个方法内部是如何实现的了，我们接下来往下看。`CFRunLoopRunSpecific`是`runloop`的启动入口\n\n```objective-c\n//即将进入runloop\nif (currentMode->_observerMask & kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);\nresult = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);\nif (currentMode->_observerMask & kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);\n```\n\n### 第二步：通知Observers：即将处理Timers和即将处理Sources和blocks\n\n触发times、source0\n\n```objective-c\n__CFRunLoopUnsetIgnoreWakeUps(rl);\nif (rlm->_observerMask & kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);//即将处理Timers\nif (rlm->_observerMask & kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);//即将处理Sources\n__CFRunLoopDoBlocks(rl, rlm);//处理blocks\n```\n\n### 第三步：处理 Source0 \n\n到了这一步可能会再次处理一遍blocks\n\n如果有 Source1 是 ready 状态的话，就会跳转到 handle_msg 去处理消息。代码如下：\n\n```objective-c\n Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);\n    if (sourceHandledThisLoop) {\n    __CFRunLoopDoBlocks(rl, rlm);\n}\n    Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context->termTSR);\n\n    if (MACH_PORT_NULL != dispatchPort && !didDispatchPortLastTime) {\n#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI\n       msg = (mach_msg_header_t *)msg_buffer;\n      //MachPort处于等待中，runloop则会去处理handle_msg\n       if (__CFRunLoopServiceMachPort(dispatchPort, &msg, sizeof(msg_buffer), &livePort, 0, &voucherState, NULL)) {\n           goto handle_msg;\n       }\n#elif DEPLOYMENT_TARGET_WINDOWS\n       if (__CFRunLoopWaitForMultipleObjects(NULL, &dispatchPort, 0, 0, &livePort, NULL)) {\n           goto handle_msg;\n       }\n#endif\n    }\n    didDispatchPortLastTime = false;\n```\n\n### 第四步：通知Observers：开始休眠（等待消息唤醒）\n\n```objective-c\n//通知Observers：开始休眠\nif (!poll && (rlm->_observerMask & kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);\n__CFRunLoopSetSleeping(rl);\n```\n\n### 第五步：通知Observers：结束休眠（被某个消息唤醒）\n\nRunLoop 被唤醒后就要开始处理消息了：（这一段代码太长，就不直接贴出来了）\n\n- 如果是 Timer 时间到的话，就触发 Timer 的回调；\n\n- 处理 GCD Async To Main Queue；\n\n- 如果是 source1(MachPor) 事件的话，就处理这个事件。\n- 再次处理Blocks\n\n```objc\n#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI\n#if USE_DISPATCH_SOURCE_FOR_TIMERS\n        do {\n            if (kCFUseCollectableAllocator) {\n                // objc_clear_stack(0);\n                // <rdar://problem/16393959>\n                memset(msg_buffer, 0, sizeof(msg_buffer));\n            }\n            msg = (mach_msg_header_t *)msg_buffer;\n            __CFRunLoopServiceMachPort(waitSet, &msg, sizeof(msg_buffer), &livePort, poll ? 0 : TIMEOUT_INFINITY, &voucherState, &voucherCopy);\n            \n            if (modeQueuePort != MACH_PORT_NULL && livePort == modeQueuePort) {\n                // Drain the internal queue. If one of the callout blocks sets the timerFired flag, break out and service the timer.\n                while (_dispatch_runloop_root_queue_perform_4CF(rlm->_queue));\n                if (rlm->_timerFired) {\n                    // Leave livePort as the queue port, and service timers below\n                    rlm->_timerFired = false;\n                    break;\n                } else {\n                    if (msg && msg != (mach_msg_header_t *)msg_buffer) free(msg);\n                }\n            } else {\n                // Go ahead and leave the inner loop.\n                break;\n            }\n        } while (1);\n(省略)........\n```\n\n### 第六步：根据上一步的操作决定是退出runloop还是继续执行runloop\n\n根据上一步的操作决定是退出runloop还是继续执行runloop\n\n```objc\nif (sourceHandledThisLoop && stopAfterHandle) {\n\t    retVal = kCFRunLoopRunHandledSource;\n        } else if (timeout_context->termTSR < mach_absolute_time()) {\n            retVal = kCFRunLoopRunTimedOut;\n\t} else if (__CFRunLoopIsStopped(rl)) {\n            __CFRunLoopUnsetStopped(rl);\n\t    retVal = kCFRunLoopRunStopped;\n\t} else if (rlm->_stopped) {\n\t    rlm->_stopped = false;\n\t    retVal = kCFRunLoopRunStopped;\n\t} else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) {\n\t    retVal = kCFRunLoopRunFinished;\n\t}\n```\n\n\n\n### RunLoop的六个状态\n\n```objc\ntypedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {\n    kCFRunLoopEntry = (1UL << 0),\t\t\t\t\t\t//即将进入RunLoop\n    kCFRunLoopBeforeTimers = (1UL << 1),\t\t//即将处理Timers\n    kCFRunLoopBeforeSources = (1UL << 2),\t\t//即将处理Source\n    kCFRunLoopBeforeWaiting = (1UL << 5),\t\t//即将休眠\n    kCFRunLoopAfterWaiting = (1UL << 6),\t\t//即将唤醒\n    kCFRunLoopExit = (1UL << 7),\t\t\t\t\t\t//退出RunLoop\n    kCFRunLoopAllActivities = 0x0FFFFFFFU\n};\n```\n\n用一张图概括RunLoop的运行轨迹\n\n![runloop](5f51c5e05085badb689f01b1e63e1c7d.png)\n\n## 思路\n\n通过上面的runloop运行轨迹我们能够知道，RunLoop`处理事件的时间主要出在两个阶段：\n\n- `kCFRunLoopBeforeSources`和`kCFRunLoopBeforeWaiting`之间\n- `kCFRunLoopAfterWaiting`之后\n\n试想如果 RunLoop 的线程，进入睡眠前方法的执行时间过长而导致无法进入睡眠，或者线程唤醒后接收消息时间过长而无法进入下一步的话，就可以认为是线程受阻了。如果这个线程是主线程的话，表现出来的就是出现了卡顿。所以，如果我们要利用 RunLoop 原理来监控卡顿的话，就是要关注这三个阶段。\n\n接下来，我们就一起分析一下，如何对 loop 的这两个状态进行监听，以及监控的时间值如何设置才合理。\n\n## 监控RunLoop状态检测超时\n\n通过`RunLoop`的源码我们已经知道了主线程处理事件的时间，那么如何检测应用是否发生了卡顿呢？为了找到合理的处理方案，我们得先在项目中得到runloop的监听状态。\n\n```objc\nstatic void runLoopObserverCallback(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void * info) {\n    [RunloopMonitor shareInstance].currentActivity = activity;\n    dispatch_semaphore_signal([RunloopMonitor shareInstance].semphore);\n    switch (activity) {\n        case kCFRunLoopEntry:\n            NSLog(@\"runloop entry\");\n            break;\n        case kCFRunLoopExit:\n            NSLog(@\"runloop exit\");\n            break;\n        case kCFRunLoopAfterWaiting:\n            NSLog(@\"runloop after waiting\");\n            break;\n        case kCFRunLoopBeforeTimers:\n            NSLog(@\"runloop before timers\");\n            break;\n        case kCFRunLoopBeforeSources:\n            NSLog(@\"runloop before sources\");\n            break;\n        case kCFRunLoopBeforeWaiting:\n            NSLog(@\"runloop before waiting\");\n            break;\n        default:\n            break;\n    }\n};\n```\n\nUITableView代理代码：\n\n```objc\n- (NSInteger)tableView: (UITableView *)tableView numberOfRowsInSection: (NSInteger)section {\n    return 500;\n}\n\n- (UITableViewCell *)tableView: (UITableView *)tableView cellForRowAtIndexPath: (NSIndexPath *)indexPath {\n    UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier: @\"cell\"];\n    cell.textLabel.text = [NSString stringWithFormat: @\"第%lu行\", indexPath.row];\n    if (indexPath.row > 0 && indexPath.row % 30 == 0) {\n        sleep(2.0);\n    }\n    return cell;\n}\n\n- (void)tableView: (UITableView *)tableView didSelectRowAtIndexPath: (NSIndexPath *)indexPath {\n    sleep(2.0);\n}\n```\n\n运行之后输出的结果是滚动引发的`Sources`事件总是被快速的执行完成，然后进入到`kCFRunLoopBeforeWaiting`状态下。假如在滚动过程中发生了卡顿现象，那么`RunLoop`必然会保持`kCFRunLoopAfterWaiting`或者`kCFRunLoopBeforeSources`这两个状态之一。\n\n为了实现卡顿的检测，首先需要注册`RunLoop`的监听回调，保存`RunLoop`状态；其次，通过创建子线程循环监听主线程`RunLoop`的状态来检测是否存在停留卡顿现象: `收到Sources相关的事件时，将超时阙值时间内分割成多个时间片段，重复去获取当前RunLoop的状态。如果多次处在处理事件的状态下，那么可以视作发生了卡顿现象`\n\n```objc\n- (void)startMonitoring {\n    if (_isMonitoring) { return; }\n    _isMonitoring = YES;\n    CFRunLoopObserverContext context = { 0, (__bridge void *)self, NULL, NULL};\n    _observer = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, &runLoopObserverCallback, &context);\n    CFRunLoopAddObserver(CFRunLoopGetMain(), _observer, kCFRunLoopCommonModes);\n    \n    dispatch_async(event_monitor_queue(), ^{\n        while ([RunloopMonitor shareInstance].isMonitoring) {\n            if ([RunloopMonitor shareInstance].currentActivity == kCFRunLoopBeforeWaiting) {\n                __block BOOL timeOut = YES;\n                dispatch_async(dispatch_get_main_queue(), ^{\n                    timeOut = NO;\n                    dispatch_semaphore_signal([RunloopMonitor shareInstance].eventSemphore);\n                });\n                [NSThread sleepForTimeInterval: time_out_interval];\n                if (timeOut) {\n                }\n                dispatch_wait([RunloopMonitor shareInstance].eventSemphore, DISPATCH_TIME_FOREVER);\n            }\n        }\n    });\n    \n    dispatch_async(fluecy_monitor_queue(), ^{\n        while ([RunloopMonitor shareInstance].isMonitoring) {\n            long waitTime = dispatch_semaphore_wait(self.semphore, dispatch_time(DISPATCH_TIME_NOW, wait_interval));\n            if (waitTime != 0) {\n                if (![RunloopMonitor shareInstance].observer) {\n                    [RunloopMonitor shareInstance].outTime = 0;\n                    [[RunloopMonitor shareInstance] stopMonitoring];\n                    continue;\n                }\n                if ([RunloopMonitor shareInstance].currentActivity == kCFRunLoopBeforeSources || [RunloopMonitor shareInstance].currentActivity == kCFRunLoopAfterWaiting) {\n                    if (++[RunloopMonitor shareInstance].outTime < 5) {\n                        continue;\n                    }\n                    [NSThread sleepForTimeInterval: restore_interval];\n                }\n            }\n            [RunloopMonitor shareInstance].outTime = 0;\n        }\n    });\n}\n```\n\n\n\n## 标记位检测线程超时\n\n与UI卡顿不同的事，事件处理往往是处在`kCFRunLoopBeforeWaiting`的状态下收到了`Sources`事件源，最开始笔者尝试同样以多个时间片段查询的方式处理。但是由于主线程的`RunLoop`在闲置时基本处于`Before Waiting`状态，这就导致了即便没有发生任何卡顿，这种检测方式也总能认定主线程处在卡顿状态。\n\n于是github上查看了下卡顿检测第三方监测卡顿的工具，他们的卡顿监控方案大致思路为：创建一个子线程进行循环检测，每次检测时设置标记位为`YES`，然后派发任务到主线程中将标记位设置为`NO`。接着子线程沉睡超时阙值时长，判断标志位是否成功设置成`NO`。如果没有说明主线程发生了卡顿，无法处理派发任务：\n\n![图片 1](图片 1.png)\n\n## 获取堆栈\n\n子线程监控发现卡顿后，还需要记录当前出现卡顿的方法堆栈信息，并适时推送到服务端供开发者分析，从而解决卡顿问题。那么，在这个过程中，如何获取卡顿的方法堆栈信息呢？\n\n这里我选择了魔改[BSBacktraceLogger](https://github.com/bestswifter/BSBacktraceLogger)\n\n## 小结\n\n多数开发者对于`RunLoop`可能并没有进行实际的应用开发过，或者说即便了解`RunLoop`也只是处在理论的认知上。本文仅仅是对采用runloop来进行APP卡顿的一些个人观点，有纰漏还望指出。\n\n[Demo](https://github.com/eziochiu/RunLoopMonitor.git)","slug":"如何利用RunLoop的知识来监测APP卡顿","published":1,"updated":"2023-07-21T09:10:33.577Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clkcgbp5i0019pfo736mnfnic","content":"<p>卡顿问题，就是在主线程上无法响应用户交互的问题。如果一个 App 时不时地就给你卡一下，有时还长时间无响应，这时你还愿意继续用它吗？所以说，卡顿问题对 App 的伤害是巨大的</p>\n<h2 id><a href=\"#\" class=\"headerlink\" title></a><span id=\"more\"></span></h2><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>用runloop来监测卡顿其实并不是什么比较前沿的技术，也不算什么新奇的技术，实际上开发者也用的比较少。一来，应为 <code>XCode</code> 的<code>instrument</code>足够的优秀，几乎所有的监控操作都有对应的工具。二来，大多数项目上都是集成第三方的统计工具，比如Bugly、友盟之类的等等。但是这样也暴露了一些问题，集成第三方会担心自己的APP信息泄露，那怎么办呢？所以这套自己通过runloop的检测也就营运而生。</p>\n<h2 id=\"卡顿可能产生的原因\"><a href=\"#卡顿可能产生的原因\" class=\"headerlink\" title=\"卡顿可能产生的原因\"></a>卡顿可能产生的原因</h2><p>一般来讲卡顿产生的原因可以大致分为以下几种类型：</p>\n<p>1、复杂 UI 、图文混排的绘制量过大；</p>\n<p>2、在主线程上做网络同步请求；</p>\n<p>4、在主线程做大量的 IO 操作；</p>\n<p>4、运算量过大，CPU 持续高占用；死锁和主子线程抢锁</p>\n<p>那么问题来了，我们如何来做卡顿的监测呢？只是单纯的检测FPS的波动吗？FPS又是什么呢？维基百科显示FPS，即每秒显示帧数 或者 每秒显示张数 - <a href=\"https://zh.wikipedia.org/wiki/%E5%B8%A7%E7%8E%87\">影格率</a>测量单位（这里牵扯到CPU和GPU同步的问题，相关只是点就不在陈述了）。也就是说简单地通过监视 FPS 是很难确定是否会出现卡顿，所以FPS是不能作为用来检测卡顿的标准的。那我们应该通过什么来监测卡顿呢？</p>\n<h2 id=\"关于RunLoop\"><a href=\"#关于RunLoop\" class=\"headerlink\" title=\"关于RunLoop\"></a>关于RunLoop</h2><p>对于iOS开发人员来说，runloop相信大家一定不会陌生，因为他是在日常开发中的一个基础概念，我们都知道，线程的消息事件是依赖于 RunLoop 的，所以从 RunLoop 入手，就可以知道主线程上都调用了哪些方法。我们通过监听 RunLoop 的状态，就能够发现调用方法是否执行时间过长，从而判断出是否会出现卡顿。</p>\n<p>当然，如果你要在RunLoop中监测哪些方法的运行时间过长，首先你必须得清楚RunLoop的运行原理，知道了运行原理之后才能知道我们要在RunLoop的哪个环节进行监测。</p>\n<h3 id=\"第一步：通知Observers：即将进入RunLoop\"><a href=\"#第一步：通知Observers：即将进入RunLoop\" class=\"headerlink\" title=\"第一步：通知Observers：即将进入RunLoop\"></a>第一步：通知Observers：即将进入RunLoop</h3><p>我们在<a href=\"http://opensource.apple.com/tarballs/CF/CF-1153.18.tar.gz\">CFRunLoop-1153.18</a>的源码的第2676行中的<code>CFRunLoopRun(void)</code>中，开启一个<code>do..while</code>循环来保活</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void CFRunLoopRun(void) &#123;\t/* DOES CALLOUT */</span><br><span class=\"line\">    int32_t result;</span><br><span class=\"line\">    do &#123;</span><br><span class=\"line\">        result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);</span><br><span class=\"line\">        CHECK_FOR_FORK();</span><br><span class=\"line\">    &#125; while (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那我们的重点就在<code>CFRunLoopRunSpecific</code>这个方法内部是如何实现的了，我们接下来往下看。<code>CFRunLoopRunSpecific</code>是<code>runloop</code>的启动入口</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//即将进入runloop</span><br><span class=\"line\">if (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class=\"line\">result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class=\"line\">if (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"第二步：通知Observers：即将处理Timers和即将处理Sources和blocks\"><a href=\"#第二步：通知Observers：即将处理Timers和即将处理Sources和blocks\" class=\"headerlink\" title=\"第二步：通知Observers：即将处理Timers和即将处理Sources和blocks\"></a>第二步：通知Observers：即将处理Timers和即将处理Sources和blocks</h3><p>触发times、source0</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__CFRunLoopUnsetIgnoreWakeUps(rl);</span><br><span class=\"line\">if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);//即将处理Timers</span><br><span class=\"line\">if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);//即将处理Sources</span><br><span class=\"line\">__CFRunLoopDoBlocks(rl, rlm);//处理blocks</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"第三步：处理-Source0\"><a href=\"#第三步：处理-Source0\" class=\"headerlink\" title=\"第三步：处理 Source0\"></a>第三步：处理 Source0</h3><p>到了这一步可能会再次处理一遍blocks</p>\n<p>如果有 Source1 是 ready 状态的话，就会跳转到 handle_msg 去处理消息。代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class=\"line\">    if (sourceHandledThisLoop) &#123;</span><br><span class=\"line\">    __CFRunLoopDoBlocks(rl, rlm);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context-&gt;termTSR);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123;</span><br><span class=\"line\">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span><br><span class=\"line\">       msg = (mach_msg_header_t *)msg_buffer;</span><br><span class=\"line\">      //MachPort处于等待中，runloop则会去处理handle_msg</span><br><span class=\"line\">       if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0, &amp;voucherState, NULL)) &#123;</span><br><span class=\"line\">           goto handle_msg;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">#elif DEPLOYMENT_TARGET_WINDOWS</span><br><span class=\"line\">       if (__CFRunLoopWaitForMultipleObjects(NULL, &amp;dispatchPort, 0, 0, &amp;livePort, NULL)) &#123;</span><br><span class=\"line\">           goto handle_msg;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">#endif</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    didDispatchPortLastTime = false;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"第四步：通知Observers：开始休眠（等待消息唤醒）\"><a href=\"#第四步：通知Observers：开始休眠（等待消息唤醒）\" class=\"headerlink\" title=\"第四步：通知Observers：开始休眠（等待消息唤醒）\"></a>第四步：通知Observers：开始休眠（等待消息唤醒）</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//通知Observers：开始休眠</span><br><span class=\"line\">if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class=\"line\">__CFRunLoopSetSleeping(rl);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"第五步：通知Observers：结束休眠（被某个消息唤醒）\"><a href=\"#第五步：通知Observers：结束休眠（被某个消息唤醒）\" class=\"headerlink\" title=\"第五步：通知Observers：结束休眠（被某个消息唤醒）\"></a>第五步：通知Observers：结束休眠（被某个消息唤醒）</h3><p>RunLoop 被唤醒后就要开始处理消息了：（这一段代码太长，就不直接贴出来了）</p>\n<ul>\n<li><p>如果是 Timer 时间到的话，就触发 Timer 的回调；</p>\n</li>\n<li><p>处理 GCD Async To Main Queue；</p>\n</li>\n<li><p>如果是 source1(MachPor) 事件的话，就处理这个事件。</p>\n</li>\n<li><p>再次处理Blocks</p>\n</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span></span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (kCFUseCollectableAllocator) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// objc_clear_stack(0);</span></span><br><span class=\"line\">                <span class=\"comment\">// &lt;rdar://problem/16393959&gt;</span></span><br><span class=\"line\">                memset(msg_buffer, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(msg_buffer));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            msg = (mach_msg_header_t *)msg_buffer;</span><br><span class=\"line\">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class=\"keyword\">sizeof</span>(msg_buffer), &amp;livePort, poll ? <span class=\"number\">0</span> : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Drain the internal queue. If one of the callout blocks sets the timerFired flag, break out and service the timer.</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (_dispatch_runloop_root_queue_perform_4CF(rlm-&gt;_queue));</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (rlm-&gt;_timerFired) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Leave livePort as the queue port, and service timers below</span></span><br><span class=\"line\">                    rlm-&gt;_timerFired = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Go ahead and leave the inner loop.</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (<span class=\"number\">1</span>);</span><br><span class=\"line\">(省略)........</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"第六步：根据上一步的操作决定是退出runloop还是继续执行runloop\"><a href=\"#第六步：根据上一步的操作决定是退出runloop还是继续执行runloop\" class=\"headerlink\" title=\"第六步：根据上一步的操作决定是退出runloop还是继续执行runloop\"></a>第六步：根据上一步的操作决定是退出runloop还是继续执行runloop</h3><p>根据上一步的操作决定是退出runloop还是继续执行runloop</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class=\"line\">\t    retVal = kCFRunLoopRunHandledSource;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class=\"line\">            retVal = kCFRunLoopRunTimedOut;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class=\"line\">            __CFRunLoopUnsetStopped(rl);</span><br><span class=\"line\">\t    retVal = kCFRunLoopRunStopped;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (rlm-&gt;_stopped) &#123;</span><br><span class=\"line\">\t    rlm-&gt;_stopped = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t    retVal = kCFRunLoopRunStopped;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class=\"line\">\t    retVal = kCFRunLoopRunFinished;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"RunLoop的六个状态\"><a href=\"#RunLoop的六个状态\" class=\"headerlink\" title=\"RunLoop的六个状态\"></a>RunLoop的六个状态</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">CF_OPTIONS</span>(<span class=\"built_in\">CFOptionFlags</span>, <span class=\"built_in\">CFRunLoopActivity</span>) &#123;</span><br><span class=\"line\">    kCFRunLoopEntry = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">0</span>),\t\t\t\t\t\t<span class=\"comment\">//即将进入RunLoop</span></span><br><span class=\"line\">    kCFRunLoopBeforeTimers = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">1</span>),\t\t<span class=\"comment\">//即将处理Timers</span></span><br><span class=\"line\">    kCFRunLoopBeforeSources = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">2</span>),\t\t<span class=\"comment\">//即将处理Source</span></span><br><span class=\"line\">    kCFRunLoopBeforeWaiting = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">5</span>),\t\t<span class=\"comment\">//即将休眠</span></span><br><span class=\"line\">    kCFRunLoopAfterWaiting = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">6</span>),\t\t<span class=\"comment\">//即将唤醒</span></span><br><span class=\"line\">    kCFRunLoopExit = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">7</span>),\t\t\t\t\t\t<span class=\"comment\">//退出RunLoop</span></span><br><span class=\"line\">    kCFRunLoopAllActivities = <span class=\"number\">0x0FFFFFFF</span>U</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>用一张图概括RunLoop的运行轨迹</p>\n<p><img src=\"/2019/09/11/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8RunLoop%E7%9A%84%E7%9F%A5%E8%AF%86%E6%9D%A5%E7%9B%91%E6%B5%8BAPP%E5%8D%A1%E9%A1%BF/5f51c5e05085badb689f01b1e63e1c7d.png\" alt=\"runloop\"></p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>通过上面的runloop运行轨迹我们能够知道，RunLoop&#96;处理事件的时间主要出在两个阶段：</p>\n<ul>\n<li><code>kCFRunLoopBeforeSources</code>和<code>kCFRunLoopBeforeWaiting</code>之间</li>\n<li><code>kCFRunLoopAfterWaiting</code>之后</li>\n</ul>\n<p>试想如果 RunLoop 的线程，进入睡眠前方法的执行时间过长而导致无法进入睡眠，或者线程唤醒后接收消息时间过长而无法进入下一步的话，就可以认为是线程受阻了。如果这个线程是主线程的话，表现出来的就是出现了卡顿。所以，如果我们要利用 RunLoop 原理来监控卡顿的话，就是要关注这三个阶段。</p>\n<p>接下来，我们就一起分析一下，如何对 loop 的这两个状态进行监听，以及监控的时间值如何设置才合理。</p>\n<h2 id=\"监控RunLoop状态检测超时\"><a href=\"#监控RunLoop状态检测超时\" class=\"headerlink\" title=\"监控RunLoop状态检测超时\"></a>监控RunLoop状态检测超时</h2><p>通过<code>RunLoop</code>的源码我们已经知道了主线程处理事件的时间，那么如何检测应用是否发生了卡顿呢？为了找到合理的处理方案，我们得先在项目中得到runloop的监听状态。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"type\">void</span> runLoopObserverCallback(<span class=\"built_in\">CFRunLoopObserverRef</span> observer, <span class=\"built_in\">CFRunLoopActivity</span> activity, <span class=\"type\">void</span> * info) &#123;</span><br><span class=\"line\">    [RunloopMonitor shareInstance].currentActivity = activity;</span><br><span class=\"line\">    dispatch_semaphore_signal([RunloopMonitor shareInstance].semphore);</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (activity) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> kCFRunLoopEntry:</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;runloop entry&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> kCFRunLoopExit:</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;runloop exit&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> kCFRunLoopAfterWaiting:</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;runloop after waiting&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> kCFRunLoopBeforeTimers:</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;runloop before timers&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> kCFRunLoopBeforeSources:</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;runloop before sources&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> kCFRunLoopBeforeWaiting:</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;runloop before waiting&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>UITableView代理代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSInteger</span>)tableView: (<span class=\"built_in\">UITableView</span> *)tableView numberOfRowsInSection: (<span class=\"built_in\">NSInteger</span>)section &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">500</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">UITableViewCell</span> *)tableView: (<span class=\"built_in\">UITableView</span> *)tableView cellForRowAtIndexPath: (<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;</span><br><span class=\"line\">    <span class=\"built_in\">UITableViewCell</span> * cell = [tableView dequeueReusableCellWithIdentifier: <span class=\"string\">@&quot;cell&quot;</span>];</span><br><span class=\"line\">    cell.textLabel.text = [<span class=\"built_in\">NSString</span> stringWithFormat: <span class=\"string\">@&quot;第%lu行&quot;</span>, indexPath.row];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (indexPath.row &gt; <span class=\"number\">0</span> &amp;&amp; indexPath.row % <span class=\"number\">30</span> == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        sleep(<span class=\"number\">2.0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cell;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)tableView: (<span class=\"built_in\">UITableView</span> *)tableView didSelectRowAtIndexPath: (<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;</span><br><span class=\"line\">    sleep(<span class=\"number\">2.0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行之后输出的结果是滚动引发的<code>Sources</code>事件总是被快速的执行完成，然后进入到<code>kCFRunLoopBeforeWaiting</code>状态下。假如在滚动过程中发生了卡顿现象，那么<code>RunLoop</code>必然会保持<code>kCFRunLoopAfterWaiting</code>或者<code>kCFRunLoopBeforeSources</code>这两个状态之一。</p>\n<p>为了实现卡顿的检测，首先需要注册<code>RunLoop</code>的监听回调，保存<code>RunLoop</code>状态；其次，通过创建子线程循环监听主线程<code>RunLoop</code>的状态来检测是否存在停留卡顿现象: <code>收到Sources相关的事件时，将超时阙值时间内分割成多个时间片段，重复去获取当前RunLoop的状态。如果多次处在处理事件的状态下，那么可以视作发生了卡顿现象</code></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)startMonitoring &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_isMonitoring) &#123; <span class=\"keyword\">return</span>; &#125;</span><br><span class=\"line\">    _isMonitoring = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    <span class=\"built_in\">CFRunLoopObserverContext</span> context = &#123; <span class=\"number\">0</span>, (__bridge <span class=\"type\">void</span> *)<span class=\"keyword\">self</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>&#125;;</span><br><span class=\"line\">    _observer = <span class=\"built_in\">CFRunLoopObserverCreate</span>(kCFAllocatorDefault, kCFRunLoopAllActivities, <span class=\"literal\">YES</span>, <span class=\"number\">0</span>, &amp;runLoopObserverCallback, &amp;context);</span><br><span class=\"line\">    <span class=\"built_in\">CFRunLoopAddObserver</span>(<span class=\"built_in\">CFRunLoopGetMain</span>(), _observer, kCFRunLoopCommonModes);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">dispatch_async</span>(event_monitor_queue(), ^&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ([RunloopMonitor shareInstance].isMonitoring) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ([RunloopMonitor shareInstance].currentActivity == kCFRunLoopBeforeWaiting) &#123;</span><br><span class=\"line\">                __block <span class=\"type\">BOOL</span> timeOut = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">                <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">                    timeOut = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">                    dispatch_semaphore_signal([RunloopMonitor shareInstance].eventSemphore);</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">                [<span class=\"built_in\">NSThread</span> sleepForTimeInterval: time_out_interval];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (timeOut) &#123;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                dispatch_wait([RunloopMonitor shareInstance].eventSemphore, DISPATCH_TIME_FOREVER);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">dispatch_async</span>(fluecy_monitor_queue(), ^&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ([RunloopMonitor shareInstance].isMonitoring) &#123;</span><br><span class=\"line\">            <span class=\"type\">long</span> waitTime = dispatch_semaphore_wait(<span class=\"keyword\">self</span>.semphore, dispatch_time(DISPATCH_TIME_NOW, wait_interval));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (waitTime != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (![RunloopMonitor shareInstance].observer) &#123;</span><br><span class=\"line\">                    [RunloopMonitor shareInstance].outTime = <span class=\"number\">0</span>;</span><br><span class=\"line\">                    [[RunloopMonitor shareInstance] stopMonitoring];</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ([RunloopMonitor shareInstance].currentActivity == kCFRunLoopBeforeSources || [RunloopMonitor shareInstance].currentActivity == kCFRunLoopAfterWaiting) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (++[RunloopMonitor shareInstance].outTime &lt; <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval: restore_interval];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            [RunloopMonitor shareInstance].outTime = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"标记位检测线程超时\"><a href=\"#标记位检测线程超时\" class=\"headerlink\" title=\"标记位检测线程超时\"></a>标记位检测线程超时</h2><p>与UI卡顿不同的事，事件处理往往是处在<code>kCFRunLoopBeforeWaiting</code>的状态下收到了<code>Sources</code>事件源，最开始笔者尝试同样以多个时间片段查询的方式处理。但是由于主线程的<code>RunLoop</code>在闲置时基本处于<code>Before Waiting</code>状态，这就导致了即便没有发生任何卡顿，这种检测方式也总能认定主线程处在卡顿状态。</p>\n<p>于是github上查看了下卡顿检测第三方监测卡顿的工具，他们的卡顿监控方案大致思路为：创建一个子线程进行循环检测，每次检测时设置标记位为<code>YES</code>，然后派发任务到主线程中将标记位设置为<code>NO</code>。接着子线程沉睡超时阙值时长，判断标志位是否成功设置成<code>NO</code>。如果没有说明主线程发生了卡顿，无法处理派发任务：</p>\n<p>![图片 1](图片 1.png)</p>\n<h2 id=\"获取堆栈\"><a href=\"#获取堆栈\" class=\"headerlink\" title=\"获取堆栈\"></a>获取堆栈</h2><p>子线程监控发现卡顿后，还需要记录当前出现卡顿的方法堆栈信息，并适时推送到服务端供开发者分析，从而解决卡顿问题。那么，在这个过程中，如何获取卡顿的方法堆栈信息呢？</p>\n<p>这里我选择了魔改<a href=\"https://github.com/bestswifter/BSBacktraceLogger\">BSBacktraceLogger</a></p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>多数开发者对于<code>RunLoop</code>可能并没有进行实际的应用开发过，或者说即便了解<code>RunLoop</code>也只是处在理论的认知上。本文仅仅是对采用runloop来进行APP卡顿的一些个人观点，有纰漏还望指出。</p>\n<p><a href=\"https://github.com/eziochiu/RunLoopMonitor.git\">Demo</a></p>\n","site":{"data":{}},"length":9415,"excerpt":"<p>卡顿问题，就是在主线程上无法响应用户交互的问题。如果一个 App 时不时地就给你卡一下，有时还长时间无响应，这时你还愿意继续用它吗？所以说，卡顿问题对 App 的伤害是巨大的</p>\n<h2 id><a href=\"#\" class=\"headerlink\" title></a></h2>","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>用runloop来监测卡顿其实并不是什么比较前沿的技术，也不算什么新奇的技术，实际上开发者也用的比较少。一来，应为 <code>XCode</code> 的<code>instrument</code>足够的优秀，几乎所有的监控操作都有对应的工具。二来，大多数项目上都是集成第三方的统计工具，比如Bugly、友盟之类的等等。但是这样也暴露了一些问题，集成第三方会担心自己的APP信息泄露，那怎么办呢？所以这套自己通过runloop的检测也就营运而生。</p>\n<h2 id=\"卡顿可能产生的原因\"><a href=\"#卡顿可能产生的原因\" class=\"headerlink\" title=\"卡顿可能产生的原因\"></a>卡顿可能产生的原因</h2><p>一般来讲卡顿产生的原因可以大致分为以下几种类型：</p>\n<p>1、复杂 UI 、图文混排的绘制量过大；</p>\n<p>2、在主线程上做网络同步请求；</p>\n<p>4、在主线程做大量的 IO 操作；</p>\n<p>4、运算量过大，CPU 持续高占用；死锁和主子线程抢锁</p>\n<p>那么问题来了，我们如何来做卡顿的监测呢？只是单纯的检测FPS的波动吗？FPS又是什么呢？维基百科显示FPS，即每秒显示帧数 或者 每秒显示张数 - <a href=\"https://zh.wikipedia.org/wiki/%E5%B8%A7%E7%8E%87\">影格率</a>测量单位（这里牵扯到CPU和GPU同步的问题，相关只是点就不在陈述了）。也就是说简单地通过监视 FPS 是很难确定是否会出现卡顿，所以FPS是不能作为用来检测卡顿的标准的。那我们应该通过什么来监测卡顿呢？</p>\n<h2 id=\"关于RunLoop\"><a href=\"#关于RunLoop\" class=\"headerlink\" title=\"关于RunLoop\"></a>关于RunLoop</h2><p>对于iOS开发人员来说，runloop相信大家一定不会陌生，因为他是在日常开发中的一个基础概念，我们都知道，线程的消息事件是依赖于 RunLoop 的，所以从 RunLoop 入手，就可以知道主线程上都调用了哪些方法。我们通过监听 RunLoop 的状态，就能够发现调用方法是否执行时间过长，从而判断出是否会出现卡顿。</p>\n<p>当然，如果你要在RunLoop中监测哪些方法的运行时间过长，首先你必须得清楚RunLoop的运行原理，知道了运行原理之后才能知道我们要在RunLoop的哪个环节进行监测。</p>\n<h3 id=\"第一步：通知Observers：即将进入RunLoop\"><a href=\"#第一步：通知Observers：即将进入RunLoop\" class=\"headerlink\" title=\"第一步：通知Observers：即将进入RunLoop\"></a>第一步：通知Observers：即将进入RunLoop</h3><p>我们在<a href=\"http://opensource.apple.com/tarballs/CF/CF-1153.18.tar.gz\">CFRunLoop-1153.18</a>的源码的第2676行中的<code>CFRunLoopRun(void)</code>中，开启一个<code>do..while</code>循环来保活</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void CFRunLoopRun(void) &#123;\t/* DOES CALLOUT */</span><br><span class=\"line\">    int32_t result;</span><br><span class=\"line\">    do &#123;</span><br><span class=\"line\">        result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);</span><br><span class=\"line\">        CHECK_FOR_FORK();</span><br><span class=\"line\">    &#125; while (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那我们的重点就在<code>CFRunLoopRunSpecific</code>这个方法内部是如何实现的了，我们接下来往下看。<code>CFRunLoopRunSpecific</code>是<code>runloop</code>的启动入口</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//即将进入runloop</span><br><span class=\"line\">if (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class=\"line\">result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class=\"line\">if (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"第二步：通知Observers：即将处理Timers和即将处理Sources和blocks\"><a href=\"#第二步：通知Observers：即将处理Timers和即将处理Sources和blocks\" class=\"headerlink\" title=\"第二步：通知Observers：即将处理Timers和即将处理Sources和blocks\"></a>第二步：通知Observers：即将处理Timers和即将处理Sources和blocks</h3><p>触发times、source0</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__CFRunLoopUnsetIgnoreWakeUps(rl);</span><br><span class=\"line\">if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);//即将处理Timers</span><br><span class=\"line\">if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);//即将处理Sources</span><br><span class=\"line\">__CFRunLoopDoBlocks(rl, rlm);//处理blocks</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"第三步：处理-Source0\"><a href=\"#第三步：处理-Source0\" class=\"headerlink\" title=\"第三步：处理 Source0\"></a>第三步：处理 Source0</h3><p>到了这一步可能会再次处理一遍blocks</p>\n<p>如果有 Source1 是 ready 状态的话，就会跳转到 handle_msg 去处理消息。代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class=\"line\">    if (sourceHandledThisLoop) &#123;</span><br><span class=\"line\">    __CFRunLoopDoBlocks(rl, rlm);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context-&gt;termTSR);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123;</span><br><span class=\"line\">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span><br><span class=\"line\">       msg = (mach_msg_header_t *)msg_buffer;</span><br><span class=\"line\">      //MachPort处于等待中，runloop则会去处理handle_msg</span><br><span class=\"line\">       if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0, &amp;voucherState, NULL)) &#123;</span><br><span class=\"line\">           goto handle_msg;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">#elif DEPLOYMENT_TARGET_WINDOWS</span><br><span class=\"line\">       if (__CFRunLoopWaitForMultipleObjects(NULL, &amp;dispatchPort, 0, 0, &amp;livePort, NULL)) &#123;</span><br><span class=\"line\">           goto handle_msg;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">#endif</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    didDispatchPortLastTime = false;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"第四步：通知Observers：开始休眠（等待消息唤醒）\"><a href=\"#第四步：通知Observers：开始休眠（等待消息唤醒）\" class=\"headerlink\" title=\"第四步：通知Observers：开始休眠（等待消息唤醒）\"></a>第四步：通知Observers：开始休眠（等待消息唤醒）</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//通知Observers：开始休眠</span><br><span class=\"line\">if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class=\"line\">__CFRunLoopSetSleeping(rl);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"第五步：通知Observers：结束休眠（被某个消息唤醒）\"><a href=\"#第五步：通知Observers：结束休眠（被某个消息唤醒）\" class=\"headerlink\" title=\"第五步：通知Observers：结束休眠（被某个消息唤醒）\"></a>第五步：通知Observers：结束休眠（被某个消息唤醒）</h3><p>RunLoop 被唤醒后就要开始处理消息了：（这一段代码太长，就不直接贴出来了）</p>\n<ul>\n<li><p>如果是 Timer 时间到的话，就触发 Timer 的回调；</p>\n</li>\n<li><p>处理 GCD Async To Main Queue；</p>\n</li>\n<li><p>如果是 source1(MachPor) 事件的话，就处理这个事件。</p>\n</li>\n<li><p>再次处理Blocks</p>\n</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span></span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (kCFUseCollectableAllocator) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// objc_clear_stack(0);</span></span><br><span class=\"line\">                <span class=\"comment\">// &lt;rdar://problem/16393959&gt;</span></span><br><span class=\"line\">                memset(msg_buffer, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(msg_buffer));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            msg = (mach_msg_header_t *)msg_buffer;</span><br><span class=\"line\">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class=\"keyword\">sizeof</span>(msg_buffer), &amp;livePort, poll ? <span class=\"number\">0</span> : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Drain the internal queue. If one of the callout blocks sets the timerFired flag, break out and service the timer.</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (_dispatch_runloop_root_queue_perform_4CF(rlm-&gt;_queue));</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (rlm-&gt;_timerFired) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Leave livePort as the queue port, and service timers below</span></span><br><span class=\"line\">                    rlm-&gt;_timerFired = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Go ahead and leave the inner loop.</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (<span class=\"number\">1</span>);</span><br><span class=\"line\">(省略)........</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"第六步：根据上一步的操作决定是退出runloop还是继续执行runloop\"><a href=\"#第六步：根据上一步的操作决定是退出runloop还是继续执行runloop\" class=\"headerlink\" title=\"第六步：根据上一步的操作决定是退出runloop还是继续执行runloop\"></a>第六步：根据上一步的操作决定是退出runloop还是继续执行runloop</h3><p>根据上一步的操作决定是退出runloop还是继续执行runloop</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class=\"line\">\t    retVal = kCFRunLoopRunHandledSource;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class=\"line\">            retVal = kCFRunLoopRunTimedOut;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class=\"line\">            __CFRunLoopUnsetStopped(rl);</span><br><span class=\"line\">\t    retVal = kCFRunLoopRunStopped;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (rlm-&gt;_stopped) &#123;</span><br><span class=\"line\">\t    rlm-&gt;_stopped = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t    retVal = kCFRunLoopRunStopped;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class=\"line\">\t    retVal = kCFRunLoopRunFinished;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"RunLoop的六个状态\"><a href=\"#RunLoop的六个状态\" class=\"headerlink\" title=\"RunLoop的六个状态\"></a>RunLoop的六个状态</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">CF_OPTIONS</span>(<span class=\"built_in\">CFOptionFlags</span>, <span class=\"built_in\">CFRunLoopActivity</span>) &#123;</span><br><span class=\"line\">    kCFRunLoopEntry = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">0</span>),\t\t\t\t\t\t<span class=\"comment\">//即将进入RunLoop</span></span><br><span class=\"line\">    kCFRunLoopBeforeTimers = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">1</span>),\t\t<span class=\"comment\">//即将处理Timers</span></span><br><span class=\"line\">    kCFRunLoopBeforeSources = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">2</span>),\t\t<span class=\"comment\">//即将处理Source</span></span><br><span class=\"line\">    kCFRunLoopBeforeWaiting = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">5</span>),\t\t<span class=\"comment\">//即将休眠</span></span><br><span class=\"line\">    kCFRunLoopAfterWaiting = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">6</span>),\t\t<span class=\"comment\">//即将唤醒</span></span><br><span class=\"line\">    kCFRunLoopExit = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">7</span>),\t\t\t\t\t\t<span class=\"comment\">//退出RunLoop</span></span><br><span class=\"line\">    kCFRunLoopAllActivities = <span class=\"number\">0x0FFFFFFF</span>U</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>用一张图概括RunLoop的运行轨迹</p>\n<p><img src=\"/2019/09/11/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8RunLoop%E7%9A%84%E7%9F%A5%E8%AF%86%E6%9D%A5%E7%9B%91%E6%B5%8BAPP%E5%8D%A1%E9%A1%BF/5f51c5e05085badb689f01b1e63e1c7d.png\" alt=\"runloop\"></p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>通过上面的runloop运行轨迹我们能够知道，RunLoop&#96;处理事件的时间主要出在两个阶段：</p>\n<ul>\n<li><code>kCFRunLoopBeforeSources</code>和<code>kCFRunLoopBeforeWaiting</code>之间</li>\n<li><code>kCFRunLoopAfterWaiting</code>之后</li>\n</ul>\n<p>试想如果 RunLoop 的线程，进入睡眠前方法的执行时间过长而导致无法进入睡眠，或者线程唤醒后接收消息时间过长而无法进入下一步的话，就可以认为是线程受阻了。如果这个线程是主线程的话，表现出来的就是出现了卡顿。所以，如果我们要利用 RunLoop 原理来监控卡顿的话，就是要关注这三个阶段。</p>\n<p>接下来，我们就一起分析一下，如何对 loop 的这两个状态进行监听，以及监控的时间值如何设置才合理。</p>\n<h2 id=\"监控RunLoop状态检测超时\"><a href=\"#监控RunLoop状态检测超时\" class=\"headerlink\" title=\"监控RunLoop状态检测超时\"></a>监控RunLoop状态检测超时</h2><p>通过<code>RunLoop</code>的源码我们已经知道了主线程处理事件的时间，那么如何检测应用是否发生了卡顿呢？为了找到合理的处理方案，我们得先在项目中得到runloop的监听状态。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"type\">void</span> runLoopObserverCallback(<span class=\"built_in\">CFRunLoopObserverRef</span> observer, <span class=\"built_in\">CFRunLoopActivity</span> activity, <span class=\"type\">void</span> * info) &#123;</span><br><span class=\"line\">    [RunloopMonitor shareInstance].currentActivity = activity;</span><br><span class=\"line\">    dispatch_semaphore_signal([RunloopMonitor shareInstance].semphore);</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (activity) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> kCFRunLoopEntry:</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;runloop entry&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> kCFRunLoopExit:</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;runloop exit&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> kCFRunLoopAfterWaiting:</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;runloop after waiting&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> kCFRunLoopBeforeTimers:</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;runloop before timers&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> kCFRunLoopBeforeSources:</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;runloop before sources&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> kCFRunLoopBeforeWaiting:</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;runloop before waiting&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>UITableView代理代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSInteger</span>)tableView: (<span class=\"built_in\">UITableView</span> *)tableView numberOfRowsInSection: (<span class=\"built_in\">NSInteger</span>)section &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">500</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">UITableViewCell</span> *)tableView: (<span class=\"built_in\">UITableView</span> *)tableView cellForRowAtIndexPath: (<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;</span><br><span class=\"line\">    <span class=\"built_in\">UITableViewCell</span> * cell = [tableView dequeueReusableCellWithIdentifier: <span class=\"string\">@&quot;cell&quot;</span>];</span><br><span class=\"line\">    cell.textLabel.text = [<span class=\"built_in\">NSString</span> stringWithFormat: <span class=\"string\">@&quot;第%lu行&quot;</span>, indexPath.row];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (indexPath.row &gt; <span class=\"number\">0</span> &amp;&amp; indexPath.row % <span class=\"number\">30</span> == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        sleep(<span class=\"number\">2.0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cell;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)tableView: (<span class=\"built_in\">UITableView</span> *)tableView didSelectRowAtIndexPath: (<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;</span><br><span class=\"line\">    sleep(<span class=\"number\">2.0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行之后输出的结果是滚动引发的<code>Sources</code>事件总是被快速的执行完成，然后进入到<code>kCFRunLoopBeforeWaiting</code>状态下。假如在滚动过程中发生了卡顿现象，那么<code>RunLoop</code>必然会保持<code>kCFRunLoopAfterWaiting</code>或者<code>kCFRunLoopBeforeSources</code>这两个状态之一。</p>\n<p>为了实现卡顿的检测，首先需要注册<code>RunLoop</code>的监听回调，保存<code>RunLoop</code>状态；其次，通过创建子线程循环监听主线程<code>RunLoop</code>的状态来检测是否存在停留卡顿现象: <code>收到Sources相关的事件时，将超时阙值时间内分割成多个时间片段，重复去获取当前RunLoop的状态。如果多次处在处理事件的状态下，那么可以视作发生了卡顿现象</code></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)startMonitoring &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_isMonitoring) &#123; <span class=\"keyword\">return</span>; &#125;</span><br><span class=\"line\">    _isMonitoring = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    <span class=\"built_in\">CFRunLoopObserverContext</span> context = &#123; <span class=\"number\">0</span>, (__bridge <span class=\"type\">void</span> *)<span class=\"keyword\">self</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>&#125;;</span><br><span class=\"line\">    _observer = <span class=\"built_in\">CFRunLoopObserverCreate</span>(kCFAllocatorDefault, kCFRunLoopAllActivities, <span class=\"literal\">YES</span>, <span class=\"number\">0</span>, &amp;runLoopObserverCallback, &amp;context);</span><br><span class=\"line\">    <span class=\"built_in\">CFRunLoopAddObserver</span>(<span class=\"built_in\">CFRunLoopGetMain</span>(), _observer, kCFRunLoopCommonModes);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">dispatch_async</span>(event_monitor_queue(), ^&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ([RunloopMonitor shareInstance].isMonitoring) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ([RunloopMonitor shareInstance].currentActivity == kCFRunLoopBeforeWaiting) &#123;</span><br><span class=\"line\">                __block <span class=\"type\">BOOL</span> timeOut = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">                <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">                    timeOut = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">                    dispatch_semaphore_signal([RunloopMonitor shareInstance].eventSemphore);</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">                [<span class=\"built_in\">NSThread</span> sleepForTimeInterval: time_out_interval];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (timeOut) &#123;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                dispatch_wait([RunloopMonitor shareInstance].eventSemphore, DISPATCH_TIME_FOREVER);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">dispatch_async</span>(fluecy_monitor_queue(), ^&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ([RunloopMonitor shareInstance].isMonitoring) &#123;</span><br><span class=\"line\">            <span class=\"type\">long</span> waitTime = dispatch_semaphore_wait(<span class=\"keyword\">self</span>.semphore, dispatch_time(DISPATCH_TIME_NOW, wait_interval));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (waitTime != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (![RunloopMonitor shareInstance].observer) &#123;</span><br><span class=\"line\">                    [RunloopMonitor shareInstance].outTime = <span class=\"number\">0</span>;</span><br><span class=\"line\">                    [[RunloopMonitor shareInstance] stopMonitoring];</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ([RunloopMonitor shareInstance].currentActivity == kCFRunLoopBeforeSources || [RunloopMonitor shareInstance].currentActivity == kCFRunLoopAfterWaiting) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (++[RunloopMonitor shareInstance].outTime &lt; <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval: restore_interval];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            [RunloopMonitor shareInstance].outTime = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"标记位检测线程超时\"><a href=\"#标记位检测线程超时\" class=\"headerlink\" title=\"标记位检测线程超时\"></a>标记位检测线程超时</h2><p>与UI卡顿不同的事，事件处理往往是处在<code>kCFRunLoopBeforeWaiting</code>的状态下收到了<code>Sources</code>事件源，最开始笔者尝试同样以多个时间片段查询的方式处理。但是由于主线程的<code>RunLoop</code>在闲置时基本处于<code>Before Waiting</code>状态，这就导致了即便没有发生任何卡顿，这种检测方式也总能认定主线程处在卡顿状态。</p>\n<p>于是github上查看了下卡顿检测第三方监测卡顿的工具，他们的卡顿监控方案大致思路为：创建一个子线程进行循环检测，每次检测时设置标记位为<code>YES</code>，然后派发任务到主线程中将标记位设置为<code>NO</code>。接着子线程沉睡超时阙值时长，判断标志位是否成功设置成<code>NO</code>。如果没有说明主线程发生了卡顿，无法处理派发任务：</p>\n<p>![图片 1](图片 1.png)</p>\n<h2 id=\"获取堆栈\"><a href=\"#获取堆栈\" class=\"headerlink\" title=\"获取堆栈\"></a>获取堆栈</h2><p>子线程监控发现卡顿后，还需要记录当前出现卡顿的方法堆栈信息，并适时推送到服务端供开发者分析，从而解决卡顿问题。那么，在这个过程中，如何获取卡顿的方法堆栈信息呢？</p>\n<p>这里我选择了魔改<a href=\"https://github.com/bestswifter/BSBacktraceLogger\">BSBacktraceLogger</a></p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>多数开发者对于<code>RunLoop</code>可能并没有进行实际的应用开发过，或者说即便了解<code>RunLoop</code>也只是处在理论的认知上。本文仅仅是对采用runloop来进行APP卡顿的一些个人观点，有纰漏还望指出。</p>\n<p><a href=\"https://github.com/eziochiu/RunLoopMonitor.git\">Demo</a></p>"},{"title":"【转载】iOS进程间是如何通信的","top":0,"date":"2019-03-12T06:27:27.000Z","banner_img":null,"_content":"\n# 总起\n\nOS X是MacOS与NeXTSTEP的结合。OC是Smalltalk类面向对象编程与C的结合。iCloud则是苹果移动服务与云平台的结合。\n\n上述都是一些亮点，但是不得不说苹果技术中的进程通讯走的是“反人类”的道路。\n\n由于不是根据每个节点上最优原则进行设计，苹果的进程间通信解决方案更显得混乱扎堆。结果是，大量重叠，不兼容的IPC技术在各个抽象层随处可见。（除了GCD还有剪贴板）\n\n* Mach Ports\n* Distributed Notifications\n* Distributed Objects\n* AppleEvents & AppleScript\n* Pasteboard\n* XPC\n\n从低级内核抽象到高级，面向对象的API，它们都有各自特殊的表现以及安全特性。但是基础层面来看，它们都是从不同上下文段传递或者获取数据的机制。\n\n<!-- more -->\n\n[原文链接](https://nshipster.com/inter-process-communication/)    [转载自此处](https://segmentfault.com/a/1190000002400329)\n\n# Mach Ports\n所有的进程间通讯最终落实依赖的还是Mach内核API提供的功能。\n\nMach端口是轻量并且强大的而又缺少相关文档晦涩使用的（天使与恶魔）。\n\n通过一个Mach端口发送一个消息调用一次mach_msg_send方法，但是这里需要做一些配置来构建待发送的消息：\n\n```\nnatural_t data;\nmach_port_t port;\n\nstruct {\n    mach_msg_header_t header;\n    mach_msg_body_t body;\n    mach_msg_type_descriptor_t type;\n} message;\n\nmessage.header = (mach_msg_header_t) {\n    .msgh_remote_port = port,\n    .msgh_local_port = MACH_PORT_NULL,\n    .msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, 0),\n    .msgh_size = sizeof(message)\n};\n\nmessage.body = (mach_msg_body_t) {\n    .msgh_descriptor_count = 1\n};\n\nmessage.type = (mach_msg_type_descriptor_t) {\n    .pad1 = data,\n    .pad2 = sizeof(data)\n};\n\nmach_msg_return_t error = mach_msg_send(&message.header);\n\nif (error == MACH_MSG_SUCCESS) {\n    // ...\n}\n```\n\n（消息）接收端稍微轻松点，因为消息只需要被声明而不用初始化：\n\n```\nmach_port_t port;\n\nstruct {\n    mach_msg_header_t header;\n    mach_msg_body_t body;\n    mach_msg_type_descriptor_t type;\n    mach_msg_trailer_t trailer;\n} message;\n\nmach_msg_return_t error = mach_msg_receive(&message.header);\n\nif (error == MACH_MSG_SUCCESS) {\n    natural_t data = message.type.pad1;\n    // ...\n}\n```\n\n还算不错的是，Core Foundation和Foundation为Mach端口提供了高级API。在内核基础上封装的CFMachPort / NSMachPort可以用做runloop源，尽管CFMachPort / NSMachPort有利于的是两个不同端口之间的通讯同步。\n\nCFMessagePort确实非常适合用于简单的一对一通讯。简简单单几行代码，一个本地端口就被附属到runloop源上，只要获取到消息就执行回调。\n\n```\nstatic CFDataRef Callback(CFMessagePortRef port,\n                          SInt32 messageID,\n                          CFDataRef data,\n                          void *info)\n{\n    // ...\n}\n\nCFMessagePortRef localPort =\n    CFMessagePortCreateLocal(nil,\n                             CFSTR(\"com.example.app.port.server\"),\n                             Callback,\n                             nil,\n                             nil);\n\nCFRunLoopSourceRef runLoopSource =\n    CFMessagePortCreateRunLoopSource(nil, localPort, 0);\n\nCFRunLoopAddSource(CFRunLoopGetCurrent(),\n                   runLoopSource,\n                   kCFRunLoopCommonModes);\n```\n\n若要进行发送数据同样也十分直截了当。只要完成指定远端的端口，装载数据，还有设置发送与接收的超时时间的操作。剩下就由CFMessagePortSendRequest来接管了。\n\n```\nCFDataRef data;\nSInt32 messageID = 0x1111; // Arbitrary\nCFTimeInterval timeout = 10.0;\n\nCFMessagePortRef remotePort =\n    CFMessagePortCreateRemote(nil,\n                              CFSTR(\"com.example.app.port.client\"));\n\nSInt32 status =\n    CFMessagePortSendRequest(remotePort,\n                             messageID,\n                             data,\n                             timeout,\n                             timeout,\n                             NULL,\n                             NULL);\nif (status == kCFMessagePortSuccess) {\n    // ...\n}\n```\n\n# Distributed Notifications\n\n在Cocoa中有很多种两个对象进行通信的途径。\n\n当然也能进行直接消息传递。也有像目标-动作，代理，回调这些解耦，一对一的设计模式。KVO允许让很多对象订阅一个事件，但是它把这些对象都联系起来了。另一方面通知让消息全局广播，并且让有监听该广播的对象接收该消息。【注：想知道发了多少次广播吗？添加 NSNotificationCenter addObserverForName:object:queue:usingBlock，其中name与object置nil，看block被调用了几次。】\n\n每个应用为基础应用消息发布-订阅对自身通知中心实例进行管理。但是鲜有人知的APICFNotificationCenterGetDistributedCenter的通知可以进行系统级别范围的通信。\n\n为了获取通知，添加所要指定监听消息名的观察者到通知发布中心，当消息接收到的时候函数指针指向的函数将被执行一次：\n\n```\nstatic void Callback(CFNotificationCenterRef center,\n                     void *observer,\n                     CFStringRef name,\n                     const void *object,\n                     CFDictionaryRef userInfo)\n{\n    // ...\n}\n\nCFNotificationCenterRef distributedCenter =\n    CFNotificationCenterGetDistributedCenter();\n\nCFNotificationSuspensionBehavior behavior =\n        CFNotificationSuspensionBehaviorDeliverImmediately;\n\nCFNotificationCenterAddObserver(distributedCenter,\n                                NULL,\n                                Callback,\n                                CFSTR(\"notification.identifier\"),\n                                NULL,\n                                behavior);\n\n```\n\n发送端代码更为简单，只要配置好ID,对象还有user info：\n\n```\nvoid *object;\nCFDictionaryRef userInfo;\n\nCFNotificationCenterRef distributedCenter =\n    CFNotificationCenterGetDistributedCenter();\n\nCFNotificationCenterPostNotification(distributedCenter,\n                                     CFSTR(\"notification.identifier\"),\n                                     object,\n                                     userInfo,\n                                     true);\n```\n\n链接两个应用通信的方式中，分发式通知是最为简单的。用它来进行大量数据的传输是不明智的，但是对于轻量级信息同步，分发式通知堪称完美。\n\n# Distributed Objects\n\n90年代中NeXT全盛时期，分发式对象（DO）是Cocoa框架中一个远程消息发送特性。尽管现在已经不再大范围的使用，在现代奇数层上IPC无障碍通信仍然并未实现。\n\n使用DO分发一个对象仅仅是搭建一个NSConnection并将其注册为特殊（你分的清楚）的名字：\n\n```\n@protocol Protocol;\n\nid <Protocol> vendedObject;\n\nNSConnection *connection = [[NSConnection alloc] init];\n[connection setRootObject:vendedObject];\n[connection registerName:@\"server\"];\n```\n\n另外一个应用将会也建立同样名字的并注册过的链接，然后立即获取一个原子代理当做原始对象。\n\n```\nid proxy = [NSConnection rootProxyForConnectionWithRegisteredName:@\"server\" host:nil];\n[proxy setProtocolForProxy:@protocol(Protocol)];\n```\n\n只要分发对象代理收到消息了，一个通过NSConnection连接远程调用（RPC）将会根据发送对象进行对应的计算并且返回结果给代理。【注：原理是一个OS管理的共享的NSPortNameServer实例对这个带着名字的连接进行管控。】\n\n分发式对象简单，透明，健壮。简直就是Cocoa中的标杆。。。\n\n实际上，分布式对象不能像局部对象那样使用，那就是因为任何发送给代理的消息都可能抛出异常。不想其他语言，OC没有异常处理控制流程。所以对任何东西都进行@try/@catch也算是Cocoa大会很凄凉的补救了。\n\nDO还有一个原因致其使用不便。在试图通过连接“marshal values”时，对象和原语的差距尤为明显。\n此外，连接是完全加密的，和下方通信信道扩展性的缺乏致使其在大多数的使用中通信被迫中断。\n\n下方是左列分布式对象用来指定其属性代理行为和方法参数的注解：\n\n* in：输入参数，后续不再引用\n* out：参数被引用作为返回值\n* inout：输入参数，引用作为返回值\n* const：常量参数\n* oneway：无障碍结果返回\n* bycopy：返回对象的拷贝\n* byref：返回对象的代理\n\n\n# AppleEvents & AppleScript\n\nAppleEvents是经典Macintosh操作系统最持久的遗产。在System 7推出的AppleEvents允许应用程序在本地使用AppleScript或者使用程序链接的功能进行程序控制。现在AppleScript使用Cocoa Scripting Bridge，仍然是OS X应用进程间最直接的交互方式。【注：Mac系统的苹果时间管理中心为AppleEvents提供了原始低级传送机制，但是是在OS X的Mach端口基础之上的重实现】。\n\n也就是说，使用起来这是简单而又古怪的技术之一。\n\nAppleScript使用自然语言语法，设计初衷是没有涉及参数而更容易掌握。虽然与人交流更亲和了，但是写起来确实噩梦。\n\n为了更好的了解人类自然性，这里有个栗子教你怎么让Safari在最前的窗口的激活栏打开一个URL。\n\n```\ntell application \"Safari\"\n  set the URL of the front document to \"http://nshipster.com\"\nend tell\n```\n\n在大部分情况下，AppleScript的语法自然语言的特性更多是不便不是优势。（吐槽。。。略略略）\n\n即便是经验老道的OC开发者，不靠文档或者栗子写出AppleScript是不可能的任务。\n\n幸运的是，Scripting Bridge为Cocoa应用提供了更友善的编程接口。\n\n# Cocoa Scripting Bridge\n\n为了使用Scripting Bridge与应用进行交互，首先要先添加一个编程接口：\n\n```\n$ sdef /Applications/Safari.app | sdp -fh --basename Safari\n```\n\nsdef为应用生成脚本定义文件。这些文件可以以管道输入道sdp并格式转成（在这里是）C头文件。这样的结果是添加该头文件到应用工程并提供第一类对象接口。\n\n这里举个栗子来解释如何使用Cocoa Scripting Bridge：\n\n```\n#import \"Safari.h\"\n\nSafariApplication *safari = [SBApplication applicationWithBundleIdentifier:@\"com.apple.Safari\"];\n\nfor (SafariWindow *window in safari.windows) {\n    if (window.visible) {\n        window.currentTab.URL = [NSURL URLWithString:@\"http://nshipster.com\"];\n        break;\n    }\n}\n```\n\n对比AppleScript上面显得冗繁了点，但是却更容易集成到已存在的代码中去。在可读性上更优因为毕竟长得更像OC。\n\n唉，AppleScript的星芒也正出现消退，在最近发布的OS X与iWork应用证答复减少它的戏份。从这点说，未必值得在你的应用中去添加这项（脚本）支持。\n\n# Pasteboard\n\n剪贴板是OS X与iOS最常见的进程间通信机制。当用户跨应用拷贝了一段文字，图片，文档，这时候通过mach port的com.apple.pboard服务媒介进行从一个进程到另一个进程的数据交换。\n\nOS X上是NSPasteboard，iOS上对应的是UIPasteboard。它们几乎是别无二致，但尽管大致一样，对比OS X iOS上提供了更简洁，更现代化却又不影响功效的API。\n\n编写剪贴板代码几乎就跟在GUI应用上使用Edit > Copy操作一样简单：\n\n```\nNSImage *image;\n\nNSPasteboard *pasteboard = [NSPasteboard generalPasteboard];\n[pasteboard clearContents];\n[pasteboard writeObjects:@[image]];\n```\n\n因为剪贴动作太频繁了，所以要确认剪贴内容是否是你（应用）所需要得：\n\n```\nNSPasteboard *pasteboard = [NSPasteboard generalPasteboard];\n\nif ([pasteboard canReadObjectForClasses:@[[NSImage class]] options:nil]) {\n    NSArray *contents = [pasteboard readObjectsForClasses:@[[NSImage class]] options: nil];\n    NSImage *image = [contents firstObject];\n}\n```\n\n# XPC\n\nXPC是SDK中最先进的进程间通讯技术。它架构之初的目的在于避免长时间得运行过程，来适应有限的资源，在可能运行的时候才进行初始化。把XPC纳入应用而不做任何事情的想法是不现实的，但这样提供了更好的进程间的特权分离和故障隔离。\n\nXPC作为NSTask替代品甚至更多。\n\n2011推出以来，XPC为OS X上的应用沙盒提供基础设施，iOS上的远程试图控制器，还有两个平台上的应用扩展。它还广范围的用在系统框架和第一方应用：\n\n```\n$ find /Applications -name \\*.xpc\n```\n\n控制台输入上面的命令行你会知道XPC无处不在。在一般应用中同样的情形也在发生，比如图片或者视频转变服务，系统调用，网页服务加载，或是第三方的授权。\n\nXPC负责进程间通讯的同时还负责该服务生命周期的管理。包括注册服务，启动，以及通过launchd解决服务之间的通讯。一个XPC服务可以根据需求地洞，或者在崩溃的时候重启，或者是空闲的时候终止。正因如此，服务可以完全被设计成无状态的，以便于在运行的任何时间点的突然终止都能做到影响不大。\n\n作为被iOS还有OS X中backported所采用的安全模块，XPC服务默认运行在最为严格的环境：不能访问文件，不能访问网络，没有根权限升级。任何能做的事情就是对照被赋予的白名单列表。\n\nXPC可以被libxpc C API访问，或者是NSXPCConnection OC API。【注：作者会用低级API去实现（纯C）】\n\nXPC服务要么存在于应用的沙盒中亦或是使用launchd调用跑在后台。\n\n服务调用带事件句柄的xpc_main来获取新的XPC连接。\n\n```\nstatic void connection_handler(xpc_connection_t peer) {\n    xpc_connection_set_event_handler(peer, ^(xpc_object_t event) {\n        peer_event_handler(peer, event);\n    });\n\n    xpc_connection_resume(peer);\n}\n\nint main(int argc, const char *argv[]) {\n   xpc_main(connection_handler);\n   exit(EXIT_FAILURE);\n}\n```\n\n每个XPC连接是一对一的，意味着服务在不同的连接进行操作，每次调用xpc_connection_create就会创建一个新的链接。【注：类似BSD套接字中的API accept函数，服务在单个文件描述符进行监听来为范围内的链接创建额外描述符】：\n\n```\nxpc_connection_t c = xpc_connection_create(\"com.example.service\", NULL);\nxpc_connection_set_event_handler(c, ^(xpc_object_t event) {\n    // ...\n});\nxpc_connection_resume(c);\n```\n\n当一个消息发送到XPC链接，将自动的派发到一个由runtime管理的消息队列中。当链接的远端一旦开启的时候，消息将出队并被发送。\n\n每个消息就是一个字典，字符串key和强类型值：\n\n```\nxpc_dictionary_t message = xpc_dictionary_create(NULL, NULL, 0);\nxpc_dictionary_set_uint64(message, \"foo\", 1);\nxpc_connection_send_message(c, message);\nxpc_release(message)\n```\n\nXPC对象对下列原始类型进行操作：\n\n* Data\n* Boolean\n* Double\n* String\n* Signed Integer\n* Unsigned Integer\n* Date\n* UUID\n* Array\n* Dictionary\n* Null\n\n\nXPC提供了一个便捷的方法来从dispatch_data_t数据类型进行转换，这样从GCD到XPC的工作流程就简化了：\n\n```\nvoid *buffer;\nsize_t length;\ndispatch_data_t ddata =\n    dispatch_data_create(buffer,\n                         length,\n                         DISPATCH_TARGET_QUEUE_DEFAULT,\n                         DISPATCH_DATA_DESTRUCTOR_MUNMAP);\n\nxpc_object_t xdata = xpc_data_create_with_dispatch_data(ddata);\n```\n\n# 服务注册\n\nXPC可以注册成启动项任务，配置成匹配IOKit事件自动启动，BSD通知或者是CFDistributedNotifications。这些标准都指定在服务的launchd.plist文件里：\n.launchd.plist\n\n```\n<key>LaunchEvents</key>\n<dict>\n  <key>com.apple.iokit.matching</key>\n  <dict>\n      <key>com.example.device-attach</key>\n      <dict>\n          <key>idProduct</key>\n          <integer>2794</integer>\n          <key>idVendor</key>\n          <integer>725</integer>\n          <key>IOProviderClass</key>\n          <string>IOUSBDevice</string>\n          <key>IOMatchLaunchStream</key>\n          <true/>\n          <key>ProcessType</key>\n          <string>Adaptive</string>\n      </dict>\n  </dict>\n</dict>\n```\n\n最近一次对于launchd属性列表的修改是增加了ProcessType Key，其用来在高级层面上描述启动机构的预期目的。根据预描述行为期望，操作系统会响应调整CPU和I/O的阈值。\n\n![图片描述](articlex.png)\n\n为了注册一个服务运行大概五分钟的时间，一套标准需要传送给xpc_activity_register：\n\n```\nxpc_object_t criteria = xpc_dictionary_create(NULL, NULL, 0);\nxpc_dictionary_set_int64(criteria, XPC_ACTIVITY_INTERVAL, 5 * 60);\nxpc_dictionary_set_int64(criteria, XPC_ACTIVITY_GRACE_PERIOD, 10 * 60);\n\nxpc_activity_register(\"com.example.app.activity\",\n                      criteria,\n                      ^(xpc_activity_t activity)\n{\n    // Process Data\n\n    xpc_activity_set_state(activity, XPC_ACTIVITY_STATE_CONTINUE);\n\n    dispatch_async(dispatch_get_main_queue(), ^{\n        // Update UI\n\n        xpc_activity_set_state(activity, XPC_ACTIVITY_STATE_DONE);\n    });\n});\n```\n\n","source":"_posts/【转载】iOS进程-线程-间是如何通信的.md","raw":"---\ntitle: 【转载】iOS进程间是如何通信的\ntags: [转载, 底层原理]\ntop: 0\ndate: 2019-03-12 14:27:27\ncategories: 底层原理\nbanner_img:\n---\n\n# 总起\n\nOS X是MacOS与NeXTSTEP的结合。OC是Smalltalk类面向对象编程与C的结合。iCloud则是苹果移动服务与云平台的结合。\n\n上述都是一些亮点，但是不得不说苹果技术中的进程通讯走的是“反人类”的道路。\n\n由于不是根据每个节点上最优原则进行设计，苹果的进程间通信解决方案更显得混乱扎堆。结果是，大量重叠，不兼容的IPC技术在各个抽象层随处可见。（除了GCD还有剪贴板）\n\n* Mach Ports\n* Distributed Notifications\n* Distributed Objects\n* AppleEvents & AppleScript\n* Pasteboard\n* XPC\n\n从低级内核抽象到高级，面向对象的API，它们都有各自特殊的表现以及安全特性。但是基础层面来看，它们都是从不同上下文段传递或者获取数据的机制。\n\n<!-- more -->\n\n[原文链接](https://nshipster.com/inter-process-communication/)    [转载自此处](https://segmentfault.com/a/1190000002400329)\n\n# Mach Ports\n所有的进程间通讯最终落实依赖的还是Mach内核API提供的功能。\n\nMach端口是轻量并且强大的而又缺少相关文档晦涩使用的（天使与恶魔）。\n\n通过一个Mach端口发送一个消息调用一次mach_msg_send方法，但是这里需要做一些配置来构建待发送的消息：\n\n```\nnatural_t data;\nmach_port_t port;\n\nstruct {\n    mach_msg_header_t header;\n    mach_msg_body_t body;\n    mach_msg_type_descriptor_t type;\n} message;\n\nmessage.header = (mach_msg_header_t) {\n    .msgh_remote_port = port,\n    .msgh_local_port = MACH_PORT_NULL,\n    .msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, 0),\n    .msgh_size = sizeof(message)\n};\n\nmessage.body = (mach_msg_body_t) {\n    .msgh_descriptor_count = 1\n};\n\nmessage.type = (mach_msg_type_descriptor_t) {\n    .pad1 = data,\n    .pad2 = sizeof(data)\n};\n\nmach_msg_return_t error = mach_msg_send(&message.header);\n\nif (error == MACH_MSG_SUCCESS) {\n    // ...\n}\n```\n\n（消息）接收端稍微轻松点，因为消息只需要被声明而不用初始化：\n\n```\nmach_port_t port;\n\nstruct {\n    mach_msg_header_t header;\n    mach_msg_body_t body;\n    mach_msg_type_descriptor_t type;\n    mach_msg_trailer_t trailer;\n} message;\n\nmach_msg_return_t error = mach_msg_receive(&message.header);\n\nif (error == MACH_MSG_SUCCESS) {\n    natural_t data = message.type.pad1;\n    // ...\n}\n```\n\n还算不错的是，Core Foundation和Foundation为Mach端口提供了高级API。在内核基础上封装的CFMachPort / NSMachPort可以用做runloop源，尽管CFMachPort / NSMachPort有利于的是两个不同端口之间的通讯同步。\n\nCFMessagePort确实非常适合用于简单的一对一通讯。简简单单几行代码，一个本地端口就被附属到runloop源上，只要获取到消息就执行回调。\n\n```\nstatic CFDataRef Callback(CFMessagePortRef port,\n                          SInt32 messageID,\n                          CFDataRef data,\n                          void *info)\n{\n    // ...\n}\n\nCFMessagePortRef localPort =\n    CFMessagePortCreateLocal(nil,\n                             CFSTR(\"com.example.app.port.server\"),\n                             Callback,\n                             nil,\n                             nil);\n\nCFRunLoopSourceRef runLoopSource =\n    CFMessagePortCreateRunLoopSource(nil, localPort, 0);\n\nCFRunLoopAddSource(CFRunLoopGetCurrent(),\n                   runLoopSource,\n                   kCFRunLoopCommonModes);\n```\n\n若要进行发送数据同样也十分直截了当。只要完成指定远端的端口，装载数据，还有设置发送与接收的超时时间的操作。剩下就由CFMessagePortSendRequest来接管了。\n\n```\nCFDataRef data;\nSInt32 messageID = 0x1111; // Arbitrary\nCFTimeInterval timeout = 10.0;\n\nCFMessagePortRef remotePort =\n    CFMessagePortCreateRemote(nil,\n                              CFSTR(\"com.example.app.port.client\"));\n\nSInt32 status =\n    CFMessagePortSendRequest(remotePort,\n                             messageID,\n                             data,\n                             timeout,\n                             timeout,\n                             NULL,\n                             NULL);\nif (status == kCFMessagePortSuccess) {\n    // ...\n}\n```\n\n# Distributed Notifications\n\n在Cocoa中有很多种两个对象进行通信的途径。\n\n当然也能进行直接消息传递。也有像目标-动作，代理，回调这些解耦，一对一的设计模式。KVO允许让很多对象订阅一个事件，但是它把这些对象都联系起来了。另一方面通知让消息全局广播，并且让有监听该广播的对象接收该消息。【注：想知道发了多少次广播吗？添加 NSNotificationCenter addObserverForName:object:queue:usingBlock，其中name与object置nil，看block被调用了几次。】\n\n每个应用为基础应用消息发布-订阅对自身通知中心实例进行管理。但是鲜有人知的APICFNotificationCenterGetDistributedCenter的通知可以进行系统级别范围的通信。\n\n为了获取通知，添加所要指定监听消息名的观察者到通知发布中心，当消息接收到的时候函数指针指向的函数将被执行一次：\n\n```\nstatic void Callback(CFNotificationCenterRef center,\n                     void *observer,\n                     CFStringRef name,\n                     const void *object,\n                     CFDictionaryRef userInfo)\n{\n    // ...\n}\n\nCFNotificationCenterRef distributedCenter =\n    CFNotificationCenterGetDistributedCenter();\n\nCFNotificationSuspensionBehavior behavior =\n        CFNotificationSuspensionBehaviorDeliverImmediately;\n\nCFNotificationCenterAddObserver(distributedCenter,\n                                NULL,\n                                Callback,\n                                CFSTR(\"notification.identifier\"),\n                                NULL,\n                                behavior);\n\n```\n\n发送端代码更为简单，只要配置好ID,对象还有user info：\n\n```\nvoid *object;\nCFDictionaryRef userInfo;\n\nCFNotificationCenterRef distributedCenter =\n    CFNotificationCenterGetDistributedCenter();\n\nCFNotificationCenterPostNotification(distributedCenter,\n                                     CFSTR(\"notification.identifier\"),\n                                     object,\n                                     userInfo,\n                                     true);\n```\n\n链接两个应用通信的方式中，分发式通知是最为简单的。用它来进行大量数据的传输是不明智的，但是对于轻量级信息同步，分发式通知堪称完美。\n\n# Distributed Objects\n\n90年代中NeXT全盛时期，分发式对象（DO）是Cocoa框架中一个远程消息发送特性。尽管现在已经不再大范围的使用，在现代奇数层上IPC无障碍通信仍然并未实现。\n\n使用DO分发一个对象仅仅是搭建一个NSConnection并将其注册为特殊（你分的清楚）的名字：\n\n```\n@protocol Protocol;\n\nid <Protocol> vendedObject;\n\nNSConnection *connection = [[NSConnection alloc] init];\n[connection setRootObject:vendedObject];\n[connection registerName:@\"server\"];\n```\n\n另外一个应用将会也建立同样名字的并注册过的链接，然后立即获取一个原子代理当做原始对象。\n\n```\nid proxy = [NSConnection rootProxyForConnectionWithRegisteredName:@\"server\" host:nil];\n[proxy setProtocolForProxy:@protocol(Protocol)];\n```\n\n只要分发对象代理收到消息了，一个通过NSConnection连接远程调用（RPC）将会根据发送对象进行对应的计算并且返回结果给代理。【注：原理是一个OS管理的共享的NSPortNameServer实例对这个带着名字的连接进行管控。】\n\n分发式对象简单，透明，健壮。简直就是Cocoa中的标杆。。。\n\n实际上，分布式对象不能像局部对象那样使用，那就是因为任何发送给代理的消息都可能抛出异常。不想其他语言，OC没有异常处理控制流程。所以对任何东西都进行@try/@catch也算是Cocoa大会很凄凉的补救了。\n\nDO还有一个原因致其使用不便。在试图通过连接“marshal values”时，对象和原语的差距尤为明显。\n此外，连接是完全加密的，和下方通信信道扩展性的缺乏致使其在大多数的使用中通信被迫中断。\n\n下方是左列分布式对象用来指定其属性代理行为和方法参数的注解：\n\n* in：输入参数，后续不再引用\n* out：参数被引用作为返回值\n* inout：输入参数，引用作为返回值\n* const：常量参数\n* oneway：无障碍结果返回\n* bycopy：返回对象的拷贝\n* byref：返回对象的代理\n\n\n# AppleEvents & AppleScript\n\nAppleEvents是经典Macintosh操作系统最持久的遗产。在System 7推出的AppleEvents允许应用程序在本地使用AppleScript或者使用程序链接的功能进行程序控制。现在AppleScript使用Cocoa Scripting Bridge，仍然是OS X应用进程间最直接的交互方式。【注：Mac系统的苹果时间管理中心为AppleEvents提供了原始低级传送机制，但是是在OS X的Mach端口基础之上的重实现】。\n\n也就是说，使用起来这是简单而又古怪的技术之一。\n\nAppleScript使用自然语言语法，设计初衷是没有涉及参数而更容易掌握。虽然与人交流更亲和了，但是写起来确实噩梦。\n\n为了更好的了解人类自然性，这里有个栗子教你怎么让Safari在最前的窗口的激活栏打开一个URL。\n\n```\ntell application \"Safari\"\n  set the URL of the front document to \"http://nshipster.com\"\nend tell\n```\n\n在大部分情况下，AppleScript的语法自然语言的特性更多是不便不是优势。（吐槽。。。略略略）\n\n即便是经验老道的OC开发者，不靠文档或者栗子写出AppleScript是不可能的任务。\n\n幸运的是，Scripting Bridge为Cocoa应用提供了更友善的编程接口。\n\n# Cocoa Scripting Bridge\n\n为了使用Scripting Bridge与应用进行交互，首先要先添加一个编程接口：\n\n```\n$ sdef /Applications/Safari.app | sdp -fh --basename Safari\n```\n\nsdef为应用生成脚本定义文件。这些文件可以以管道输入道sdp并格式转成（在这里是）C头文件。这样的结果是添加该头文件到应用工程并提供第一类对象接口。\n\n这里举个栗子来解释如何使用Cocoa Scripting Bridge：\n\n```\n#import \"Safari.h\"\n\nSafariApplication *safari = [SBApplication applicationWithBundleIdentifier:@\"com.apple.Safari\"];\n\nfor (SafariWindow *window in safari.windows) {\n    if (window.visible) {\n        window.currentTab.URL = [NSURL URLWithString:@\"http://nshipster.com\"];\n        break;\n    }\n}\n```\n\n对比AppleScript上面显得冗繁了点，但是却更容易集成到已存在的代码中去。在可读性上更优因为毕竟长得更像OC。\n\n唉，AppleScript的星芒也正出现消退，在最近发布的OS X与iWork应用证答复减少它的戏份。从这点说，未必值得在你的应用中去添加这项（脚本）支持。\n\n# Pasteboard\n\n剪贴板是OS X与iOS最常见的进程间通信机制。当用户跨应用拷贝了一段文字，图片，文档，这时候通过mach port的com.apple.pboard服务媒介进行从一个进程到另一个进程的数据交换。\n\nOS X上是NSPasteboard，iOS上对应的是UIPasteboard。它们几乎是别无二致，但尽管大致一样，对比OS X iOS上提供了更简洁，更现代化却又不影响功效的API。\n\n编写剪贴板代码几乎就跟在GUI应用上使用Edit > Copy操作一样简单：\n\n```\nNSImage *image;\n\nNSPasteboard *pasteboard = [NSPasteboard generalPasteboard];\n[pasteboard clearContents];\n[pasteboard writeObjects:@[image]];\n```\n\n因为剪贴动作太频繁了，所以要确认剪贴内容是否是你（应用）所需要得：\n\n```\nNSPasteboard *pasteboard = [NSPasteboard generalPasteboard];\n\nif ([pasteboard canReadObjectForClasses:@[[NSImage class]] options:nil]) {\n    NSArray *contents = [pasteboard readObjectsForClasses:@[[NSImage class]] options: nil];\n    NSImage *image = [contents firstObject];\n}\n```\n\n# XPC\n\nXPC是SDK中最先进的进程间通讯技术。它架构之初的目的在于避免长时间得运行过程，来适应有限的资源，在可能运行的时候才进行初始化。把XPC纳入应用而不做任何事情的想法是不现实的，但这样提供了更好的进程间的特权分离和故障隔离。\n\nXPC作为NSTask替代品甚至更多。\n\n2011推出以来，XPC为OS X上的应用沙盒提供基础设施，iOS上的远程试图控制器，还有两个平台上的应用扩展。它还广范围的用在系统框架和第一方应用：\n\n```\n$ find /Applications -name \\*.xpc\n```\n\n控制台输入上面的命令行你会知道XPC无处不在。在一般应用中同样的情形也在发生，比如图片或者视频转变服务，系统调用，网页服务加载，或是第三方的授权。\n\nXPC负责进程间通讯的同时还负责该服务生命周期的管理。包括注册服务，启动，以及通过launchd解决服务之间的通讯。一个XPC服务可以根据需求地洞，或者在崩溃的时候重启，或者是空闲的时候终止。正因如此，服务可以完全被设计成无状态的，以便于在运行的任何时间点的突然终止都能做到影响不大。\n\n作为被iOS还有OS X中backported所采用的安全模块，XPC服务默认运行在最为严格的环境：不能访问文件，不能访问网络，没有根权限升级。任何能做的事情就是对照被赋予的白名单列表。\n\nXPC可以被libxpc C API访问，或者是NSXPCConnection OC API。【注：作者会用低级API去实现（纯C）】\n\nXPC服务要么存在于应用的沙盒中亦或是使用launchd调用跑在后台。\n\n服务调用带事件句柄的xpc_main来获取新的XPC连接。\n\n```\nstatic void connection_handler(xpc_connection_t peer) {\n    xpc_connection_set_event_handler(peer, ^(xpc_object_t event) {\n        peer_event_handler(peer, event);\n    });\n\n    xpc_connection_resume(peer);\n}\n\nint main(int argc, const char *argv[]) {\n   xpc_main(connection_handler);\n   exit(EXIT_FAILURE);\n}\n```\n\n每个XPC连接是一对一的，意味着服务在不同的连接进行操作，每次调用xpc_connection_create就会创建一个新的链接。【注：类似BSD套接字中的API accept函数，服务在单个文件描述符进行监听来为范围内的链接创建额外描述符】：\n\n```\nxpc_connection_t c = xpc_connection_create(\"com.example.service\", NULL);\nxpc_connection_set_event_handler(c, ^(xpc_object_t event) {\n    // ...\n});\nxpc_connection_resume(c);\n```\n\n当一个消息发送到XPC链接，将自动的派发到一个由runtime管理的消息队列中。当链接的远端一旦开启的时候，消息将出队并被发送。\n\n每个消息就是一个字典，字符串key和强类型值：\n\n```\nxpc_dictionary_t message = xpc_dictionary_create(NULL, NULL, 0);\nxpc_dictionary_set_uint64(message, \"foo\", 1);\nxpc_connection_send_message(c, message);\nxpc_release(message)\n```\n\nXPC对象对下列原始类型进行操作：\n\n* Data\n* Boolean\n* Double\n* String\n* Signed Integer\n* Unsigned Integer\n* Date\n* UUID\n* Array\n* Dictionary\n* Null\n\n\nXPC提供了一个便捷的方法来从dispatch_data_t数据类型进行转换，这样从GCD到XPC的工作流程就简化了：\n\n```\nvoid *buffer;\nsize_t length;\ndispatch_data_t ddata =\n    dispatch_data_create(buffer,\n                         length,\n                         DISPATCH_TARGET_QUEUE_DEFAULT,\n                         DISPATCH_DATA_DESTRUCTOR_MUNMAP);\n\nxpc_object_t xdata = xpc_data_create_with_dispatch_data(ddata);\n```\n\n# 服务注册\n\nXPC可以注册成启动项任务，配置成匹配IOKit事件自动启动，BSD通知或者是CFDistributedNotifications。这些标准都指定在服务的launchd.plist文件里：\n.launchd.plist\n\n```\n<key>LaunchEvents</key>\n<dict>\n  <key>com.apple.iokit.matching</key>\n  <dict>\n      <key>com.example.device-attach</key>\n      <dict>\n          <key>idProduct</key>\n          <integer>2794</integer>\n          <key>idVendor</key>\n          <integer>725</integer>\n          <key>IOProviderClass</key>\n          <string>IOUSBDevice</string>\n          <key>IOMatchLaunchStream</key>\n          <true/>\n          <key>ProcessType</key>\n          <string>Adaptive</string>\n      </dict>\n  </dict>\n</dict>\n```\n\n最近一次对于launchd属性列表的修改是增加了ProcessType Key，其用来在高级层面上描述启动机构的预期目的。根据预描述行为期望，操作系统会响应调整CPU和I/O的阈值。\n\n![图片描述](articlex.png)\n\n为了注册一个服务运行大概五分钟的时间，一套标准需要传送给xpc_activity_register：\n\n```\nxpc_object_t criteria = xpc_dictionary_create(NULL, NULL, 0);\nxpc_dictionary_set_int64(criteria, XPC_ACTIVITY_INTERVAL, 5 * 60);\nxpc_dictionary_set_int64(criteria, XPC_ACTIVITY_GRACE_PERIOD, 10 * 60);\n\nxpc_activity_register(\"com.example.app.activity\",\n                      criteria,\n                      ^(xpc_activity_t activity)\n{\n    // Process Data\n\n    xpc_activity_set_state(activity, XPC_ACTIVITY_STATE_CONTINUE);\n\n    dispatch_async(dispatch_get_main_queue(), ^{\n        // Update UI\n\n        xpc_activity_set_state(activity, XPC_ACTIVITY_STATE_DONE);\n    });\n});\n```\n\n","slug":"【转载】iOS进程-线程-间是如何通信的","published":1,"updated":"2023-07-21T09:10:33.576Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clkcgbp5j001bpfo74a0f0ox0","content":"<h1 id=\"总起\"><a href=\"#总起\" class=\"headerlink\" title=\"总起\"></a>总起</h1><p>OS X是MacOS与NeXTSTEP的结合。OC是Smalltalk类面向对象编程与C的结合。iCloud则是苹果移动服务与云平台的结合。</p>\n<p>上述都是一些亮点，但是不得不说苹果技术中的进程通讯走的是“反人类”的道路。</p>\n<p>由于不是根据每个节点上最优原则进行设计，苹果的进程间通信解决方案更显得混乱扎堆。结果是，大量重叠，不兼容的IPC技术在各个抽象层随处可见。（除了GCD还有剪贴板）</p>\n<ul>\n<li>Mach Ports</li>\n<li>Distributed Notifications</li>\n<li>Distributed Objects</li>\n<li>AppleEvents &amp; AppleScript</li>\n<li>Pasteboard</li>\n<li>XPC</li>\n</ul>\n<p>从低级内核抽象到高级，面向对象的API，它们都有各自特殊的表现以及安全特性。但是基础层面来看，它们都是从不同上下文段传递或者获取数据的机制。</p>\n<span id=\"more\"></span>\n\n<p><a href=\"https://nshipster.com/inter-process-communication/\">原文链接</a>    <a href=\"https://segmentfault.com/a/1190000002400329\">转载自此处</a></p>\n<h1 id=\"Mach-Ports\"><a href=\"#Mach-Ports\" class=\"headerlink\" title=\"Mach Ports\"></a>Mach Ports</h1><p>所有的进程间通讯最终落实依赖的还是Mach内核API提供的功能。</p>\n<p>Mach端口是轻量并且强大的而又缺少相关文档晦涩使用的（天使与恶魔）。</p>\n<p>通过一个Mach端口发送一个消息调用一次mach_msg_send方法，但是这里需要做一些配置来构建待发送的消息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">natural_t data;</span><br><span class=\"line\">mach_port_t port;</span><br><span class=\"line\"></span><br><span class=\"line\">struct &#123;</span><br><span class=\"line\">    mach_msg_header_t header;</span><br><span class=\"line\">    mach_msg_body_t body;</span><br><span class=\"line\">    mach_msg_type_descriptor_t type;</span><br><span class=\"line\">&#125; message;</span><br><span class=\"line\"></span><br><span class=\"line\">message.header = (mach_msg_header_t) &#123;</span><br><span class=\"line\">    .msgh_remote_port = port,</span><br><span class=\"line\">    .msgh_local_port = MACH_PORT_NULL,</span><br><span class=\"line\">    .msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, 0),</span><br><span class=\"line\">    .msgh_size = sizeof(message)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">message.body = (mach_msg_body_t) &#123;</span><br><span class=\"line\">    .msgh_descriptor_count = 1</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">message.type = (mach_msg_type_descriptor_t) &#123;</span><br><span class=\"line\">    .pad1 = data,</span><br><span class=\"line\">    .pad2 = sizeof(data)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">mach_msg_return_t error = mach_msg_send(&amp;message.header);</span><br><span class=\"line\"></span><br><span class=\"line\">if (error == MACH_MSG_SUCCESS) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（消息）接收端稍微轻松点，因为消息只需要被声明而不用初始化：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mach_port_t port;</span><br><span class=\"line\"></span><br><span class=\"line\">struct &#123;</span><br><span class=\"line\">    mach_msg_header_t header;</span><br><span class=\"line\">    mach_msg_body_t body;</span><br><span class=\"line\">    mach_msg_type_descriptor_t type;</span><br><span class=\"line\">    mach_msg_trailer_t trailer;</span><br><span class=\"line\">&#125; message;</span><br><span class=\"line\"></span><br><span class=\"line\">mach_msg_return_t error = mach_msg_receive(&amp;message.header);</span><br><span class=\"line\"></span><br><span class=\"line\">if (error == MACH_MSG_SUCCESS) &#123;</span><br><span class=\"line\">    natural_t data = message.type.pad1;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还算不错的是，Core Foundation和Foundation为Mach端口提供了高级API。在内核基础上封装的CFMachPort &#x2F; NSMachPort可以用做runloop源，尽管CFMachPort &#x2F; NSMachPort有利于的是两个不同端口之间的通讯同步。</p>\n<p>CFMessagePort确实非常适合用于简单的一对一通讯。简简单单几行代码，一个本地端口就被附属到runloop源上，只要获取到消息就执行回调。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static CFDataRef Callback(CFMessagePortRef port,</span><br><span class=\"line\">                          SInt32 messageID,</span><br><span class=\"line\">                          CFDataRef data,</span><br><span class=\"line\">                          void *info)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">CFMessagePortRef localPort =</span><br><span class=\"line\">    CFMessagePortCreateLocal(nil,</span><br><span class=\"line\">                             CFSTR(&quot;com.example.app.port.server&quot;),</span><br><span class=\"line\">                             Callback,</span><br><span class=\"line\">                             nil,</span><br><span class=\"line\">                             nil);</span><br><span class=\"line\"></span><br><span class=\"line\">CFRunLoopSourceRef runLoopSource =</span><br><span class=\"line\">    CFMessagePortCreateRunLoopSource(nil, localPort, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">CFRunLoopAddSource(CFRunLoopGetCurrent(),</span><br><span class=\"line\">                   runLoopSource,</span><br><span class=\"line\">                   kCFRunLoopCommonModes);</span><br></pre></td></tr></table></figure>\n\n<p>若要进行发送数据同样也十分直截了当。只要完成指定远端的端口，装载数据，还有设置发送与接收的超时时间的操作。剩下就由CFMessagePortSendRequest来接管了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CFDataRef data;</span><br><span class=\"line\">SInt32 messageID = 0x1111; // Arbitrary</span><br><span class=\"line\">CFTimeInterval timeout = 10.0;</span><br><span class=\"line\"></span><br><span class=\"line\">CFMessagePortRef remotePort =</span><br><span class=\"line\">    CFMessagePortCreateRemote(nil,</span><br><span class=\"line\">                              CFSTR(&quot;com.example.app.port.client&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">SInt32 status =</span><br><span class=\"line\">    CFMessagePortSendRequest(remotePort,</span><br><span class=\"line\">                             messageID,</span><br><span class=\"line\">                             data,</span><br><span class=\"line\">                             timeout,</span><br><span class=\"line\">                             timeout,</span><br><span class=\"line\">                             NULL,</span><br><span class=\"line\">                             NULL);</span><br><span class=\"line\">if (status == kCFMessagePortSuccess) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Distributed-Notifications\"><a href=\"#Distributed-Notifications\" class=\"headerlink\" title=\"Distributed Notifications\"></a>Distributed Notifications</h1><p>在Cocoa中有很多种两个对象进行通信的途径。</p>\n<p>当然也能进行直接消息传递。也有像目标-动作，代理，回调这些解耦，一对一的设计模式。KVO允许让很多对象订阅一个事件，但是它把这些对象都联系起来了。另一方面通知让消息全局广播，并且让有监听该广播的对象接收该消息。【注：想知道发了多少次广播吗？添加 NSNotificationCenter addObserverForName:object:queue:usingBlock，其中name与object置nil，看block被调用了几次。】</p>\n<p>每个应用为基础应用消息发布-订阅对自身通知中心实例进行管理。但是鲜有人知的APICFNotificationCenterGetDistributedCenter的通知可以进行系统级别范围的通信。</p>\n<p>为了获取通知，添加所要指定监听消息名的观察者到通知发布中心，当消息接收到的时候函数指针指向的函数将被执行一次：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void Callback(CFNotificationCenterRef center,</span><br><span class=\"line\">                     void *observer,</span><br><span class=\"line\">                     CFStringRef name,</span><br><span class=\"line\">                     const void *object,</span><br><span class=\"line\">                     CFDictionaryRef userInfo)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">CFNotificationCenterRef distributedCenter =</span><br><span class=\"line\">    CFNotificationCenterGetDistributedCenter();</span><br><span class=\"line\"></span><br><span class=\"line\">CFNotificationSuspensionBehavior behavior =</span><br><span class=\"line\">        CFNotificationSuspensionBehaviorDeliverImmediately;</span><br><span class=\"line\"></span><br><span class=\"line\">CFNotificationCenterAddObserver(distributedCenter,</span><br><span class=\"line\">                                NULL,</span><br><span class=\"line\">                                Callback,</span><br><span class=\"line\">                                CFSTR(&quot;notification.identifier&quot;),</span><br><span class=\"line\">                                NULL,</span><br><span class=\"line\">                                behavior);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>发送端代码更为简单，只要配置好ID,对象还有user info：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void *object;</span><br><span class=\"line\">CFDictionaryRef userInfo;</span><br><span class=\"line\"></span><br><span class=\"line\">CFNotificationCenterRef distributedCenter =</span><br><span class=\"line\">    CFNotificationCenterGetDistributedCenter();</span><br><span class=\"line\"></span><br><span class=\"line\">CFNotificationCenterPostNotification(distributedCenter,</span><br><span class=\"line\">                                     CFSTR(&quot;notification.identifier&quot;),</span><br><span class=\"line\">                                     object,</span><br><span class=\"line\">                                     userInfo,</span><br><span class=\"line\">                                     true);</span><br></pre></td></tr></table></figure>\n\n<p>链接两个应用通信的方式中，分发式通知是最为简单的。用它来进行大量数据的传输是不明智的，但是对于轻量级信息同步，分发式通知堪称完美。</p>\n<h1 id=\"Distributed-Objects\"><a href=\"#Distributed-Objects\" class=\"headerlink\" title=\"Distributed Objects\"></a>Distributed Objects</h1><p>90年代中NeXT全盛时期，分发式对象（DO）是Cocoa框架中一个远程消息发送特性。尽管现在已经不再大范围的使用，在现代奇数层上IPC无障碍通信仍然并未实现。</p>\n<p>使用DO分发一个对象仅仅是搭建一个NSConnection并将其注册为特殊（你分的清楚）的名字：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@protocol Protocol;</span><br><span class=\"line\"></span><br><span class=\"line\">id &lt;Protocol&gt; vendedObject;</span><br><span class=\"line\"></span><br><span class=\"line\">NSConnection *connection = [[NSConnection alloc] init];</span><br><span class=\"line\">[connection setRootObject:vendedObject];</span><br><span class=\"line\">[connection registerName:@&quot;server&quot;];</span><br></pre></td></tr></table></figure>\n\n<p>另外一个应用将会也建立同样名字的并注册过的链接，然后立即获取一个原子代理当做原始对象。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id proxy = [NSConnection rootProxyForConnectionWithRegisteredName:@&quot;server&quot; host:nil];</span><br><span class=\"line\">[proxy setProtocolForProxy:@protocol(Protocol)];</span><br></pre></td></tr></table></figure>\n\n<p>只要分发对象代理收到消息了，一个通过NSConnection连接远程调用（RPC）将会根据发送对象进行对应的计算并且返回结果给代理。【注：原理是一个OS管理的共享的NSPortNameServer实例对这个带着名字的连接进行管控。】</p>\n<p>分发式对象简单，透明，健壮。简直就是Cocoa中的标杆。。。</p>\n<p>实际上，分布式对象不能像局部对象那样使用，那就是因为任何发送给代理的消息都可能抛出异常。不想其他语言，OC没有异常处理控制流程。所以对任何东西都进行@try&#x2F;@catch也算是Cocoa大会很凄凉的补救了。</p>\n<p>DO还有一个原因致其使用不便。在试图通过连接“marshal values”时，对象和原语的差距尤为明显。<br>此外，连接是完全加密的，和下方通信信道扩展性的缺乏致使其在大多数的使用中通信被迫中断。</p>\n<p>下方是左列分布式对象用来指定其属性代理行为和方法参数的注解：</p>\n<ul>\n<li>in：输入参数，后续不再引用</li>\n<li>out：参数被引用作为返回值</li>\n<li>inout：输入参数，引用作为返回值</li>\n<li>const：常量参数</li>\n<li>oneway：无障碍结果返回</li>\n<li>bycopy：返回对象的拷贝</li>\n<li>byref：返回对象的代理</li>\n</ul>\n<h1 id=\"AppleEvents-AppleScript\"><a href=\"#AppleEvents-AppleScript\" class=\"headerlink\" title=\"AppleEvents &amp; AppleScript\"></a>AppleEvents &amp; AppleScript</h1><p>AppleEvents是经典Macintosh操作系统最持久的遗产。在System 7推出的AppleEvents允许应用程序在本地使用AppleScript或者使用程序链接的功能进行程序控制。现在AppleScript使用Cocoa Scripting Bridge，仍然是OS X应用进程间最直接的交互方式。【注：Mac系统的苹果时间管理中心为AppleEvents提供了原始低级传送机制，但是是在OS X的Mach端口基础之上的重实现】。</p>\n<p>也就是说，使用起来这是简单而又古怪的技术之一。</p>\n<p>AppleScript使用自然语言语法，设计初衷是没有涉及参数而更容易掌握。虽然与人交流更亲和了，但是写起来确实噩梦。</p>\n<p>为了更好的了解人类自然性，这里有个栗子教你怎么让Safari在最前的窗口的激活栏打开一个URL。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tell application &quot;Safari&quot;</span><br><span class=\"line\">  set the URL of the front document to &quot;http://nshipster.com&quot;</span><br><span class=\"line\">end tell</span><br></pre></td></tr></table></figure>\n\n<p>在大部分情况下，AppleScript的语法自然语言的特性更多是不便不是优势。（吐槽。。。略略略）</p>\n<p>即便是经验老道的OC开发者，不靠文档或者栗子写出AppleScript是不可能的任务。</p>\n<p>幸运的是，Scripting Bridge为Cocoa应用提供了更友善的编程接口。</p>\n<h1 id=\"Cocoa-Scripting-Bridge\"><a href=\"#Cocoa-Scripting-Bridge\" class=\"headerlink\" title=\"Cocoa Scripting Bridge\"></a>Cocoa Scripting Bridge</h1><p>为了使用Scripting Bridge与应用进行交互，首先要先添加一个编程接口：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sdef /Applications/Safari.app | sdp -fh --basename Safari</span><br></pre></td></tr></table></figure>\n\n<p>sdef为应用生成脚本定义文件。这些文件可以以管道输入道sdp并格式转成（在这里是）C头文件。这样的结果是添加该头文件到应用工程并提供第一类对象接口。</p>\n<p>这里举个栗子来解释如何使用Cocoa Scripting Bridge：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;Safari.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">SafariApplication *safari = [SBApplication applicationWithBundleIdentifier:@&quot;com.apple.Safari&quot;];</span><br><span class=\"line\"></span><br><span class=\"line\">for (SafariWindow *window in safari.windows) &#123;</span><br><span class=\"line\">    if (window.visible) &#123;</span><br><span class=\"line\">        window.currentTab.URL = [NSURL URLWithString:@&quot;http://nshipster.com&quot;];</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对比AppleScript上面显得冗繁了点，但是却更容易集成到已存在的代码中去。在可读性上更优因为毕竟长得更像OC。</p>\n<p>唉，AppleScript的星芒也正出现消退，在最近发布的OS X与iWork应用证答复减少它的戏份。从这点说，未必值得在你的应用中去添加这项（脚本）支持。</p>\n<h1 id=\"Pasteboard\"><a href=\"#Pasteboard\" class=\"headerlink\" title=\"Pasteboard\"></a>Pasteboard</h1><p>剪贴板是OS X与iOS最常见的进程间通信机制。当用户跨应用拷贝了一段文字，图片，文档，这时候通过mach port的com.apple.pboard服务媒介进行从一个进程到另一个进程的数据交换。</p>\n<p>OS X上是NSPasteboard，iOS上对应的是UIPasteboard。它们几乎是别无二致，但尽管大致一样，对比OS X iOS上提供了更简洁，更现代化却又不影响功效的API。</p>\n<p>编写剪贴板代码几乎就跟在GUI应用上使用Edit &gt; Copy操作一样简单：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSImage *image;</span><br><span class=\"line\"></span><br><span class=\"line\">NSPasteboard *pasteboard = [NSPasteboard generalPasteboard];</span><br><span class=\"line\">[pasteboard clearContents];</span><br><span class=\"line\">[pasteboard writeObjects:@[image]];</span><br></pre></td></tr></table></figure>\n\n<p>因为剪贴动作太频繁了，所以要确认剪贴内容是否是你（应用）所需要得：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSPasteboard *pasteboard = [NSPasteboard generalPasteboard];</span><br><span class=\"line\"></span><br><span class=\"line\">if ([pasteboard canReadObjectForClasses:@[[NSImage class]] options:nil]) &#123;</span><br><span class=\"line\">    NSArray *contents = [pasteboard readObjectsForClasses:@[[NSImage class]] options: nil];</span><br><span class=\"line\">    NSImage *image = [contents firstObject];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"XPC\"><a href=\"#XPC\" class=\"headerlink\" title=\"XPC\"></a>XPC</h1><p>XPC是SDK中最先进的进程间通讯技术。它架构之初的目的在于避免长时间得运行过程，来适应有限的资源，在可能运行的时候才进行初始化。把XPC纳入应用而不做任何事情的想法是不现实的，但这样提供了更好的进程间的特权分离和故障隔离。</p>\n<p>XPC作为NSTask替代品甚至更多。</p>\n<p>2011推出以来，XPC为OS X上的应用沙盒提供基础设施，iOS上的远程试图控制器，还有两个平台上的应用扩展。它还广范围的用在系统框架和第一方应用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ find /Applications -name \\*.xpc</span><br></pre></td></tr></table></figure>\n\n<p>控制台输入上面的命令行你会知道XPC无处不在。在一般应用中同样的情形也在发生，比如图片或者视频转变服务，系统调用，网页服务加载，或是第三方的授权。</p>\n<p>XPC负责进程间通讯的同时还负责该服务生命周期的管理。包括注册服务，启动，以及通过launchd解决服务之间的通讯。一个XPC服务可以根据需求地洞，或者在崩溃的时候重启，或者是空闲的时候终止。正因如此，服务可以完全被设计成无状态的，以便于在运行的任何时间点的突然终止都能做到影响不大。</p>\n<p>作为被iOS还有OS X中backported所采用的安全模块，XPC服务默认运行在最为严格的环境：不能访问文件，不能访问网络，没有根权限升级。任何能做的事情就是对照被赋予的白名单列表。</p>\n<p>XPC可以被libxpc C API访问，或者是NSXPCConnection OC API。【注：作者会用低级API去实现（纯C）】</p>\n<p>XPC服务要么存在于应用的沙盒中亦或是使用launchd调用跑在后台。</p>\n<p>服务调用带事件句柄的xpc_main来获取新的XPC连接。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void connection_handler(xpc_connection_t peer) &#123;</span><br><span class=\"line\">    xpc_connection_set_event_handler(peer, ^(xpc_object_t event) &#123;</span><br><span class=\"line\">        peer_event_handler(peer, event);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    xpc_connection_resume(peer);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char *argv[]) &#123;</span><br><span class=\"line\">   xpc_main(connection_handler);</span><br><span class=\"line\">   exit(EXIT_FAILURE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>每个XPC连接是一对一的，意味着服务在不同的连接进行操作，每次调用xpc_connection_create就会创建一个新的链接。【注：类似BSD套接字中的API accept函数，服务在单个文件描述符进行监听来为范围内的链接创建额外描述符】：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xpc_connection_t c = xpc_connection_create(&quot;com.example.service&quot;, NULL);</span><br><span class=\"line\">xpc_connection_set_event_handler(c, ^(xpc_object_t event) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">xpc_connection_resume(c);</span><br></pre></td></tr></table></figure>\n\n<p>当一个消息发送到XPC链接，将自动的派发到一个由runtime管理的消息队列中。当链接的远端一旦开启的时候，消息将出队并被发送。</p>\n<p>每个消息就是一个字典，字符串key和强类型值：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xpc_dictionary_t message = xpc_dictionary_create(NULL, NULL, 0);</span><br><span class=\"line\">xpc_dictionary_set_uint64(message, &quot;foo&quot;, 1);</span><br><span class=\"line\">xpc_connection_send_message(c, message);</span><br><span class=\"line\">xpc_release(message)</span><br></pre></td></tr></table></figure>\n\n<p>XPC对象对下列原始类型进行操作：</p>\n<ul>\n<li>Data</li>\n<li>Boolean</li>\n<li>Double</li>\n<li>String</li>\n<li>Signed Integer</li>\n<li>Unsigned Integer</li>\n<li>Date</li>\n<li>UUID</li>\n<li>Array</li>\n<li>Dictionary</li>\n<li>Null</li>\n</ul>\n<p>XPC提供了一个便捷的方法来从dispatch_data_t数据类型进行转换，这样从GCD到XPC的工作流程就简化了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void *buffer;</span><br><span class=\"line\">size_t length;</span><br><span class=\"line\">dispatch_data_t ddata =</span><br><span class=\"line\">    dispatch_data_create(buffer,</span><br><span class=\"line\">                         length,</span><br><span class=\"line\">                         DISPATCH_TARGET_QUEUE_DEFAULT,</span><br><span class=\"line\">                         DISPATCH_DATA_DESTRUCTOR_MUNMAP);</span><br><span class=\"line\"></span><br><span class=\"line\">xpc_object_t xdata = xpc_data_create_with_dispatch_data(ddata);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"服务注册\"><a href=\"#服务注册\" class=\"headerlink\" title=\"服务注册\"></a>服务注册</h1><p>XPC可以注册成启动项任务，配置成匹配IOKit事件自动启动，BSD通知或者是CFDistributedNotifications。这些标准都指定在服务的launchd.plist文件里：<br>.launchd.plist</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;key&gt;LaunchEvents&lt;/key&gt;</span><br><span class=\"line\">&lt;dict&gt;</span><br><span class=\"line\">  &lt;key&gt;com.apple.iokit.matching&lt;/key&gt;</span><br><span class=\"line\">  &lt;dict&gt;</span><br><span class=\"line\">      &lt;key&gt;com.example.device-attach&lt;/key&gt;</span><br><span class=\"line\">      &lt;dict&gt;</span><br><span class=\"line\">          &lt;key&gt;idProduct&lt;/key&gt;</span><br><span class=\"line\">          &lt;integer&gt;2794&lt;/integer&gt;</span><br><span class=\"line\">          &lt;key&gt;idVendor&lt;/key&gt;</span><br><span class=\"line\">          &lt;integer&gt;725&lt;/integer&gt;</span><br><span class=\"line\">          &lt;key&gt;IOProviderClass&lt;/key&gt;</span><br><span class=\"line\">          &lt;string&gt;IOUSBDevice&lt;/string&gt;</span><br><span class=\"line\">          &lt;key&gt;IOMatchLaunchStream&lt;/key&gt;</span><br><span class=\"line\">          &lt;true/&gt;</span><br><span class=\"line\">          &lt;key&gt;ProcessType&lt;/key&gt;</span><br><span class=\"line\">          &lt;string&gt;Adaptive&lt;/string&gt;</span><br><span class=\"line\">      &lt;/dict&gt;</span><br><span class=\"line\">  &lt;/dict&gt;</span><br><span class=\"line\">&lt;/dict&gt;</span><br></pre></td></tr></table></figure>\n\n<p>最近一次对于launchd属性列表的修改是增加了ProcessType Key，其用来在高级层面上描述启动机构的预期目的。根据预描述行为期望，操作系统会响应调整CPU和I&#x2F;O的阈值。</p>\n<p><img src=\"/2019/03/12/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91iOS%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E9%97%B4%E6%98%AF%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1%E7%9A%84/articlex.png\" alt=\"图片描述\"></p>\n<p>为了注册一个服务运行大概五分钟的时间，一套标准需要传送给xpc_activity_register：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xpc_object_t criteria = xpc_dictionary_create(NULL, NULL, 0);</span><br><span class=\"line\">xpc_dictionary_set_int64(criteria, XPC_ACTIVITY_INTERVAL, 5 * 60);</span><br><span class=\"line\">xpc_dictionary_set_int64(criteria, XPC_ACTIVITY_GRACE_PERIOD, 10 * 60);</span><br><span class=\"line\"></span><br><span class=\"line\">xpc_activity_register(&quot;com.example.app.activity&quot;,</span><br><span class=\"line\">                      criteria,</span><br><span class=\"line\">                      ^(xpc_activity_t activity)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // Process Data</span><br><span class=\"line\"></span><br><span class=\"line\">    xpc_activity_set_state(activity, XPC_ACTIVITY_STATE_CONTINUE);</span><br><span class=\"line\"></span><br><span class=\"line\">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">        // Update UI</span><br><span class=\"line\"></span><br><span class=\"line\">        xpc_activity_set_state(activity, XPC_ACTIVITY_STATE_DONE);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"length":9915,"excerpt":"<h1 id=\"总起\"><a href=\"#总起\" class=\"headerlink\" title=\"总起\"></a>总起</h1><p>OS X是MacOS与NeXTSTEP的结合。OC是Smalltalk类面向对象编程与C的结合。iCloud则是苹果移动服务与云平台的结合。</p>\n<p>上述都是一些亮点，但是不得不说苹果技术中的进程通讯走的是“反人类”的道路。</p>\n<p>由于不是根据每个节点上最优原则进行设计，苹果的进程间通信解决方案更显得混乱扎堆。结果是，大量重叠，不兼容的IPC技术在各个抽象层随处可见。（除了GCD还有剪贴板）</p>\n<ul>\n<li>Mach Ports</li>\n<li>Distributed Notifications</li>\n<li>Distributed Objects</li>\n<li>AppleEvents &amp; AppleScript</li>\n<li>Pasteboard</li>\n<li>XPC</li>\n</ul>\n<p>从低级内核抽象到高级，面向对象的API，它们都有各自特殊的表现以及安全特性。但是基础层面来看，它们都是从不同上下文段传递或者获取数据的机制。</p>","more":"<p><a href=\"https://nshipster.com/inter-process-communication/\">原文链接</a>    <a href=\"https://segmentfault.com/a/1190000002400329\">转载自此处</a></p>\n<h1 id=\"Mach-Ports\"><a href=\"#Mach-Ports\" class=\"headerlink\" title=\"Mach Ports\"></a>Mach Ports</h1><p>所有的进程间通讯最终落实依赖的还是Mach内核API提供的功能。</p>\n<p>Mach端口是轻量并且强大的而又缺少相关文档晦涩使用的（天使与恶魔）。</p>\n<p>通过一个Mach端口发送一个消息调用一次mach_msg_send方法，但是这里需要做一些配置来构建待发送的消息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">natural_t data;</span><br><span class=\"line\">mach_port_t port;</span><br><span class=\"line\"></span><br><span class=\"line\">struct &#123;</span><br><span class=\"line\">    mach_msg_header_t header;</span><br><span class=\"line\">    mach_msg_body_t body;</span><br><span class=\"line\">    mach_msg_type_descriptor_t type;</span><br><span class=\"line\">&#125; message;</span><br><span class=\"line\"></span><br><span class=\"line\">message.header = (mach_msg_header_t) &#123;</span><br><span class=\"line\">    .msgh_remote_port = port,</span><br><span class=\"line\">    .msgh_local_port = MACH_PORT_NULL,</span><br><span class=\"line\">    .msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, 0),</span><br><span class=\"line\">    .msgh_size = sizeof(message)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">message.body = (mach_msg_body_t) &#123;</span><br><span class=\"line\">    .msgh_descriptor_count = 1</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">message.type = (mach_msg_type_descriptor_t) &#123;</span><br><span class=\"line\">    .pad1 = data,</span><br><span class=\"line\">    .pad2 = sizeof(data)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">mach_msg_return_t error = mach_msg_send(&amp;message.header);</span><br><span class=\"line\"></span><br><span class=\"line\">if (error == MACH_MSG_SUCCESS) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（消息）接收端稍微轻松点，因为消息只需要被声明而不用初始化：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mach_port_t port;</span><br><span class=\"line\"></span><br><span class=\"line\">struct &#123;</span><br><span class=\"line\">    mach_msg_header_t header;</span><br><span class=\"line\">    mach_msg_body_t body;</span><br><span class=\"line\">    mach_msg_type_descriptor_t type;</span><br><span class=\"line\">    mach_msg_trailer_t trailer;</span><br><span class=\"line\">&#125; message;</span><br><span class=\"line\"></span><br><span class=\"line\">mach_msg_return_t error = mach_msg_receive(&amp;message.header);</span><br><span class=\"line\"></span><br><span class=\"line\">if (error == MACH_MSG_SUCCESS) &#123;</span><br><span class=\"line\">    natural_t data = message.type.pad1;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还算不错的是，Core Foundation和Foundation为Mach端口提供了高级API。在内核基础上封装的CFMachPort &#x2F; NSMachPort可以用做runloop源，尽管CFMachPort &#x2F; NSMachPort有利于的是两个不同端口之间的通讯同步。</p>\n<p>CFMessagePort确实非常适合用于简单的一对一通讯。简简单单几行代码，一个本地端口就被附属到runloop源上，只要获取到消息就执行回调。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static CFDataRef Callback(CFMessagePortRef port,</span><br><span class=\"line\">                          SInt32 messageID,</span><br><span class=\"line\">                          CFDataRef data,</span><br><span class=\"line\">                          void *info)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">CFMessagePortRef localPort =</span><br><span class=\"line\">    CFMessagePortCreateLocal(nil,</span><br><span class=\"line\">                             CFSTR(&quot;com.example.app.port.server&quot;),</span><br><span class=\"line\">                             Callback,</span><br><span class=\"line\">                             nil,</span><br><span class=\"line\">                             nil);</span><br><span class=\"line\"></span><br><span class=\"line\">CFRunLoopSourceRef runLoopSource =</span><br><span class=\"line\">    CFMessagePortCreateRunLoopSource(nil, localPort, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">CFRunLoopAddSource(CFRunLoopGetCurrent(),</span><br><span class=\"line\">                   runLoopSource,</span><br><span class=\"line\">                   kCFRunLoopCommonModes);</span><br></pre></td></tr></table></figure>\n\n<p>若要进行发送数据同样也十分直截了当。只要完成指定远端的端口，装载数据，还有设置发送与接收的超时时间的操作。剩下就由CFMessagePortSendRequest来接管了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CFDataRef data;</span><br><span class=\"line\">SInt32 messageID = 0x1111; // Arbitrary</span><br><span class=\"line\">CFTimeInterval timeout = 10.0;</span><br><span class=\"line\"></span><br><span class=\"line\">CFMessagePortRef remotePort =</span><br><span class=\"line\">    CFMessagePortCreateRemote(nil,</span><br><span class=\"line\">                              CFSTR(&quot;com.example.app.port.client&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">SInt32 status =</span><br><span class=\"line\">    CFMessagePortSendRequest(remotePort,</span><br><span class=\"line\">                             messageID,</span><br><span class=\"line\">                             data,</span><br><span class=\"line\">                             timeout,</span><br><span class=\"line\">                             timeout,</span><br><span class=\"line\">                             NULL,</span><br><span class=\"line\">                             NULL);</span><br><span class=\"line\">if (status == kCFMessagePortSuccess) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Distributed-Notifications\"><a href=\"#Distributed-Notifications\" class=\"headerlink\" title=\"Distributed Notifications\"></a>Distributed Notifications</h1><p>在Cocoa中有很多种两个对象进行通信的途径。</p>\n<p>当然也能进行直接消息传递。也有像目标-动作，代理，回调这些解耦，一对一的设计模式。KVO允许让很多对象订阅一个事件，但是它把这些对象都联系起来了。另一方面通知让消息全局广播，并且让有监听该广播的对象接收该消息。【注：想知道发了多少次广播吗？添加 NSNotificationCenter addObserverForName:object:queue:usingBlock，其中name与object置nil，看block被调用了几次。】</p>\n<p>每个应用为基础应用消息发布-订阅对自身通知中心实例进行管理。但是鲜有人知的APICFNotificationCenterGetDistributedCenter的通知可以进行系统级别范围的通信。</p>\n<p>为了获取通知，添加所要指定监听消息名的观察者到通知发布中心，当消息接收到的时候函数指针指向的函数将被执行一次：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void Callback(CFNotificationCenterRef center,</span><br><span class=\"line\">                     void *observer,</span><br><span class=\"line\">                     CFStringRef name,</span><br><span class=\"line\">                     const void *object,</span><br><span class=\"line\">                     CFDictionaryRef userInfo)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">CFNotificationCenterRef distributedCenter =</span><br><span class=\"line\">    CFNotificationCenterGetDistributedCenter();</span><br><span class=\"line\"></span><br><span class=\"line\">CFNotificationSuspensionBehavior behavior =</span><br><span class=\"line\">        CFNotificationSuspensionBehaviorDeliverImmediately;</span><br><span class=\"line\"></span><br><span class=\"line\">CFNotificationCenterAddObserver(distributedCenter,</span><br><span class=\"line\">                                NULL,</span><br><span class=\"line\">                                Callback,</span><br><span class=\"line\">                                CFSTR(&quot;notification.identifier&quot;),</span><br><span class=\"line\">                                NULL,</span><br><span class=\"line\">                                behavior);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>发送端代码更为简单，只要配置好ID,对象还有user info：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void *object;</span><br><span class=\"line\">CFDictionaryRef userInfo;</span><br><span class=\"line\"></span><br><span class=\"line\">CFNotificationCenterRef distributedCenter =</span><br><span class=\"line\">    CFNotificationCenterGetDistributedCenter();</span><br><span class=\"line\"></span><br><span class=\"line\">CFNotificationCenterPostNotification(distributedCenter,</span><br><span class=\"line\">                                     CFSTR(&quot;notification.identifier&quot;),</span><br><span class=\"line\">                                     object,</span><br><span class=\"line\">                                     userInfo,</span><br><span class=\"line\">                                     true);</span><br></pre></td></tr></table></figure>\n\n<p>链接两个应用通信的方式中，分发式通知是最为简单的。用它来进行大量数据的传输是不明智的，但是对于轻量级信息同步，分发式通知堪称完美。</p>\n<h1 id=\"Distributed-Objects\"><a href=\"#Distributed-Objects\" class=\"headerlink\" title=\"Distributed Objects\"></a>Distributed Objects</h1><p>90年代中NeXT全盛时期，分发式对象（DO）是Cocoa框架中一个远程消息发送特性。尽管现在已经不再大范围的使用，在现代奇数层上IPC无障碍通信仍然并未实现。</p>\n<p>使用DO分发一个对象仅仅是搭建一个NSConnection并将其注册为特殊（你分的清楚）的名字：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@protocol Protocol;</span><br><span class=\"line\"></span><br><span class=\"line\">id &lt;Protocol&gt; vendedObject;</span><br><span class=\"line\"></span><br><span class=\"line\">NSConnection *connection = [[NSConnection alloc] init];</span><br><span class=\"line\">[connection setRootObject:vendedObject];</span><br><span class=\"line\">[connection registerName:@&quot;server&quot;];</span><br></pre></td></tr></table></figure>\n\n<p>另外一个应用将会也建立同样名字的并注册过的链接，然后立即获取一个原子代理当做原始对象。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id proxy = [NSConnection rootProxyForConnectionWithRegisteredName:@&quot;server&quot; host:nil];</span><br><span class=\"line\">[proxy setProtocolForProxy:@protocol(Protocol)];</span><br></pre></td></tr></table></figure>\n\n<p>只要分发对象代理收到消息了，一个通过NSConnection连接远程调用（RPC）将会根据发送对象进行对应的计算并且返回结果给代理。【注：原理是一个OS管理的共享的NSPortNameServer实例对这个带着名字的连接进行管控。】</p>\n<p>分发式对象简单，透明，健壮。简直就是Cocoa中的标杆。。。</p>\n<p>实际上，分布式对象不能像局部对象那样使用，那就是因为任何发送给代理的消息都可能抛出异常。不想其他语言，OC没有异常处理控制流程。所以对任何东西都进行@try&#x2F;@catch也算是Cocoa大会很凄凉的补救了。</p>\n<p>DO还有一个原因致其使用不便。在试图通过连接“marshal values”时，对象和原语的差距尤为明显。<br>此外，连接是完全加密的，和下方通信信道扩展性的缺乏致使其在大多数的使用中通信被迫中断。</p>\n<p>下方是左列分布式对象用来指定其属性代理行为和方法参数的注解：</p>\n<ul>\n<li>in：输入参数，后续不再引用</li>\n<li>out：参数被引用作为返回值</li>\n<li>inout：输入参数，引用作为返回值</li>\n<li>const：常量参数</li>\n<li>oneway：无障碍结果返回</li>\n<li>bycopy：返回对象的拷贝</li>\n<li>byref：返回对象的代理</li>\n</ul>\n<h1 id=\"AppleEvents-AppleScript\"><a href=\"#AppleEvents-AppleScript\" class=\"headerlink\" title=\"AppleEvents &amp; AppleScript\"></a>AppleEvents &amp; AppleScript</h1><p>AppleEvents是经典Macintosh操作系统最持久的遗产。在System 7推出的AppleEvents允许应用程序在本地使用AppleScript或者使用程序链接的功能进行程序控制。现在AppleScript使用Cocoa Scripting Bridge，仍然是OS X应用进程间最直接的交互方式。【注：Mac系统的苹果时间管理中心为AppleEvents提供了原始低级传送机制，但是是在OS X的Mach端口基础之上的重实现】。</p>\n<p>也就是说，使用起来这是简单而又古怪的技术之一。</p>\n<p>AppleScript使用自然语言语法，设计初衷是没有涉及参数而更容易掌握。虽然与人交流更亲和了，但是写起来确实噩梦。</p>\n<p>为了更好的了解人类自然性，这里有个栗子教你怎么让Safari在最前的窗口的激活栏打开一个URL。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tell application &quot;Safari&quot;</span><br><span class=\"line\">  set the URL of the front document to &quot;http://nshipster.com&quot;</span><br><span class=\"line\">end tell</span><br></pre></td></tr></table></figure>\n\n<p>在大部分情况下，AppleScript的语法自然语言的特性更多是不便不是优势。（吐槽。。。略略略）</p>\n<p>即便是经验老道的OC开发者，不靠文档或者栗子写出AppleScript是不可能的任务。</p>\n<p>幸运的是，Scripting Bridge为Cocoa应用提供了更友善的编程接口。</p>\n<h1 id=\"Cocoa-Scripting-Bridge\"><a href=\"#Cocoa-Scripting-Bridge\" class=\"headerlink\" title=\"Cocoa Scripting Bridge\"></a>Cocoa Scripting Bridge</h1><p>为了使用Scripting Bridge与应用进行交互，首先要先添加一个编程接口：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sdef /Applications/Safari.app | sdp -fh --basename Safari</span><br></pre></td></tr></table></figure>\n\n<p>sdef为应用生成脚本定义文件。这些文件可以以管道输入道sdp并格式转成（在这里是）C头文件。这样的结果是添加该头文件到应用工程并提供第一类对象接口。</p>\n<p>这里举个栗子来解释如何使用Cocoa Scripting Bridge：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;Safari.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">SafariApplication *safari = [SBApplication applicationWithBundleIdentifier:@&quot;com.apple.Safari&quot;];</span><br><span class=\"line\"></span><br><span class=\"line\">for (SafariWindow *window in safari.windows) &#123;</span><br><span class=\"line\">    if (window.visible) &#123;</span><br><span class=\"line\">        window.currentTab.URL = [NSURL URLWithString:@&quot;http://nshipster.com&quot;];</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对比AppleScript上面显得冗繁了点，但是却更容易集成到已存在的代码中去。在可读性上更优因为毕竟长得更像OC。</p>\n<p>唉，AppleScript的星芒也正出现消退，在最近发布的OS X与iWork应用证答复减少它的戏份。从这点说，未必值得在你的应用中去添加这项（脚本）支持。</p>\n<h1 id=\"Pasteboard\"><a href=\"#Pasteboard\" class=\"headerlink\" title=\"Pasteboard\"></a>Pasteboard</h1><p>剪贴板是OS X与iOS最常见的进程间通信机制。当用户跨应用拷贝了一段文字，图片，文档，这时候通过mach port的com.apple.pboard服务媒介进行从一个进程到另一个进程的数据交换。</p>\n<p>OS X上是NSPasteboard，iOS上对应的是UIPasteboard。它们几乎是别无二致，但尽管大致一样，对比OS X iOS上提供了更简洁，更现代化却又不影响功效的API。</p>\n<p>编写剪贴板代码几乎就跟在GUI应用上使用Edit &gt; Copy操作一样简单：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSImage *image;</span><br><span class=\"line\"></span><br><span class=\"line\">NSPasteboard *pasteboard = [NSPasteboard generalPasteboard];</span><br><span class=\"line\">[pasteboard clearContents];</span><br><span class=\"line\">[pasteboard writeObjects:@[image]];</span><br></pre></td></tr></table></figure>\n\n<p>因为剪贴动作太频繁了，所以要确认剪贴内容是否是你（应用）所需要得：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSPasteboard *pasteboard = [NSPasteboard generalPasteboard];</span><br><span class=\"line\"></span><br><span class=\"line\">if ([pasteboard canReadObjectForClasses:@[[NSImage class]] options:nil]) &#123;</span><br><span class=\"line\">    NSArray *contents = [pasteboard readObjectsForClasses:@[[NSImage class]] options: nil];</span><br><span class=\"line\">    NSImage *image = [contents firstObject];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"XPC\"><a href=\"#XPC\" class=\"headerlink\" title=\"XPC\"></a>XPC</h1><p>XPC是SDK中最先进的进程间通讯技术。它架构之初的目的在于避免长时间得运行过程，来适应有限的资源，在可能运行的时候才进行初始化。把XPC纳入应用而不做任何事情的想法是不现实的，但这样提供了更好的进程间的特权分离和故障隔离。</p>\n<p>XPC作为NSTask替代品甚至更多。</p>\n<p>2011推出以来，XPC为OS X上的应用沙盒提供基础设施，iOS上的远程试图控制器，还有两个平台上的应用扩展。它还广范围的用在系统框架和第一方应用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ find /Applications -name \\*.xpc</span><br></pre></td></tr></table></figure>\n\n<p>控制台输入上面的命令行你会知道XPC无处不在。在一般应用中同样的情形也在发生，比如图片或者视频转变服务，系统调用，网页服务加载，或是第三方的授权。</p>\n<p>XPC负责进程间通讯的同时还负责该服务生命周期的管理。包括注册服务，启动，以及通过launchd解决服务之间的通讯。一个XPC服务可以根据需求地洞，或者在崩溃的时候重启，或者是空闲的时候终止。正因如此，服务可以完全被设计成无状态的，以便于在运行的任何时间点的突然终止都能做到影响不大。</p>\n<p>作为被iOS还有OS X中backported所采用的安全模块，XPC服务默认运行在最为严格的环境：不能访问文件，不能访问网络，没有根权限升级。任何能做的事情就是对照被赋予的白名单列表。</p>\n<p>XPC可以被libxpc C API访问，或者是NSXPCConnection OC API。【注：作者会用低级API去实现（纯C）】</p>\n<p>XPC服务要么存在于应用的沙盒中亦或是使用launchd调用跑在后台。</p>\n<p>服务调用带事件句柄的xpc_main来获取新的XPC连接。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void connection_handler(xpc_connection_t peer) &#123;</span><br><span class=\"line\">    xpc_connection_set_event_handler(peer, ^(xpc_object_t event) &#123;</span><br><span class=\"line\">        peer_event_handler(peer, event);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    xpc_connection_resume(peer);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char *argv[]) &#123;</span><br><span class=\"line\">   xpc_main(connection_handler);</span><br><span class=\"line\">   exit(EXIT_FAILURE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>每个XPC连接是一对一的，意味着服务在不同的连接进行操作，每次调用xpc_connection_create就会创建一个新的链接。【注：类似BSD套接字中的API accept函数，服务在单个文件描述符进行监听来为范围内的链接创建额外描述符】：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xpc_connection_t c = xpc_connection_create(&quot;com.example.service&quot;, NULL);</span><br><span class=\"line\">xpc_connection_set_event_handler(c, ^(xpc_object_t event) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">xpc_connection_resume(c);</span><br></pre></td></tr></table></figure>\n\n<p>当一个消息发送到XPC链接，将自动的派发到一个由runtime管理的消息队列中。当链接的远端一旦开启的时候，消息将出队并被发送。</p>\n<p>每个消息就是一个字典，字符串key和强类型值：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xpc_dictionary_t message = xpc_dictionary_create(NULL, NULL, 0);</span><br><span class=\"line\">xpc_dictionary_set_uint64(message, &quot;foo&quot;, 1);</span><br><span class=\"line\">xpc_connection_send_message(c, message);</span><br><span class=\"line\">xpc_release(message)</span><br></pre></td></tr></table></figure>\n\n<p>XPC对象对下列原始类型进行操作：</p>\n<ul>\n<li>Data</li>\n<li>Boolean</li>\n<li>Double</li>\n<li>String</li>\n<li>Signed Integer</li>\n<li>Unsigned Integer</li>\n<li>Date</li>\n<li>UUID</li>\n<li>Array</li>\n<li>Dictionary</li>\n<li>Null</li>\n</ul>\n<p>XPC提供了一个便捷的方法来从dispatch_data_t数据类型进行转换，这样从GCD到XPC的工作流程就简化了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void *buffer;</span><br><span class=\"line\">size_t length;</span><br><span class=\"line\">dispatch_data_t ddata =</span><br><span class=\"line\">    dispatch_data_create(buffer,</span><br><span class=\"line\">                         length,</span><br><span class=\"line\">                         DISPATCH_TARGET_QUEUE_DEFAULT,</span><br><span class=\"line\">                         DISPATCH_DATA_DESTRUCTOR_MUNMAP);</span><br><span class=\"line\"></span><br><span class=\"line\">xpc_object_t xdata = xpc_data_create_with_dispatch_data(ddata);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"服务注册\"><a href=\"#服务注册\" class=\"headerlink\" title=\"服务注册\"></a>服务注册</h1><p>XPC可以注册成启动项任务，配置成匹配IOKit事件自动启动，BSD通知或者是CFDistributedNotifications。这些标准都指定在服务的launchd.plist文件里：<br>.launchd.plist</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;key&gt;LaunchEvents&lt;/key&gt;</span><br><span class=\"line\">&lt;dict&gt;</span><br><span class=\"line\">  &lt;key&gt;com.apple.iokit.matching&lt;/key&gt;</span><br><span class=\"line\">  &lt;dict&gt;</span><br><span class=\"line\">      &lt;key&gt;com.example.device-attach&lt;/key&gt;</span><br><span class=\"line\">      &lt;dict&gt;</span><br><span class=\"line\">          &lt;key&gt;idProduct&lt;/key&gt;</span><br><span class=\"line\">          &lt;integer&gt;2794&lt;/integer&gt;</span><br><span class=\"line\">          &lt;key&gt;idVendor&lt;/key&gt;</span><br><span class=\"line\">          &lt;integer&gt;725&lt;/integer&gt;</span><br><span class=\"line\">          &lt;key&gt;IOProviderClass&lt;/key&gt;</span><br><span class=\"line\">          &lt;string&gt;IOUSBDevice&lt;/string&gt;</span><br><span class=\"line\">          &lt;key&gt;IOMatchLaunchStream&lt;/key&gt;</span><br><span class=\"line\">          &lt;true/&gt;</span><br><span class=\"line\">          &lt;key&gt;ProcessType&lt;/key&gt;</span><br><span class=\"line\">          &lt;string&gt;Adaptive&lt;/string&gt;</span><br><span class=\"line\">      &lt;/dict&gt;</span><br><span class=\"line\">  &lt;/dict&gt;</span><br><span class=\"line\">&lt;/dict&gt;</span><br></pre></td></tr></table></figure>\n\n<p>最近一次对于launchd属性列表的修改是增加了ProcessType Key，其用来在高级层面上描述启动机构的预期目的。根据预描述行为期望，操作系统会响应调整CPU和I&#x2F;O的阈值。</p>\n<p><img src=\"/2019/03/12/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91iOS%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E9%97%B4%E6%98%AF%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1%E7%9A%84/articlex.png\" alt=\"图片描述\"></p>\n<p>为了注册一个服务运行大概五分钟的时间，一套标准需要传送给xpc_activity_register：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xpc_object_t criteria = xpc_dictionary_create(NULL, NULL, 0);</span><br><span class=\"line\">xpc_dictionary_set_int64(criteria, XPC_ACTIVITY_INTERVAL, 5 * 60);</span><br><span class=\"line\">xpc_dictionary_set_int64(criteria, XPC_ACTIVITY_GRACE_PERIOD, 10 * 60);</span><br><span class=\"line\"></span><br><span class=\"line\">xpc_activity_register(&quot;com.example.app.activity&quot;,</span><br><span class=\"line\">                      criteria,</span><br><span class=\"line\">                      ^(xpc_activity_t activity)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // Process Data</span><br><span class=\"line\"></span><br><span class=\"line\">    xpc_activity_set_state(activity, XPC_ACTIVITY_STATE_CONTINUE);</span><br><span class=\"line\"></span><br><span class=\"line\">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">        // Update UI</span><br><span class=\"line\"></span><br><span class=\"line\">        xpc_activity_set_state(activity, XPC_ACTIVITY_STATE_DONE);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>"}],"PostAsset":[{"_id":"source/_posts/AutoreleasePool源码分析/双向链表.png","post":"clkcgbp540001pfo73n9edpqx","slug":"双向链表.png","modified":1,"renderable":1},{"_id":"source/_posts/iOS Reveal2Loader修复版（iOS13修复）/QQ20190225-124715@2x.png","post":"clkcgbp5b000bpfo7c1j6ezhc","slug":"QQ20190225-124715@2x.png","modified":1,"renderable":1},{"_id":"source/_posts/iOS Reveal2Loader修复版（iOS13修复）/QQ20190225-124731@2x.png","post":"clkcgbp5b000bpfo7c1j6ezhc","slug":"QQ20190225-124731@2x.png","modified":1,"renderable":1},{"_id":"source/_posts/如何利用RunLoop的知识来监测APP卡顿/5f51c5e05085badb689f01b1e63e1c7d.png","post":"clkcgbp5i0019pfo736mnfnic","slug":"5f51c5e05085badb689f01b1e63e1c7d.png","modified":1,"renderable":1},{"_id":"source/_posts/如何利用RunLoop的知识来监测APP卡顿/图片 1.png","post":"clkcgbp5i0019pfo736mnfnic","slug":"图片 1.png","modified":1,"renderable":1},{"_id":"source/_posts/iOS底层之RunLoop/RunLoop_0.png","post":"clkcgbp5h0017pfo72n062gmt","slug":"RunLoop_0.png","modified":1,"renderable":1},{"_id":"source/_posts/iOS底层之RunLoop/RunLoop_1.png","post":"clkcgbp5h0017pfo72n062gmt","slug":"RunLoop_1.png","modified":1,"renderable":1},{"_id":"source/_posts/iOS底层之RunLoop/RunLoop_3.png","post":"clkcgbp5h0017pfo72n062gmt","slug":"RunLoop_3.png","modified":1,"renderable":1},{"_id":"source/_posts/iOS底层之RunLoop/RunLoop_4.png","post":"clkcgbp5h0017pfo72n062gmt","slug":"RunLoop_4.png","modified":1,"renderable":1},{"_id":"source/_posts/iOS底层之RunLoop/RunLoop_network.png","post":"clkcgbp5h0017pfo72n062gmt","slug":"RunLoop_network.png","modified":1,"renderable":1},{"_id":"source/_posts/【转载】iOS进程-线程-间是如何通信的/articlex.png","post":"clkcgbp5j001bpfo74a0f0ox0","slug":"articlex.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"clkcgbp540001pfo73n9edpqx","category_id":"clkcgbp570004pfo7bmf10re4","_id":"clkcgbp5c000epfo73l0cc2ap"},{"post_id":"clkcgbp560003pfo73vgwe1bl","category_id":"clkcgbp5b000cpfo75b7ievdp","_id":"clkcgbp5d000ipfo754d11x3z"},{"post_id":"clkcgbp590007pfo7a85xcg7t","category_id":"clkcgbp5b000cpfo75b7ievdp","_id":"clkcgbp5e000mpfo782hj13ym"},{"post_id":"clkcgbp5a0009pfo7dmxe7wwb","category_id":"clkcgbp5b000cpfo75b7ievdp","_id":"clkcgbp5e000qpfo7484e3uck"},{"post_id":"clkcgbp5b000bpfo7c1j6ezhc","category_id":"clkcgbp5e000lpfo7czm65f0p","_id":"clkcgbp5f000tpfo77bwe7uof"},{"post_id":"clkcgbp5h0016pfo799llcj2k","category_id":"clkcgbp570004pfo7bmf10re4","_id":"clkcgbp5j001cpfo7grbo33kn"},{"post_id":"clkcgbp5h0017pfo72n062gmt","category_id":"clkcgbp570004pfo7bmf10re4","_id":"clkcgbp5k001fpfo75ieh9at2"},{"post_id":"clkcgbp5j001bpfo74a0f0ox0","category_id":"clkcgbp570004pfo7bmf10re4","_id":"clkcgbp5k001jpfo78djk5gq7"},{"post_id":"clkcgbp5i0019pfo736mnfnic","category_id":"clkcgbp5j001dpfo7aac0ai67","_id":"clkcgbp5k001mpfo716bfbkkr"}],"PostTag":[{"post_id":"clkcgbp540001pfo73n9edpqx","tag_id":"clkcgbp580005pfo7e0a99r49","_id":"clkcgbp5d000kpfo74g933c55"},{"post_id":"clkcgbp540001pfo73n9edpqx","tag_id":"clkcgbp5b000dpfo7cz9n6jnd","_id":"clkcgbp5e000npfo7af08dxew"},{"post_id":"clkcgbp540001pfo73n9edpqx","tag_id":"clkcgbp5c000gpfo7cki71gvf","_id":"clkcgbp5e000ppfo7d8mp5t5y"},{"post_id":"clkcgbp560003pfo73vgwe1bl","tag_id":"clkcgbp5d000jpfo7c7jfbtan","_id":"clkcgbp5e000spfo7ggma90yb"},{"post_id":"clkcgbp560003pfo73vgwe1bl","tag_id":"clkcgbp5e000opfo78nk0h2nf","_id":"clkcgbp5f000upfo7ax1v7bx6"},{"post_id":"clkcgbp590007pfo7a85xcg7t","tag_id":"clkcgbp5e000rpfo7aorf07iw","_id":"clkcgbp5f000xpfo7c7wy8d8f"},{"post_id":"clkcgbp590007pfo7a85xcg7t","tag_id":"clkcgbp5e000opfo78nk0h2nf","_id":"clkcgbp5f000ypfo7hq7mbiif"},{"post_id":"clkcgbp5a0009pfo7dmxe7wwb","tag_id":"clkcgbp5f000wpfo713ya8qrd","_id":"clkcgbp5g0011pfo735g3gwod"},{"post_id":"clkcgbp5a0009pfo7dmxe7wwb","tag_id":"clkcgbp5e000opfo78nk0h2nf","_id":"clkcgbp5g0012pfo7gc57gb49"},{"post_id":"clkcgbp5b000bpfo7c1j6ezhc","tag_id":"clkcgbp5f0010pfo7g4t416vo","_id":"clkcgbp5g0014pfo71t2k3ulk"},{"post_id":"clkcgbp5b000bpfo7c1j6ezhc","tag_id":"clkcgbp5g0013pfo7d0f4aepb","_id":"clkcgbp5g0015pfo74jrv6ctt"},{"post_id":"clkcgbp5h0017pfo72n062gmt","tag_id":"clkcgbp5b000dpfo7cz9n6jnd","_id":"clkcgbp5j001apfo7f0zo46gd"},{"post_id":"clkcgbp5h0017pfo72n062gmt","tag_id":"clkcgbp5c000gpfo7cki71gvf","_id":"clkcgbp5j001epfo7bbrsg4im"},{"post_id":"clkcgbp5i0019pfo736mnfnic","tag_id":"clkcgbp5b000dpfo7cz9n6jnd","_id":"clkcgbp5k001hpfo76jjgbtya"},{"post_id":"clkcgbp5h0016pfo799llcj2k","tag_id":"clkcgbp5i0018pfo724xvhttk","_id":"clkcgbp5k001ipfo73zdd7si3"},{"post_id":"clkcgbp5h0016pfo799llcj2k","tag_id":"clkcgbp5c000gpfo7cki71gvf","_id":"clkcgbp5k001kpfo737l80hnn"},{"post_id":"clkcgbp5j001bpfo74a0f0ox0","tag_id":"clkcgbp5k001gpfo7g14c9gsg","_id":"clkcgbp5k001lpfo70iepbmr1"},{"post_id":"clkcgbp5j001bpfo74a0f0ox0","tag_id":"clkcgbp5c000gpfo7cki71gvf","_id":"clkcgbp5k001npfo75hz00xfz"}],"Tag":[{"name":"Autorelease","_id":"clkcgbp580005pfo7e0a99r49"},{"name":"RunLoop","_id":"clkcgbp5b000dpfo7cz9n6jnd"},{"name":"底层原理","_id":"clkcgbp5c000gpfo7cki71gvf"},{"name":"通知","_id":"clkcgbp5d000jpfo7c7jfbtan"},{"name":"多线程","_id":"clkcgbp5e000opfo78nk0h2nf"},{"name":"GCD","_id":"clkcgbp5e000rpfo7aorf07iw"},{"name":"iOS线程锁","_id":"clkcgbp5f000wpfo713ya8qrd"},{"name":"Reveal2Loader","_id":"clkcgbp5f0010pfo7g4t416vo"},{"name":"越狱插件","_id":"clkcgbp5g0013pfo7d0f4aepb"},{"name":"Block","_id":"clkcgbp5i0018pfo724xvhttk"},{"name":"转载","_id":"clkcgbp5k001gpfo7g14c9gsg"}]}}