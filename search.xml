<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【转载】iOS进程间是如何通信的]]></title>
    <url>%2F2019%2F03%2F12%2F%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91iOS%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E9%97%B4%E6%98%AF%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1%E7%9A%84%2F</url>
    <content type="text"><![CDATA[总起OS X是MacOS与NeXTSTEP的结合。OC是Smalltalk类面向对象编程与C的结合。iCloud则是苹果移动服务与云平台的结合。 上述都是一些亮点，但是不得不说苹果技术中的进程通讯走的是“反人类”的道路。 由于不是根据每个节点上最优原则进行设计，苹果的进程间通信解决方案更显得混乱扎堆。结果是，大量重叠，不兼容的IPC技术在各个抽象层随处可见。（除了GCD还有剪贴板） Mach Ports Distributed Notifications Distributed Objects AppleEvents &amp; AppleScript Pasteboard XPC 从低级内核抽象到高级，面向对象的API，它们都有各自特殊的表现以及安全特性。但是基础层面来看，它们都是从不同上下文段传递或者获取数据的机制。 原文链接 转载自此处 Mach Ports所有的进程间通讯最终落实依赖的还是Mach内核API提供的功能。 Mach端口是轻量并且强大的而又缺少相关文档晦涩使用的（天使与恶魔）。 通过一个Mach端口发送一个消息调用一次mach_msg_send方法，但是这里需要做一些配置来构建待发送的消息： 123456789101112131415161718192021222324252627282930natural_t data;mach_port_t port;struct &#123; mach_msg_header_t header; mach_msg_body_t body; mach_msg_type_descriptor_t type;&#125; message;message.header = (mach_msg_header_t) &#123; .msgh_remote_port = port, .msgh_local_port = MACH_PORT_NULL, .msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, 0), .msgh_size = sizeof(message)&#125;;message.body = (mach_msg_body_t) &#123; .msgh_descriptor_count = 1&#125;;message.type = (mach_msg_type_descriptor_t) &#123; .pad1 = data, .pad2 = sizeof(data)&#125;;mach_msg_return_t error = mach_msg_send(&amp;message.header);if (error == MACH_MSG_SUCCESS) &#123; // ...&#125; （消息）接收端稍微轻松点，因为消息只需要被声明而不用初始化： 123456789101112131415mach_port_t port;struct &#123; mach_msg_header_t header; mach_msg_body_t body; mach_msg_type_descriptor_t type; mach_msg_trailer_t trailer;&#125; message;mach_msg_return_t error = mach_msg_receive(&amp;message.header);if (error == MACH_MSG_SUCCESS) &#123; natural_t data = message.type.pad1; // ...&#125; 还算不错的是，Core Foundation和Foundation为Mach端口提供了高级API。在内核基础上封装的CFMachPort / NSMachPort可以用做runloop源，尽管CFMachPort / NSMachPort有利于的是两个不同端口之间的通讯同步。 CFMessagePort确实非常适合用于简单的一对一通讯。简简单单几行代码，一个本地端口就被附属到runloop源上，只要获取到消息就执行回调。 123456789101112131415161718192021static CFDataRef Callback(CFMessagePortRef port, SInt32 messageID, CFDataRef data, void *info)&#123; // ...&#125;CFMessagePortRef localPort = CFMessagePortCreateLocal(nil, CFSTR(&quot;com.example.app.port.server&quot;), Callback, nil, nil);CFRunLoopSourceRef runLoopSource = CFMessagePortCreateRunLoopSource(nil, localPort, 0);CFRunLoopAddSource(CFRunLoopGetCurrent(), runLoopSource, kCFRunLoopCommonModes); 若要进行发送数据同样也十分直截了当。只要完成指定远端的端口，装载数据，还有设置发送与接收的超时时间的操作。剩下就由CFMessagePortSendRequest来接管了。 12345678910111213141516171819CFDataRef data;SInt32 messageID = 0x1111; // ArbitraryCFTimeInterval timeout = 10.0;CFMessagePortRef remotePort = CFMessagePortCreateRemote(nil, CFSTR(&quot;com.example.app.port.client&quot;));SInt32 status = CFMessagePortSendRequest(remotePort, messageID, data, timeout, timeout, NULL, NULL);if (status == kCFMessagePortSuccess) &#123; // ...&#125; Distributed Notifications在Cocoa中有很多种两个对象进行通信的途径。 当然也能进行直接消息传递。也有像目标-动作，代理，回调这些解耦，一对一的设计模式。KVO允许让很多对象订阅一个事件，但是它把这些对象都联系起来了。另一方面通知让消息全局广播，并且让有监听该广播的对象接收该消息。【注：想知道发了多少次广播吗？添加 NSNotificationCenter addObserverForName:object:queue:usingBlock，其中name与object置nil，看block被调用了几次。】 每个应用为基础应用消息发布-订阅对自身通知中心实例进行管理。但是鲜有人知的APICFNotificationCenterGetDistributedCenter的通知可以进行系统级别范围的通信。 为了获取通知，添加所要指定监听消息名的观察者到通知发布中心，当消息接收到的时候函数指针指向的函数将被执行一次： 123456789101112131415161718192021static void Callback(CFNotificationCenterRef center, void *observer, CFStringRef name, const void *object, CFDictionaryRef userInfo)&#123; // ...&#125;CFNotificationCenterRef distributedCenter = CFNotificationCenterGetDistributedCenter();CFNotificationSuspensionBehavior behavior = CFNotificationSuspensionBehaviorDeliverImmediately;CFNotificationCenterAddObserver(distributedCenter, NULL, Callback, CFSTR(&quot;notification.identifier&quot;), NULL, behavior); 发送端代码更为简单，只要配置好ID,对象还有user info： 1234567891011void *object;CFDictionaryRef userInfo;CFNotificationCenterRef distributedCenter = CFNotificationCenterGetDistributedCenter();CFNotificationCenterPostNotification(distributedCenter, CFSTR(&quot;notification.identifier&quot;), object, userInfo, true); 链接两个应用通信的方式中，分发式通知是最为简单的。用它来进行大量数据的传输是不明智的，但是对于轻量级信息同步，分发式通知堪称完美。 Distributed Objects90年代中NeXT全盛时期，分发式对象（DO）是Cocoa框架中一个远程消息发送特性。尽管现在已经不再大范围的使用，在现代奇数层上IPC无障碍通信仍然并未实现。 使用DO分发一个对象仅仅是搭建一个NSConnection并将其注册为特殊（你分的清楚）的名字： 1234567@protocol Protocol;id &lt;Protocol&gt; vendedObject;NSConnection *connection = [[NSConnection alloc] init];[connection setRootObject:vendedObject];[connection registerName:@&quot;server&quot;]; 另外一个应用将会也建立同样名字的并注册过的链接，然后立即获取一个原子代理当做原始对象。 12id proxy = [NSConnection rootProxyForConnectionWithRegisteredName:@&quot;server&quot; host:nil];[proxy setProtocolForProxy:@protocol(Protocol)]; 只要分发对象代理收到消息了，一个通过NSConnection连接远程调用（RPC）将会根据发送对象进行对应的计算并且返回结果给代理。【注：原理是一个OS管理的共享的NSPortNameServer实例对这个带着名字的连接进行管控。】 分发式对象简单，透明，健壮。简直就是Cocoa中的标杆。。。 实际上，分布式对象不能像局部对象那样使用，那就是因为任何发送给代理的消息都可能抛出异常。不想其他语言，OC没有异常处理控制流程。所以对任何东西都进行@try/@catch也算是Cocoa大会很凄凉的补救了。 DO还有一个原因致其使用不便。在试图通过连接“marshal values”时，对象和原语的差距尤为明显。此外，连接是完全加密的，和下方通信信道扩展性的缺乏致使其在大多数的使用中通信被迫中断。 下方是左列分布式对象用来指定其属性代理行为和方法参数的注解： in：输入参数，后续不再引用 out：参数被引用作为返回值 inout：输入参数，引用作为返回值 const：常量参数 oneway：无障碍结果返回 bycopy：返回对象的拷贝 byref：返回对象的代理 AppleEvents &amp; AppleScriptAppleEvents是经典Macintosh操作系统最持久的遗产。在System 7推出的AppleEvents允许应用程序在本地使用AppleScript或者使用程序链接的功能进行程序控制。现在AppleScript使用Cocoa Scripting Bridge，仍然是OS X应用进程间最直接的交互方式。【注：Mac系统的苹果时间管理中心为AppleEvents提供了原始低级传送机制，但是是在OS X的Mach端口基础之上的重实现】。 也就是说，使用起来这是简单而又古怪的技术之一。 AppleScript使用自然语言语法，设计初衷是没有涉及参数而更容易掌握。虽然与人交流更亲和了，但是写起来确实噩梦。 为了更好的了解人类自然性，这里有个栗子教你怎么让Safari在最前的窗口的激活栏打开一个URL。 123tell application &quot;Safari&quot; set the URL of the front document to &quot;http://nshipster.com&quot;end tell 在大部分情况下，AppleScript的语法自然语言的特性更多是不便不是优势。（吐槽。。。略略略） 即便是经验老道的OC开发者，不靠文档或者栗子写出AppleScript是不可能的任务。 幸运的是，Scripting Bridge为Cocoa应用提供了更友善的编程接口。 Cocoa Scripting Bridge为了使用Scripting Bridge与应用进行交互，首先要先添加一个编程接口： 1$ sdef /Applications/Safari.app | sdp -fh --basename Safari sdef为应用生成脚本定义文件。这些文件可以以管道输入道sdp并格式转成（在这里是）C头文件。这样的结果是添加该头文件到应用工程并提供第一类对象接口。 这里举个栗子来解释如何使用Cocoa Scripting Bridge： 12345678910#import &quot;Safari.h&quot;SafariApplication *safari = [SBApplication applicationWithBundleIdentifier:@&quot;com.apple.Safari&quot;];for (SafariWindow *window in safari.windows) &#123; if (window.visible) &#123; window.currentTab.URL = [NSURL URLWithString:@&quot;http://nshipster.com&quot;]; break; &#125;&#125; 对比AppleScript上面显得冗繁了点，但是却更容易集成到已存在的代码中去。在可读性上更优因为毕竟长得更像OC。 唉，AppleScript的星芒也正出现消退，在最近发布的OS X与iWork应用证答复减少它的戏份。从这点说，未必值得在你的应用中去添加这项（脚本）支持。 Pasteboard剪贴板是OS X与iOS最常见的进程间通信机制。当用户跨应用拷贝了一段文字，图片，文档，这时候通过mach port的com.apple.pboard服务媒介进行从一个进程到另一个进程的数据交换。 OS X上是NSPasteboard，iOS上对应的是UIPasteboard。它们几乎是别无二致，但尽管大致一样，对比OS X iOS上提供了更简洁，更现代化却又不影响功效的API。 编写剪贴板代码几乎就跟在GUI应用上使用Edit &gt; Copy操作一样简单： 12345NSImage *image;NSPasteboard *pasteboard = [NSPasteboard generalPasteboard];[pasteboard clearContents];[pasteboard writeObjects:@[image]]; 因为剪贴动作太频繁了，所以要确认剪贴内容是否是你（应用）所需要得： 123456NSPasteboard *pasteboard = [NSPasteboard generalPasteboard];if ([pasteboard canReadObjectForClasses:@[[NSImage class]] options:nil]) &#123; NSArray *contents = [pasteboard readObjectsForClasses:@[[NSImage class]] options: nil]; NSImage *image = [contents firstObject];&#125; XPCXPC是SDK中最先进的进程间通讯技术。它架构之初的目的在于避免长时间得运行过程，来适应有限的资源，在可能运行的时候才进行初始化。把XPC纳入应用而不做任何事情的想法是不现实的，但这样提供了更好的进程间的特权分离和故障隔离。 XPC作为NSTask替代品甚至更多。 2011推出以来，XPC为OS X上的应用沙盒提供基础设施，iOS上的远程试图控制器，还有两个平台上的应用扩展。它还广范围的用在系统框架和第一方应用： 1$ find /Applications -name \*.xpc 控制台输入上面的命令行你会知道XPC无处不在。在一般应用中同样的情形也在发生，比如图片或者视频转变服务，系统调用，网页服务加载，或是第三方的授权。 XPC负责进程间通讯的同时还负责该服务生命周期的管理。包括注册服务，启动，以及通过launchd解决服务之间的通讯。一个XPC服务可以根据需求地洞，或者在崩溃的时候重启，或者是空闲的时候终止。正因如此，服务可以完全被设计成无状态的，以便于在运行的任何时间点的突然终止都能做到影响不大。 作为被iOS还有OS X中backported所采用的安全模块，XPC服务默认运行在最为严格的环境：不能访问文件，不能访问网络，没有根权限升级。任何能做的事情就是对照被赋予的白名单列表。 XPC可以被libxpc C API访问，或者是NSXPCConnection OC API。【注：作者会用低级API去实现（纯C）】 XPC服务要么存在于应用的沙盒中亦或是使用launchd调用跑在后台。 服务调用带事件句柄的xpc_main来获取新的XPC连接。 123456789101112static void connection_handler(xpc_connection_t peer) &#123; xpc_connection_set_event_handler(peer, ^(xpc_object_t event) &#123; peer_event_handler(peer, event); &#125;); xpc_connection_resume(peer);&#125;int main(int argc, const char *argv[]) &#123; xpc_main(connection_handler); exit(EXIT_FAILURE);&#125; 每个XPC连接是一对一的，意味着服务在不同的连接进行操作，每次调用xpc_connection_create就会创建一个新的链接。【注：类似BSD套接字中的API accept函数，服务在单个文件描述符进行监听来为范围内的链接创建额外描述符】： 12345xpc_connection_t c = xpc_connection_create(&quot;com.example.service&quot;, NULL);xpc_connection_set_event_handler(c, ^(xpc_object_t event) &#123; // ...&#125;);xpc_connection_resume(c); 当一个消息发送到XPC链接，将自动的派发到一个由runtime管理的消息队列中。当链接的远端一旦开启的时候，消息将出队并被发送。 每个消息就是一个字典，字符串key和强类型值： 1234xpc_dictionary_t message = xpc_dictionary_create(NULL, NULL, 0);xpc_dictionary_set_uint64(message, &quot;foo&quot;, 1);xpc_connection_send_message(c, message);xpc_release(message) XPC对象对下列原始类型进行操作： Data Boolean Double String Signed Integer Unsigned Integer Date UUID Array Dictionary Null XPC提供了一个便捷的方法来从dispatch_data_t数据类型进行转换，这样从GCD到XPC的工作流程就简化了： 123456789void *buffer;size_t length;dispatch_data_t ddata = dispatch_data_create(buffer, length, DISPATCH_TARGET_QUEUE_DEFAULT, DISPATCH_DATA_DESTRUCTOR_MUNMAP);xpc_object_t xdata = xpc_data_create_with_dispatch_data(ddata); 服务注册XPC可以注册成启动项任务，配置成匹配IOKit事件自动启动，BSD通知或者是CFDistributedNotifications。这些标准都指定在服务的launchd.plist文件里：.launchd.plist 12345678910111213141516171819&lt;key&gt;LaunchEvents&lt;/key&gt;&lt;dict&gt; &lt;key&gt;com.apple.iokit.matching&lt;/key&gt; &lt;dict&gt; &lt;key&gt;com.example.device-attach&lt;/key&gt; &lt;dict&gt; &lt;key&gt;idProduct&lt;/key&gt; &lt;integer&gt;2794&lt;/integer&gt; &lt;key&gt;idVendor&lt;/key&gt; &lt;integer&gt;725&lt;/integer&gt; &lt;key&gt;IOProviderClass&lt;/key&gt; &lt;string&gt;IOUSBDevice&lt;/string&gt; &lt;key&gt;IOMatchLaunchStream&lt;/key&gt; &lt;true/&gt; &lt;key&gt;ProcessType&lt;/key&gt; &lt;string&gt;Adaptive&lt;/string&gt; &lt;/dict&gt; &lt;/dict&gt;&lt;/dict&gt; 最近一次对于launchd属性列表的修改是增加了ProcessType Key，其用来在高级层面上描述启动机构的预期目的。根据预描述行为期望，操作系统会响应调整CPU和I/O的阈值。 为了注册一个服务运行大概五分钟的时间，一套标准需要传送给xpc_activity_register： 123456789101112131415161718xpc_object_t criteria = xpc_dictionary_create(NULL, NULL, 0);xpc_dictionary_set_int64(criteria, XPC_ACTIVITY_INTERVAL, 5 * 60);xpc_dictionary_set_int64(criteria, XPC_ACTIVITY_GRACE_PERIOD, 10 * 60);xpc_activity_register(&quot;com.example.app.activity&quot;, criteria, ^(xpc_activity_t activity)&#123; // Process Data xpc_activity_set_state(activity, XPC_ACTIVITY_STATE_CONTINUE); dispatch_async(dispatch_get_main_queue(), ^&#123; // Update UI xpc_activity_set_state(activity, XPC_ACTIVITY_STATE_DONE); &#125;);&#125;);]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>底层原理</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS Reveal2Loader修复版]]></title>
    <url>%2F2019%2F02%2F25%2FiOS-Reveal2Loader%E4%BF%AE%E5%A4%8D%E7%89%88%2F</url>
    <content type="text"><![CDATA[随着iOS12 越狱的发布，又可以在iOS12的机器上随便搞事情了，但是今天突然发现安装bigBoss上的Reveal2Loader插件替换RevealLoader的库之后竟然无法窥探系统APP和第三方APP，然后在插间内部看到了作者的源码，于是心血来潮就进行了修改一番。 具体修改过程就不说了，修改后的源码,作者源码 打包及安装方法1、cd 到工程目录 执行下列语句 sudo dpkg-deb -b Package reveal2Loader.deb (前提是必须安装dpkg，可以用brew安装也可以用macport安装) 然后会在目录下生成reveal2Loader.deb 2、将reveal2Loader.deb拷贝到手机 3、将原来的reveal2Loader插件卸载，注销SpringBoard 4、直接用filza找到该文件进行安装，前提是卸载之前的旧版本，否则会报错。 enjoy！！！]]></content>
      <categories>
        <category>越狱插件</category>
      </categories>
      <tags>
        <tag>Reveal2Loader</tag>
        <tag>越狱插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS底层之Block]]></title>
    <url>%2F2018%2F06%2F22%2FiOS%E5%BA%95%E5%B1%82%E4%B9%8BBlock%2F</url>
    <content type="text"><![CDATA[在此之前需要先了解一个概念 - 闭包（swift中叫闭包），在维基百科中，闭包的定义如下： 123In programming languages, a closure is a function or reference to a function together with a referencingenvironment—a table storing a reference to each of the non-local variables (also called free variables or upvalues) of that function. 实际上就是一个指向函数的指针。而block实际上就是一个闭包。 block的数据结构 在讲解block之前，我们先需要知道block的数据结构，鉴于苹果block和runtime的开源，block的源代码可以再libclosure找得到，大约在源码中的runtime.c的第44行可以找到如下定义： 12345#define BLOCK_DESCRIPTOR_1 1struct Block_descriptor_1 &#123; uintptr_t reserved; uintptr_t size;&#125;; 第64行中找到block的数据布局： 12345678struct Block_layout &#123; void *isa; volatile int32_t flags; // contains ref count int32_t reserved; void (*invoke)(void *, ...); struct Block_descriptor_1 *descriptor; // imported variables&#125;; 根据runtime.c中的对象定义，凡是首地址为*isa的结构体指针，都认为是对象。然而在OC中，block其实也被默认定义为对象。 通过上面的2附图其实我们可以知道，一个block实际上是由6部分组成： 1、isa指针，所有对象都有一个isa指针，上面也讲到过了，它用于实现对象的一些相关的功能；2、flags，用于按bit位表示的block的附加信息，后面讲block为什么要用copy的时候会讲到；3、reserved，保留的变量；4、invoke，函数指针，用于具体指向block内部实现的函数的调用地址；5、descriptor，表示该block的附加描述信息；6、variables，捕获过来的变量，block之所以能够访问外部的局部变量，是因为将这些变量或者变量的地址拷贝到了这个block的结构体中 写一个简单的例子： 12345678910void foo_()&#123; int i = 2; NSNumber *num = @3; long (^myBlock)(void) = ^long() &#123; return i * num.intValue; &#125;; long r = myBlock();&#125; 在终端中用clang进行反编译会得到如下的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950struct __block_impl &#123; void *isa; int Flags; int Reserved; void *FuncPtr;&#125;;struct __foo_block_desc_0 &#123; size_t reserved; size_t Block_size; void (*copy)(struct __foo_block_impl_0*, struct __foo_block_impl_0*); void (*dispose)(struct __foo_block_impl_0*);&#125;;//myBlock的数据结构定义struct __foo_block_impl_0 &#123; struct __block_impl impl; struct __foo_block_desc_0* Desc; int i; NSNumber *num;&#125;;//block数据的描述static struct __foo_block_desc_0 __foo_block_desc_0_DATA = &#123; 0, sizeof(struct __foo_block_impl_0), __foo_block_copy_0, __foo_block_dispose_0&#125;;//block中的方法static long __foo_block_func_0(struct __foo_block_impl_0 *__cself) &#123; int i = __cself-&gt;i; // bound by copy NSNumber *num = __cself-&gt;num; // bound by copy return i * num.intValue;&#125;void foo()&#123; int i = 2; NSNumber *num = @3; struct __foo_block_impl_0 myBlockT; struct __foo_block_impl_0 *myBlock = &amp;myBlockT; myBlock-&gt;impl.isa = &amp;_NSConcreteStackBlock; myBlock-&gt;impl.Flags = 570425344; myBlock-&gt;impl.FuncPtr = __foo_block_func_0; myBlock-&gt;Desc = &amp;__foo_block_desc_0_DATA; myBlock-&gt;i = i; myBlock-&gt;num = num; long r = myBlock-&gt;impl.FuncPtr(myBlock);&#125; 编译器会根据block捕获的变量，生成具体的结构体定义。block内部的代码将会提取出来，成为一个单独的C函数，创建block时实际上会在实现方法中声明一个结构体（struct），并且初始化该结构体的成员变量。而在执行block时会去调用这个单独的C函数，并把该结构体的指针传递过去。 block定义的类型在libclosure的block.h（在data.c中也可以找得到）的源码中，我们可以找到block定义的类型： 123456void * _NSConcreteStackBlock[32] = &#123; 0 &#125;;void * _NSConcreteMallocBlock[32] = &#123; 0 &#125;;void * _NSConcreteAutoBlock[32] = &#123; 0 &#125;;void * _NSConcreteFinalizingBlock[32] = &#123; 0 &#125;;void * _NSConcreteGlobalBlock[32] = &#123; 0 &#125;;void * _NSConcreteWeakBlockVariable[32] = &#123; 0 &#125;; 在C语言中定义了6中block，然而在OC当中的block只有3种类型，即： NSConcreteStackBlock 定义为栈上创建的block NSConcreteMallocBlock 定义为堆上创建的block NSConcreteGlobalBlock 作为全局变量的block PS：在最新的源码中_NSConcreteStackBlock和_NSConcreteGlobalBlock已经被废弃，取而代之的是是_NSConcreteAutoBlock,可能是由于ARC自动管理block内存的原因。 全局的block前面已经提到过 在编译器完成编译之后，block会将其内部的代码全部提取出来，形成一个单独的C语言函数，在创建block时实际上它就是在方法声实现中声明一个结构体，并初始化该结构体的成员变量。而在执行block时，会去调用这个单独的C语言函数，并把该结构体的指针传递过去 于是全局的block就由此而生，其效果就相当于C语言中的匿名函数，因为全局的block是当一个block内部没有捕获任何外部变量时，就会使一个全局的block类型，此时，他就是一个函数，所以他也具备函数的一些特性，当调用block是后面会加上小括号：block()。 那么既然全局的block具有函数的特性，就不必在考虑其生命周期（函数是一执行完就被释放） 栈中的block这个block其实是在编译器发现block内部调用或者说引用了外部的一些变量之后才生成的block。 在block内部有引用外部变量是，当block内部的结构体第一次被创建时，它会存在与该函数的函数调用栈中，其捕获的变量是会赋值到结构体的成员变量中的，所以当block完成初始化之后是不能更改其内部变量的，所以就知道为什么需要改变block内部的变量需要用到 __block了。 当函数调用结束或者返回时，函数的调用栈就会被销毁，这时block的内存也会被销毁，所以如果后续仍然需要使用这个block的时候，就必须将block以Block_Copy()的方法拷贝到堆上。也就是直接在堆上面申请内存，将block复制过去，最后在捕获到的对象发送retain，增加block的引用计数，保证block在堆上不被释放掉。 举个例子： 12345678910#include &lt;stdio.h&gt;int main() &#123; int a = 100; void (^block2)(void) = ^&#123; printf(&quot;%d\n&quot;, a); &#125;; block2(); return 0;&#125; 让clang反编译重写之后： 1234567891011121314151617181920212223242526struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; int a; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _a, int flags=0) : a(_a) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; int a = __cself-&gt;a; // bound by copy printf(&quot;%d\n&quot;, a);&#125;static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size;&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;int main()&#123; int a = 100; void (*block2)(void) = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a); ((void (*)(__block_impl *))((__block_impl *)block2)-&gt;FuncPtr)((__block_impl *)block2); return 0;&#125; 堆中的block 在栈中的block提到过，当函数调用结束，函数的调用栈会被销毁，那么栈中的block也会被销毁，但是我们一般都需要在函数结束之后任然使用这个block，所以就需要把栈中的block拷贝到堆上，在copy的同时，栈上的block的类型就转换成了堆上的block。 所以，在MRC时代，block的属性关键字必须是copy。这样就能保证再给block的属性复制的时候，能把栈上的block复制到堆上。 ARC时代的block之循环引用在开启ARC后，block的内存会比较微妙。ARC会自动处理block的内存，不用手动copy/release。 但是，和非ARC的情况有所不同： 1234void (^aBlock)(void);aBlock = ^&#123; printf(&quot;ok&quot;); &#125;; block是对象，所以aBlock默认是有__strong修饰符的，即aBlock对该block有strong references。即aBlock在被赋值的那一刻，这个block会被copy。所以，ARC开启后，所能接触到的block基本都是在堆上的。。 当block被copy之后(如开启了ARC、或把block放入dispatch queue)，该block对它捕获的对象产生strong references (非ARC下是retain)，所以有时需要避免block copy后产生的循环引用。 如果用self引用了block，block又捕获了self，这样就会有循环引用。因此，需要用weak来声明self 123456- (void)configureBlock &#123; XYZBlockKeeper * __weak weakSelf = self; self.block = ^&#123; [weakSelf doSomething]; //捕获到的是弱引用 &#125;&#125; 如果捕获到的是当前对象的成员变量对象，同样也会造成对self的引用，同样也要避免。 123456- (void)configureBlock &#123; id tmpIvar = _ivar; //临时变量,避免了self引用 self.block = ^&#123; [tmpIvar msg]; &#125;&#125; 为了避免循环引用，可以这样理解block：block就是一个对象，它捕获到的值就是这个对象的@property (strong)。]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>底层原理</tag>
        <tag>Block</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS多线程编程之GCD(更新swift3.0用法)]]></title>
    <url>%2F2018%2F04%2F20%2FiOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E4%B9%8BGCD-%E6%9B%B4%E6%96%B0swift3-0%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[iOS多线程编程之GCD iOS多线程编程之GCD(更新swift3.0用法)如果不考虑到其他任何因素和技术，多线程其实是百害而无一利的，只能浪费时间，降低CPU的运行效率。 试想一下，一个任务由十个子任务组成。现在有两种方式去完成这个任务： 1、新建是个线程，把每个子任务放到对应的子线程中去执行。执行完一个线程就切换到另外一个线程； 2、把是个人物放在一个线程里，按顺序执行。 线程，是执行程序的最基本单元，他有自己的栈和自己的寄存器。说的具体一点，线程就是“一个CPU执行一条无分叉的命令列”。 对于第一种方法，在十条线程之间来回切换，就意味着有十组栈和寄存器的值需要不断地备份、替换。而对于第二种方法，只需要一组寄存器和栈的存在，显然效率更加高效。 并发和并行通过刚刚的分析，我们可以看到，多线程本身并不能带来效率上的提升。严格意义上来说多线程在处理并发任务时，并不能提高其运行效率，反而会降低程序的运行效率。 那么什么是并发呢？它和并行不一样 并发指的是一种现象，一种经常出现，无可避免的现象。它描述的是“多个任务同时发生，需要被处理”这一现象。它的侧重点在于“发生”。 比如或者站排队检票。 并行指的是一种技术，一个同时处理多个任务的技术。它描述了一种能够同时处理多个任务的能力，侧重点在于“运行”。 比如景点开放了多个检票窗口，同一时间内能服务多个游客。这种情况可以理解为并行。 并行的反义词就是串行，表示任务必须按顺序来，一个一个执行，前一个执行完了才能执行后一个。 然而我们经常挂载嘴边的“多线程”其实正是采用了并行技术，从而提高执行效率。因为有多个线程，所以CPU有多个内核可以同时工作。并同时处理不同线程内的指令。 然而并发是一种现象，面向这一对象，我们首先需要先创建多个线程，然而真正加快程序运行速度的，是并行技术。也就是让多个CPU内核同时工作，而多线程的技术，正是让多个CPU同时进行工作。 同步与异步同步方法就是我们平时调用的哪些方法。因为任何有编程经验的人都知道，比如在第一行调用foo()方法，那么程序运行到第二行的时候，foo()方法肯定是执行完了。 所谓的异步，就是允许在执行某一个任务时，函数立刻返回，但是真正要执行的任务稍后完成。 比如我们在点击保存按钮之后，要先把数据写到磁盘，然后更新UI。同步方法就是等到数据保存完再更新UI，而异步则是立刻从保存数据的方法返回并向后执行代码，同时真正用来保存数据的指令将在稍后执行。 GCD简介GCD是以block为单位，一个block中的代码可以为一个任务。下文中提到的任务，可以理解为执行某个block。 同时GCD有两个很重要的概念：列队和执行方式。 三种队列： 串行列队：先入先出，每次只只执行一个任务； 并发列队：依然是先入先出，但是可以多个任务并发执行； 主列队：在主线程中执行； 两种执行方式： 同步执行 异步执行 其关系如下 同步 异步 主列队 在主线程中执行 在当前主线程中执行 串行列队 在当前线程中执行 新建线程执行 并发列队 在当前线程中执行 新建线程执行 GCD死锁下面的代码会造成死锁： 1234567DispatchQueue.main.sync &#123; print(&quot;当前线程\(Thread.current)&quot;)&#125;其写法相当于OC中的：dispatch_sync(dispatch_get_main_queue()&#123; NSLog(@&quot;当前线程%@&quot;,NSThread.currentThread);&#125;) 为什么会造成死锁？首先这是swift3.0的写法，DispatchQueue.main表示已经在主队列中执行，而sync中的代码块也是在当前的主队列中执行，那么，如果sync代码块中的代码要执行，则需要等待DispatchQueue.main执行完成才能执行，而DispatchQueue.main的代码要执行，则需要sync中的代码块执行完成才能执行，那么这样主队列中的两个任务就处在相互等待的状态，都在等对方先执行，而造成了死锁的问题。 其实这种解决方案很简单，只带代码写成下面这样就不会造成死锁： 123DispatchQueue.main.async &#123; print(&quot;当前线程\(Thread.current)&quot;)&#125; async是一个异步执行方式，由于是在异步执行，那么就不会存在主队列相互等待的状态，这样就不会造成死锁的问题。 GCD中的group代码如下： 12345678910let group = DispatchGroup()DispatchQueue(label: &quot;label1&quot;).async(group:group) &#123; print(&quot;当前线程111\(Thread.current)&quot;)&#125;DispatchQueue(label: &quot;label2&quot;).async(group: group) &#123; print(&quot;当前线程222\(Thread.current)&quot;)&#125;group.notify(queue: DispatchQueue.main) &#123; print(&quot;当前线程333\(Thread.current)&quot;)&#125; 在一个gcd队列组中并发执行线程111和线程222，所有并发线程完成之后通过队列组中的notify方法，回调到主线程。 GCD中的barrierGCD中的barrier是用来控制GCD线程的先后顺序的方法，代码如下： 1234567891011121314151617181920let group = DispatchGroup()let queue = DispatchQueue.init(label: &quot;queue&quot;)queue.async(group:group) &#123; for i in 0..&lt;10 &#123; print(&quot;\(i)&quot;) &#125; print(&quot;当前线程111\(Thread.current)&quot;)&#125;queue.async(group: group, qos: .default, flags: .barrier) &#123; print(&quot;线程阻塞中。。。&quot;)&#125;queue.async(group: group) &#123; for i in 0..&lt;20 &#123; print(&quot;\(i)&quot;) &#125; print(&quot;当前线程222\(Thread.current)&quot;)&#125;group.notify(queue: DispatchQueue.main) &#123; print(&quot;当前线程333\(Thread.current)&quot;)&#125; GCD中的信号量（semaphore）如果你有计算机基础，那么下面这段话应该很简单就能理解 信号量就是一个资源计数器，对信号量有两个操作来达到互斥，分别是P和V操作。 一般情况是这样进行临界访问或互斥访问的： 设信号量值为1， 当一个进程1运行是，使用资源，进行P操作，即对信号量值减1，也就是资源数少了1个。这是信号量值为0。系统中规定当信号量值为0是，必须等待，知道信号量值不为零才能继续操作。 这时如果进程2想要运行，那么也必须进行P操作，但是此时信号量为0，所以无法减1，即不能P操作，也就阻塞。这样就到到了进程1排他访问。 当进程1运行结束后，释放资源，进行V操作。资源数重新加1，这是信号量的值变为1. 这时进程2发现资源数不为0，信号量能进行P操作了，立即执行P操作。信号量值又变为0.次数进程2咱有资源，排他访问资源。 这就是信号量来控制互斥的原理 简单点来说，信号量为0时，阻塞线程，大于0是不会阻塞线程，GCD则可以通过信号量的值来达到是否阻塞线程，从而达到线程同步。 简单来说，在GCD中，让线程同步可以用三种方法（就目前我所能想到的）： group barrier semaphore group和barrier前面我们已经讲解过了，下面我们来说一说semaphore的的用法，在GCD中的信号量有三个函数操作： DispatchSemaphore.init -&gt; OC代码（dispatch_semaphore_create）//创建一个semaphore信号量 dispatch_semaphore_signal //发送一个信号 dispatch_semaphore_wait //等待信号 代码如下： 12345678910111213141516let queue = DispatchQueue.init(label: &quot;queue&quot;)let semaphore = DispatchSemaphore.init(value: 2)//初始化的信号量为2for i in 0...2 &#123; print(i) _ = semaphore.wait() _ = semaphore.wait(timeout: DispatchTime.now() + 10.0)//当前信号量为0时，阻塞线程10秒，10秒过后信号量如果依然为0，将不再等待，继续执行下面的代码 queue.async &#123; for j in 0...3 &#123; print(&quot;有限资源\(j)&quot;) sleep(3)//阻塞线程3秒 print(&quot;-------------------&quot;) &#125; semaphore.signal() &#125;&#125;]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>GCD</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS底层之RunLoop]]></title>
    <url>%2F2018%2F04%2F20%2FiOS%E5%BA%95%E5%B1%82%E4%B9%8BRunLoop%2F</url>
    <content type="text"><![CDATA[runloop在iOS开发中是一个十分基础的概念，本文将从CFRunLoop入手，介绍runloop的概念和底层实现原理。然后介绍Apple是如何通过runloop在处理一些列的触摸事件和方法回调以及自动释放池等功能的。文中部分内容来自此博客。 RunLoop的概念一般来讲，一个线程一次只能执行一次任务，任务完成之后线程就会退出，但是如果一种这种机制，让一条线程既能处理事件又不退出，通常会设置一个无线的死循环，让这条线程在里面跑而不退出，一般的代码可以这样写： 1234567function loop() &#123; initialize(); do &#123; var message = get_next_message(); process_message(message); &#125; while (message != quit);&#125; 上面这种模型我们通常称之为event loop。这种事件的处理模型在很多开发中都有，比如安卓开发中也有类似的loop循环，Windows的程序的循环消息，iOS/OSX的runloop等等。 所以runloop实际上也是一个对象，这个对象处理了很多东西，触摸事件和方法回调，并提供一个入口函数来执行event loop逻辑，线程执行完毕之后会一直处于“接收消息 - 等待 - 处理”的循环之中，直到这个循环结束，函数返回。 在iOS/OSX中提供了两种这样的对象：NSRunLoop和CFRunLoopRef。其中NSRunLoop是基于CFRunLoopRef的第二层封装，更加面向对象，但是NSRunLoop的API的线程是不安全的。 而CFRunLoopRef是在CoreFoundation的框架内的，它提供了纯C语言的API，所以这些API的线程是安全的。CFRunLoopRef 的代码是开源的，你可以在这里http://opensource.apple.com/tarballs/CF/下载到整个CoreFoundation 的源码来查看。 RunLoop与线程的关系线程和RunLoop是一一对应的关系，每一条线程都有与之对应的RunLoop，主线程的RunLoop是在程序启动时就已经开启，而其他线程在被创建时并不会开启RunLoop，如果子线程不主动去开启RunLoop，那他将一直不会有。RunLoop的创建发生在第一次获取时，销毁时发生在线程结束时。只能在一条线程内部获取其RunLoop。 RunLoop对外的接口在CoreFoundation框架中，提供了RunLoop的5种类： CFRunLoopRef CFRunLoopModeRef CFRunLoopSourceRef CFRunLoopTimerRef CFRunLoopModeRef其中，CFRunLoopModeRef并没有对外暴露接口，只是通过CFRunLoopRef对其接口进行封装，其关系如下： 一个RunLoop的包含若干个Mode，每个Mode又包含若干个source/timer/observer，每次调用RunLoop的主函数时，只能指定其中一个Mode，而这个Mode又被称之为currentMode。如果需要切换Mode只能退出当前的loop再重新指定一个Mode进入。这样做的目的是为了分隔开不同的source/timer/observer，让其相互之间互不影响。 CFRunLoopSourceRefCFRunLoopSourceRef是事件产生的地方。source主要有2个版本：source0和source1， Source0 只包含了一个函数指针的回调，它并不能主动触发事件。使用时，你需要先调用CFRunLoopSourceSignal(source)，将这个Source标记为待处理，然后手动调用CFRunLoopWakeUp(runloop)来唤醒RunLoop，让其处理这个事件。 Source1 包含了 一个mach_port和一个函数的回调指针，被用于通过内核和其他线程相互发送消息。source1可以主动唤醒RunLoop的线程。 CFRunLoopTimerRefCFRunLoopTimerRef是基于时间的触时发器，它和NSTimer可以混用。其中包含了一个时间的长度和一个函数的指针回调。当加入RunLoop时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行此回调。 这里补充一个知识点，就是为什么NSTimer会不准的原因 首先我们知道，NSTimer是基于toll-free bridged的，严格来说NSTimer不是一个基于真实时间的机制，NSTimer被触发需要满足以下3个条件， 第一、NSTimer被添加到指定的RunLoop的Mode中； 第二、该Mode在RunLoop中正在运行； 第三、达到触发的时间，因为RunLoop需要管理大量的资源，为了提高NSTimer的效率，时间的间隔被限制为50-100毫秒比较合理，直到下一次RunLoop检测到NSTimer才会被触发 在苹果开发者文档中可以查看到，参考 即使NSTimer会基于时间发出通知，但是由于NSTimer不是一个基于真实时间的机制。和输入源一样，timer和指定Mode的RunLoop紧密相连。如果没有被当前的Mode的RunLoop监测到，timer就不会被触发，直到timer指定的Mode的RunLoop运行时才会被触发。类似的，当timer被触发的时间达到，而RunLoop却又恰好正在执行一个handler句柄，那么timer就不会被触发，而是等到下次的触发时间点通过RunLoop来唤醒timer执行回调操作。如果RunLoop不再运行，那么timer就永远不会被触发 CFRunLoopObserverRefCFRunLoopObserverRef是RunLoop的观察者，每一个Observer都包含一个回调的函数指针，当RunLoop的状态发生变化时，观察者j就能通过回调接收到这个变化，在CFRunLoopRef的源码中，可以发现观察RunLoop的还时间点主要有以下几种： 12345678typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入Loop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), // 即将退出Loop&#125;; 上面的Source/Timer/Observer被统称为Mode item，一个item可以同时加入多个Mode，但是一个item被重复加入同一个Mode将不会有效果。如果一个Mode中不包含其中任何一个item则RunLoop会直接退出，不再循环。 RunLoop的ModeCFRunLoopMode和CFRunLoop的结构大致如下： 12345678910111213141516struct __CFRunLoopMode &#123; CFStringRef _name; // Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot; CFMutableSetRef _sources0; // Set CFMutableSetRef _sources1; // Set CFMutableArrayRef _observers; // Array CFMutableArrayRef _timers; // Array ...&#125;;struct __CFRunLoop &#123; CFMutableSetRef _commonModes; // Set CFMutableSetRef _commonModeItems; // Set&lt;Source/Observer/Timer&gt; CFRunLoopModeRef _currentMode; // Current Runloop Mode CFMutableSetRef _modes; // Set ...&#125;; 此处有个概念叫“CommonModes”：一个Mode可以将自己标记为“Common”属性（通过将它的ModeName添加到RunLoop的commonModes中）。每个RunLoop的内容发生变化时，RunLoop都会自动将_commonModeItems里的Source/Observer/Timer同步到具有common标记的Mode里。 例如：主线程的RunLoop里面有两个预置的Mode，即kCFRunLoopDefaultMode和UITrackingRunLoopMode。这两个Mode都已经被标记为common属性。defaultMode是APP平时所处的状态，TrackingRunLoopMode是已经追到ScrollView的滑动时的状态。当你创建一个Timer，并且添加到DefaultMode时，timer会得到重复的回调，但当此时滑动一个tableview或者scrollview时，RunLoop会将Mode切换为trackingRunLoopMode，此时这个timer将不会再被回调，并且也不会影响到滑动的操作。 所以，有时候你需要一个timer，在这两种Mode之间回调，一种办法就是将这个timer分别加入到这两种Mode。另外一种方式就是将这个timer加入到顶层的RunLoop的commonModeitems中。这个commonModeItems将会被更新到所有具有common的标记的属性的Mode中。 CFRunLoop对外暴露的接口只有以下2个： 12CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);CFRunLoopRunInMode(CFStringRef modeName, ...); Mode 暴露的管理 mode item 的接口有下面几个： 123456CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode); 你只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop会自动帮你创建对应的 CFRunLoopModeRef。对于一个 RunLoop 来说，其内部的 mode 只能增加不能删除。 苹果公开提供的 Mode 有两个：kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 和 UITrackingRunLoopMode，你可以用这两个 Mode Name 来操作其对应的 Mode。 同时苹果还提供了一个操作 Common 标记的字符串：kCFRunLoopCommonModes (NSRunLoopCommonModes)，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common”。使用时注意区分这个字符串和其他 mode name。 RunLoop 的内部逻辑根据苹果在文档里的说明，RunLoop 内部的逻辑大致如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110/// 用DefaultMode启动void CFRunLoopRun(void) &#123; CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);&#125;/// 用指定的Mode启动，允许设置RunLoop超时时间int CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) &#123; return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);&#125;/// RunLoop的实现int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) &#123; /// 首先根据modeName找到对应mode CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false); /// 如果mode里没有source/timer/observer, 直接返回。 if (__CFRunLoopModeIsEmpty(currentMode)) return; /// 1. 通知 Observers: RunLoop 即将进入 loop。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry); /// 内部函数，进入loop __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123; Boolean sourceHandledThisLoop = NO; int retVal = 0; do &#123; /// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers); /// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources); /// 执行被加入的block __CFRunLoopDoBlocks(runloop, currentMode); /// 4. RunLoop 触发 Source0 (非port) 回调。 sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle); /// 执行被加入的block __CFRunLoopDoBlocks(runloop, currentMode); /// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。 if (__Source0DidDispatchPortLastTime) &#123; Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg) if (hasMsg) goto handle_msg; &#125; /// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。 if (!sourceHandledThisLoop) &#123; __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting); &#125; /// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。 /// • 一个基于 port 的Source 的事件。 /// • 一个 Timer 到时间了 /// • RunLoop 自身的超时时间到了 /// • 被其他什么调用者手动唤醒 __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123; mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg &#125; /// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting); /// 收到消息，处理消息。 handle_msg: /// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。 if (msg_is_timer) &#123; __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time()) &#125; /// 9.2 如果有dispatch到main_queue的block，执行block。 else if (msg_is_dispatch) &#123; __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg); &#125; /// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件 else &#123; CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort); sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg); if (sourceHandledThisLoop) &#123; mach_msg(reply, MACH_SEND_MSG, reply); &#125; &#125; /// 执行加入到Loop的block __CFRunLoopDoBlocks(runloop, currentMode); if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123; /// 进入loop时参数说处理完事件就返回。 retVal = kCFRunLoopRunHandledSource; &#125; else if (timeout) &#123; /// 超出传入参数标记的超时时间了 retVal = kCFRunLoopRunTimedOut; &#125; else if (__CFRunLoopIsStopped(runloop)) &#123; /// 被外部调用者强制停止了 retVal = kCFRunLoopRunStopped; &#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123; /// source/timer/observer一个都没有了 retVal = kCFRunLoopRunFinished; &#125; /// 如果没超时，mode里没空，loop也没被停止，那继续loop。 &#125; while (retVal == 0); &#125; /// 10. 通知 Observers: RunLoop 即将退出。 __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);&#125; 可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。 RunLoop 的底层实现从上面代码可以看到，RunLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 mach_msg()。为了解释这个逻辑，下面稍微介绍一下 OSX/iOS 的系统架构。 苹果官方将整个系统大致划分为上述4个层次：应用层包括用户能接触到的图形应用，例如 Spotlight、Aqua、SpringBoard 等。应用框架层即开发人员接触到的 Cocoa 等框架。核心框架层包括各种核心框架、OpenGL 等内容。Darwin 即操作系统的核心，包括系统内核、驱动、Shell 等内容，这一层是开源的，其所有源码都可以在opensource.apple.com里找到。 我们在深入看一下 Darwin 这个核心的架构： 其中，在硬件层上面的三个组成部分：Mach、BSD、IOKit (还包括一些上面没标注的内容)，共同组成了 XNU 内核。XNU 内核的内环被称作 Mach，其作为一个微内核，仅提供了诸如处理器调度、IPC (进程间通信)等非常少量的基础服务。BSD 层可以看作围绕 Mach 层的一个外环，其提供了诸如进程管理、文件系统和网络等功能。IOKit 层是为设备驱动提供了一个面向对象(C++)的一个框架。 Mach 本身提供的 API 非常有限，而且苹果也不鼓励使用 Mach 的 API，但是这些API非常基础，如果没有这些API的话，其他任何工作都无法实施。在 Mach 中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为”对象”。和其他架构不同， Mach 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。”消息”是 Mach 中最基础的概念，消息在两个端口 (port) 之间传递，这就是 Mach 的 IPC (进程间通信) 的核心。 Mach 的消息定义是在 &lt;mach/message.h&gt;头文件的，很简单： 12345678910111213typedef struct &#123; mach_msg_header_t header; mach_msg_body_t body;&#125; mach_msg_base_t;typedef struct &#123; mach_msg_bits_t msgh_bits; mach_msg_size_t msgh_size; mach_port_t msgh_remote_port; mach_port_t msgh_local_port; mach_port_name_t msgh_voucher_port; mach_msg_id_t msgh_id;&#125; mach_msg_header_t; 一条 Mach 消息实际上就是一个二进制数据包 (BLOB)，其头部定义了当前端口 local_port 和目标端口 remote_port，发送和接受消息是通过同一个 API 进行的，其 option 标记了消息传递的方向： 12345678mach_msg_return_t mach_msg( mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify); 为了实现消息的发送和接收，mach_msg() 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数mach_msg_trap()，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 mach_msg_trap() 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg() 函数会完成实际的工作， RunLoop 的核心就是一个 mach_msg() (见上面代码的第7步)，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 mach_msg_trap() 这个地方。 关于具体的如何利用 mach port 发送信息，可以看看NSHipster 这一篇文章，或者这里的中文翻译 。 关于Mach的历史可以看看这篇很有趣的文章：Mac OS X 背后的故事（三）Mach 之父 Avie Tevanian。 苹果用 RunLoop 实现的功能首先我们可以看一下 App 启动后 RunLoop 的状态： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899CFRunLoop &#123; current mode = kCFRunLoopDefaultMode common modes = &#123; UITrackingRunLoopMode kCFRunLoopDefaultMode &#125; common mode items = &#123; // source0 (manual) CFRunLoopSource &#123;order =-1, &#123; callout = _UIApplicationHandleEventQueue&#125;&#125; CFRunLoopSource &#123;order =-1, &#123; callout = PurpleEventSignalCallback &#125;&#125; CFRunLoopSource &#123;order = 0, &#123; callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125; // source1 (mach port) CFRunLoopSource &#123;order = 0, &#123;port = 17923&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 12039&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 16647&#125;&#125; CFRunLoopSource &#123;order =-1, &#123; callout = PurpleEventCallback&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 2407, callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 1c03, callout = __IOHIDEventSystemClientAvailabilityCallback&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 1b03, callout = __IOHIDEventSystemClientQueueCallback&#125;&#125; CFRunLoopSource &#123;order = 1, &#123;port = 1903, callout = __IOMIGMachPortPortCallback&#125;&#125; // Ovserver CFRunLoopObserver &#123;order = -2147483647, activities = 0x1, // Entry callout = _wrapRunLoopWithAutoreleasePoolHandler&#125; CFRunLoopObserver &#123;order = 0, activities = 0x20, // BeforeWaiting callout = _UIGestureRecognizerUpdateObserver&#125; CFRunLoopObserver &#123;order = 1999000, activities = 0xa0, // BeforeWaiting | Exit callout = _afterCACommitHandler&#125; CFRunLoopObserver &#123;order = 2000000, activities = 0xa0, // BeforeWaiting | Exit callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125; CFRunLoopObserver &#123;order = 2147483647, activities = 0xa0, // BeforeWaiting | Exit callout = _wrapRunLoopWithAutoreleasePoolHandler&#125; // Timer CFRunLoopTimer &#123;firing = No, interval = 3.1536e+09, tolerance = 0, next fire date = 453098071 (-4421.76019 @ 96223387169499), callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125; &#125;, modes ＝ &#123; CFRunLoopMode &#123; sources0 = &#123; /* same as &apos;common mode items&apos; */ &#125;, sources1 = &#123; /* same as &apos;common mode items&apos; */ &#125;, observers = &#123; /* same as &apos;common mode items&apos; */ &#125;, timers = &#123; /* same as &apos;common mode items&apos; */ &#125;, &#125;, CFRunLoopMode &#123; sources0 = &#123; /* same as &apos;common mode items&apos; */ &#125;, sources1 = &#123; /* same as &apos;common mode items&apos; */ &#125;, observers = &#123; /* same as &apos;common mode items&apos; */ &#125;, timers = &#123; /* same as &apos;common mode items&apos; */ &#125;, &#125;, CFRunLoopMode &#123; sources0 = &#123; CFRunLoopSource &#123;order = 0, &#123; callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125; &#125;, sources1 = (null), observers = &#123; CFRunLoopObserver &gt;&#123;activities = 0xa0, order = 2000000, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125; )&#125;, timers = (null), &#125;, CFRunLoopMode &#123; sources0 = &#123; CFRunLoopSource &#123;order = -1, &#123; callout = PurpleEventSignalCallback&#125;&#125; &#125;, sources1 = &#123; CFRunLoopSource &#123;order = -1, &#123; callout = PurpleEventCallback&#125;&#125; &#125;, observers = (null), timers = (null), &#125;, CFRunLoopMode &#123; sources0 = (null), sources1 = (null), observers = (null), timers = (null), &#125; &#125;&#125; 可以看到，系统默认注册了5个Mode: kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。 UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。 UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。 4: GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。 5: kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。 你可以在这里看到更多的苹果内部的 Mode，但那些 Mode 在开发中就很难遇到了。 当 RunLoop 进行回调时，一般都是通过一个很长的函数调用出去 (call out), 当你在你的代码中下断点调试时，通常能在调用栈上看到这些函数。下面是这几个函数的整理版本，如果你在调用栈中看到这些长函数名，在这里查找一下就能定位到具体的调用地点了： 12345678910111213141516171819202122232425262728293031323334353637383940414243&#123; /// 1. 通知Observers，即将进入RunLoop /// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush(); __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry); do &#123; /// 2. 通知 Observers: 即将触发 Timer 回调。 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers); /// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources); __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block); /// 4. 触发 Source0 (非基于port的) 回调。 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0); __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block); /// 6. 通知Observers，即将进入休眠 /// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush(); __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting); /// 7. sleep to wait msg. mach_msg() -&gt; mach_msg_trap(); /// 8. 通知Observers，线程被唤醒 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting); /// 9. 如果是被Timer唤醒的，回调Timer __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer); /// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block); /// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1); &#125; while (...); /// 10. 通知Observers，即将退出RunLoop /// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop(); __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);&#125; AutoreleasePoolApp启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。 第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。 第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。 在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。 事件响应苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。 当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。 _UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。 手势识别当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。 苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。 当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。 界面更新当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。 苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。 这个函数内部的调用栈大概是这样的： 1234567891011_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv() QuartzCore:CA::Transaction::observer_callback: CA::Transaction::commit(); CA::Context::commit_transaction(); CA::Layer::layout_and_display_if_needed(); CA::Layer::layout_if_needed(); [CALayer layoutSublayers]; [UIView layoutSubviews]; CA::Layer::display_if_needed(); [CALayer display]; [UIView drawRect]; 定时器NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。 如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。 CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。 PerformSelecter当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。 当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。 GCD实际上 RunLoop 底层也会用到 GCD 的东西，比如 RunLoop 是用 dispatch_source_t 实现的 Timer（评论中有人提醒，NSTimer 是用了 XNU 内核的 mk_timer，我也仔细调试了一下，发现 NSTimer 确实是由 mk_timer 驱动，而非 GCD 驱动的）。但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。 当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。 网络请求iOS 中，关于网络请求的接口自下至上有如下几层: 1234CFSocketCFNetwork -&gt;ASIHttpRequestNSURLConnection -&gt;AFNetworkingNSURLSession -&gt;AFNetworking2, Alamofire CFSocket 是最底层的接口，只负责 socket 通信。 CFNetwork 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作于这一层。 NSURLConnection 是基于 CFNetwork 的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层。 NSURLSession 是 iOS7 中新增的接口，表面上是和 NSURLConnection 并列的，但底层仍然用到了 NSURLConnection 的部分功能 (比如 com.apple.NSURLConnectionLoader 线程)，AFNetworking2 和 Alamofire 工作于这一层。 下面主要介绍下 NSURLConnection 的工作过程。 通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。 当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。 NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>RunLoop</tag>
        <tag>底层原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AutoreleasePool源码分析]]></title>
    <url>%2F2018%2F03%2F15%2FAutoreleasePool%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[AutoreleasePool（自动释放池）是OC中的一种内存自动回收机制，它可以延迟加入AutoreleasePool中的变量release的时机。在正常情况下，创建的变量会在超出其作用域的时候release，但是如果将变量加入AutoreleasePool，那么release将延迟执行。 需要了解AutoreleasePool的工作原理，我们需要知道它的底层到底做了什么事情，那我们就先从汇编代码入手，新建一个命令行工程，创建一个新的对象继承自NSObject： 123456789#import &lt;Foundation/Foundation.h&gt;#import &quot;object.h&quot;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; object *oc = [[object alloc] init]]; &#125; return 0;&#125; 我们利用命令将OC代码重写为c++代码： 1xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m 我们可以大约得到3万2千行的c++代码的cpp文件，但是不要紧，因为最终的核心代码在该cpp的最底部： 1234567int main(int argc, const char * argv[]) &#123; /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; object *o1 = ((object *(*)(id, SEL))(void *)objc_msgSend)((id)((object *(*)(id, SEL))(void *)objc_msgSend)((id)((object *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;object&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;)), sel_registerName(&quot;autorelease&quot;)); &#125; return 0;&#125; 中间的代码层是object对象的创建过程，发送objc_msgSend消息创建对象。那其实最核心的代码就在下面这这两句上了 AtAutoreleasePool autoreleasepool; __AtAutoreleasePool我们在cpp文件中搜索AtAutoreleasePool会找到如下代码,AtAutoreleasePool具体定义如下： 123456789101112extern &quot;C&quot; __declspec(dllimport) void * objc_autoreleasePoolPush(void);extern &quot;C&quot; __declspec(dllimport) void objc_autoreleasePoolPop(void *);struct __AtAutoreleasePool &#123; __AtAutoreleasePool() &#123; // 构造函数，在创建结构体的时候调用 atautoreleasepoolobj = objc_autoreleasePoolPush(); &#125; ~__AtAutoreleasePool() &#123; // 析构函数，在结构体销毁的时候调用 objc_autoreleasePoolPop(atautoreleasepoolobj); &#125; void * atautoreleasepoolobj;&#125;; 上面两个调用，分别是构造函数和析构函数，根据构造函数和析构函数的特点：自动局部变量的构造函数是在程序执行到声明这个对象的位置时调用的，而对应的析构函数是在程序执行到离开这个对象的作用域时调用。苹果实际上是通过声明一个AtAutoreleasePool类型的局部变量autoreleasepool实现了@autoreleasepool{},那么实际上单个自动释放池的执行过程就是： 1objc_autoreleasePoolPush() —&gt; [object autorelease] —&gt; objc_autoreleasePoolPop(void *) 想了解objc_autoreleasePoolPush和objc_autoreleasePoolPop具体都做了些什么，其实很简单，我们只要到runtime-&gt;NSObject.mm的源码中就能窥探它的真是面目了，这里我们分析的runtime源码是objc-750的版本。在源码中我们可以发现这样一段代码： 1234567void *objc_autoreleasePoolPush(void) &#123; return AutoreleasePoolPage::push();&#125;void objc_autoreleasePoolPop(void *ctxt) &#123; AutoreleasePoolPage::pop(ctxt);&#125; objc_autoreleasePoolPush和objc_autoreleasePoolPop分别是由AutoreleasePoolPage调用了push方法入栈和pop方法出栈，其本质实际上是AutoreleasePoolPage对应的静态方法push和pop的封装。那么问题就显而易见了，如果要知道这个push和pop方法到底做了什么，我们还得从源码里获取到AutoreleasePoolPage相关的内容以及其实现原理。 AutoreleasePoolPage定义在runtime源码中对AutoreleasePoolPage的定义是这样的： 1234567891011121314151617181920212223242526class AutoreleasePoolPage &#123; // EMPTY_POOL_PLACEHOLDER is stored in TLS when exactly one pool is // pushed and it has never contained any objects. This saves memory // when the top level (i.e. libdispatch) pushes and pops pools but // never uses them.# define EMPTY_POOL_PLACEHOLDER ((id*)1)# define POOL_BOUNDARY nil static pthread_key_t const key = AUTORELEASE_POOL_KEY; static uint8_t const SCRIBBLE = 0xA3; // 0xA3A3A3A3 after releasing static size_t const SIZE = #if PROTECT_AUTORELEASEPOOL PAGE_MAX_SIZE; // must be multiple of vm page size#else PAGE_MAX_SIZE; // size and alignment, power of 2#endif static size_t const COUNT = SIZE / sizeof(id); magic_t const magic; id *next; pthread_t const thread; AutoreleasePoolPage * const parent; AutoreleasePoolPage *child; uint32_t const depth; uint32_t hiwat;&#125; 去除那些静态成员变量,AutoreleasePoolPage的成员变量的解释如下： 123456789class AutoreleasePoolPage &#123; magic_t const magic; //检查校验完整性的变量 id *next; //指向新添加到AutoreleasePoolPage的对象 pthread_t const thread; //AutoreleasePoolPage当前所在的线程，AutoreleasePool是按线程一一对应的（结构中的thread指针指向当前线程） AutoreleasePoolPage * const parent; //指向上一个AutoreleasePoolPage AutoreleasePoolPage *child; //指向下一个AutoreleasePoolPage uint32_t const depth; //depth 链表的深度，节点个数 uint32_t hiwat; //数据容纳的一个上限&#125; 这里需要注意的是AutoreleasePoolPage有一个成员变量是PAGE_MAX_SIZE，这个表示一个AutoreleasePoolPage最大内存大小，这个宏其实在上面可以找得到，也就是说一个AutoreleasePoolPage的最大内存大小是PAGE_MAX_SIZE（也就是4096）： 1234567891011121314#define I386_PGBYTES 4096 /* bytes per 80386 page */#define I386_PGSHIFT 12 /* bitshift for pages */#define PAGE_SIZE I386_PGBYTES#define PAGE_SHIFT I386_PGSHIFT#define PAGE_MASK (PAGE_SIZE - 1)#define PAGE_MAX_SHIFT PAGE_SHIFT#define PAGE_MAX_SIZE PAGE_SIZE#define PAGE_MAX_MASK PAGE_MASK#define PAGE_MIN_SHIFT PAGE_SHIFT#define PAGE_MIN_SIZE PAGE_SIZE#define PAGE_MIN_MASK PAGE_MASK AutoreleasePoolPage工作原理每个AutoreleasePoolPage对象的内存大小事4096字节，除去AutoreleasePoolPage的成员变量所占用的空间，剩下的空间用来存放Autorelease对象的地址，知道了AutoreleasePoolPage的定义，现在我们回到objc_autoreleasePoolPush这个方法，我们发现了，实际上这个方法是调用了AutoreleasePoolPage的push方法： 1234567891011static inline void *push() &#123; id *dest; if (DebugPoolAllocation) &#123; // Each autorelease pool starts on a new pool page. dest = autoreleaseNewPage(POOL_BOUNDARY); &#125; else &#123; dest = autoreleaseFast(POOL_BOUNDARY); &#125; assert(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY); return dest;&#125; 细心的你肯定会发现，在调用push方法的时候autoreleaseFast会将一个POOL_BOUNDARY的对象放在临界点上。POOL_BOUNDARY这个对象属于比较关键的对象，关系到AutoreleasePoolPage的释放过程。 12345678910static inline id *autoreleaseFast(id obj) &#123; AutoreleasePoolPage *page = hotPage(); if (page &amp;&amp; !page-&gt;full()) &#123; return page-&gt;add(obj); &#125; else if (page) &#123; return autoreleaseFullPage(obj, page); &#125; else &#123; return autoreleaseNoPage(obj); &#125;&#125; 上述方法分三种情况选择不同的代码执行： 1、有 hotPage 并且当前 page 不满，调用 page-&gt;add(obj) 方法将对象添加至 AutoreleasePoolPage 的栈中2、有 hotPage 并且当前 page 已满，调用 autoreleaseFullPage 初始化一个新的页，调用 page-&gt;add(obj) 方法将对象添加至 AutoreleasePoolPage 的栈中3、无 hotPage，调用 autoreleaseNoPage 创建一个 hotPage，调用 page-&gt;add(obj) 方法将对象添加至 AutoreleasePoolPage 的栈中 最后的都会调用 page-&gt;add(obj) 将对象添加到自动释放池中。而hotPage 可以理解为当前正在使用的 AutoreleasePoolPage。 接下来我们看一看objc_autoreleasePoolPop方法调用pop的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657static inline void pop(void *token) &#123; AutoreleasePoolPage *page; id *stop; if (token == (void*)EMPTY_POOL_PLACEHOLDER) &#123; // Popping the top-level placeholder pool. if (hotPage()) &#123; // Pool was used. Pop its contents normally. // Pool pages remain allocated for re-use as usual. pop(coldPage()-&gt;begin()); &#125; else &#123; // Pool was never used. Clear the placeholder. setHotPage(nil); &#125; return; &#125; page = pageForPointer(token); stop = (id *)token; if (*stop != POOL_BOUNDARY) &#123; if (stop == page-&gt;begin() &amp;&amp; !page-&gt;parent) &#123; // Start of coldest page may correctly not be POOL_BOUNDARY: // 1. top-level pool is popped, leaving the cold page in place // 2. an object is autoreleased with no pool &#125; else &#123; // Error. For bincompat purposes this is not // fatal in executables built with old SDKs. return badPop(token); &#125; &#125; if (PrintPoolHiwat) printHiwat(); page-&gt;releaseUntil(stop); // memory: delete empty children if (DebugPoolAllocation &amp;&amp; page-&gt;empty()) &#123; // special case: delete everything during page-per-pool debugging AutoreleasePoolPage *parent = page-&gt;parent; page-&gt;kill(); setHotPage(parent); &#125; else if (DebugMissingPools &amp;&amp; page-&gt;empty() &amp;&amp; !page-&gt;parent) &#123; // special case: delete everything for pop(top) // when debugging missing autorelease pools page-&gt;kill(); setHotPage(nil); &#125; else if (page-&gt;child) &#123; // hysteresis: keep one empty child if page is more than half full if (page-&gt;lessThanHalfFull()) &#123; page-&gt;child-&gt;kill(); &#125; else if (page-&gt;child-&gt;child) &#123; page-&gt;child-&gt;child-&gt;kill(); &#125; &#125;&#125; 顺着源码一步一步找就会发现，autorelease函数和push函数一样，关键代码都是调用autoreleaseFast函数向自动释放池的链表栈中添加一个对象，不过push函数的入栈的是一个边界对象，而autorelease函数入栈的是需要加入autoreleasepool的对象。自动释放池释放是传入 push 返回的边界对象（POOL_BOUNDARY）,autoreleasepool在调用autorelease时逐渐kill存在在autoreleasepool中的对象的地址，直到找到POOL_BOUNDARY对象所在的地址才会停止。 那么这就衍生了一个问题，如果AutoreleasePoolPage在添加需要释放的对象的地址超过了4096的空间或者是说有多个AutoreleasePoolPage的时候它是如何存入需要释放对象的地址，又是如何一层一层的释放的呢？ AutoreleasePoolPage双向链表其实AutoreleasePoolPage并没有单独的结构，而是由若干个AutoreleasePoolPage以双向链表的形式组合而成的栈结构在AutoreleasePoolPage的成员变量内部，我们可以清晰的看到有两个成员变量： 12AutoreleasePoolPage * const parent; //指向上一个AutoreleasePoolPageAutoreleasePoolPage *child; //指向下一个AutoreleasePoolPage parent指针和child指针，parent指向的上一个AutoreleasePoolPage的内存空间地址而child则指向下一个AutoreleasePoolPage的内存地址，当一个AutoreleasePoolPage的空间被占满时，会新建一个AutoreleasePoolPage对象，连接链表，后来的autorelease对象在新的page加入。这样无论在添加autorelease对象地址和释放autorelease对象地址的时候都能很准确的找到对应的AutoreleasePoolPage的地址 具体查看AutoreleasePoolPage的工作原理，可以用_objc_autoreleasePoolPrint这个私有函数来查看 Runloop和AutoreleasePool的关系我们新建一个空的工程，在viewDidLoad打印[NSRunLoop mainRunLoop]的详细信息，我们会在observers发现两个关于AutoreleasePool的Handler操作_wrapRunLoopWithAutoreleasePoolHandler： 12345678observers = ( &quot;&lt;CFRunLoopObserver 0x600001f68140 [0x1053f6b68]&gt;&#123;valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x107fe51b1), context = &lt;CFArray 0x600002020330 [0x1053f6b68]&gt;&#123;type = mutable-small, count = 1, values = (\n\t0 : &lt;0x7ff476808058&gt;\n)&#125;&#125;&quot;, &quot;&lt;CFRunLoopObserver 0x600001f6c1e0 [0x1053f6b68]&gt;&#123;valid = Yes, activities = 0x20, repeats = Yes, order = 0, callout = _UIGestureRecognizerUpdateObserver (0x107bb7473), context = &lt;CFRunLoopObserver context 0x60000056dea0&gt;&#125;&quot;, &quot;&lt;CFRunLoopObserver 0x600001f68c80 [0x1053f6b68]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 1999000, callout = _beforeCACommitHandler (0x108014dfc), context = &lt;CFRunLoopObserver context 0x7ff475d024b0&gt;&#125;&quot;, &quot;&lt;CFRunLoopObserver 0x600001f68960 [0x1053f6b68]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2000000, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv (0x109a136ae), context = &lt;CFRunLoopObserver context 0x0&gt;&#125;&quot;, &quot;&lt;CFRunLoopObserver 0x600001f68be0 [0x1053f6b68]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2001000, callout = _afterCACommitHandler (0x108014e75), context = &lt;CFRunLoopObserver context 0x7ff475d024b0&gt;&#125;&quot;, &quot;&lt;CFRunLoopObserver 0x600001f68b40 [0x1053f6b68]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x107fe51b1), context = &lt;CFArray 0x600002020330 [0x1053f6b68]&gt;&#123;type = mutable-small, count = 1, values = (\n\t0 : &lt;0x7ff476808058&gt;\n)&#125;&#125;&quot;) 我们查看它的activities，分别是在0x1和0xa0，那这两个分别有代表是什么呢？在runloop 的源码里我们可以找到runloop的相关枚举： 123456789typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), // 1 kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 2 kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 4 kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 32 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 64 kCFRunLoopExit = (1UL &lt;&lt; 7), // 128 kCFRunLoopAllActivities = 0x0FFFFFFFU &#125;; 根据位运算可以的出上述结果：0x1 = 1 等价于kCFRunLoopEntry，0xa0 = 64 + 128 等价于 kCFRunLoopBeforeWaiting | kCFRunLoopExit，意味着runloop会在kCFRunLoopEntry时进行一次push操作，在kCFRunLoopBeforeWaiting进行一次pop操作，然后在进行一次push操作，最后会在kCFRunLoopExit时进行一次pop操作。 也就是说runloop会在即将进行休眠和退出runloop是将AutoreleasePool进行释放。]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>Autorelease</tag>
        <tag>RunLoop</tag>
        <tag>底层原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Notification与多线程]]></title>
    <url>%2F2017%2F04%2F11%2FNotification%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前几天与同事讨论到Notification在多线程下的转发问题，所以就此整理一下。 Notification与多线程先来看看官方的文档，是这样写的： In a multithreaded application, notifications are always delivered in the thread in which the notification was posted, which may not be the same thread in which an observer registered itself. 翻译过来是： 在多线程应用中，Notification在哪个线程中post，就在哪个线程中被转发，而不一定是在注册观察者的那个线程中。 也就是说，Notification的发送与接收处理都是在同一个线程中。为了说明这一点，我们先来看一个示例： Notification的发送与处理12345678910111213141516171819202122@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; NSLog(@&quot;current thread = %@&quot;, [NSThread currentThread]); [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:TEST_NOTIFICATION object:nil]; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:TEST_NOTIFICATION object:nil userInfo:nil]; &#125;);&#125;- (void)handleNotification:(NSNotification *)notification&#123; NSLog(@&quot;current thread = %@&quot;, [NSThread currentThread]); NSLog(@&quot;test notification&quot;);&#125;@end 其输出结果如下： 1232015-03-11 22:05:12.856 test[865:45102] current thread = &lt;NSThread: 0x7fbb23412f30&gt;&#123;number = 1, name = main&#125;2015-03-11 22:05:12.857 test[865:45174] current thread = &lt;NSThread: 0x7fbb23552370&gt;&#123;number = 2, name = (null)&#125;2015-03-11 22:05:12.857 test[865:45174] test notification 可以看到，虽然我们在主线程中注册了通知的观察者，但在全局队列中post的Notification，并不是在主线程处理的。所以，这时候就需要注意，如果我们想在回调中处理与UI相关的操作，需要确保是在主线程中执行回调。 这时，就有一个问题了，如果我们的Notification是在二级线程中post的，如何能在主线程中对这个Notification进行处理呢？或者换个提法，如果我们希望一个Notification的post线程与转发线程不是同一个线程，应该怎么办呢？我们看看官方文档是怎么说的： For example, if an object running in a background thread is listening for notifications from the user interface, such as a window closing, you would like to receive the notifications in the background thread instead of the main thread. In these cases, you must capture the notifications as they are delivered on the default thread and redirect them to the appropriate thread. 这里讲到了“重定向”，就是我们在Notification所在的默认线程中捕获这些分发的通知，然后将其重定向到指定的线程中。 一种重定向的实现思路是自定义一个通知队列(注意，不是NSNotificationQueue对象，而是一个数组)，让这个队列去维护那些我们需要重定向的Notification。我们仍然是像平常一样去注册一个通知的观察者，当Notification来了时，先看看post这个Notification的线程是不是我们所期望的线程，如果不是，则将这个Notification存储到我们的队列中，并发送一个信号(signal)到期望的线程中，来告诉这个线程需要处理一个Notification。指定的线程在收到信号后，将Notification从队列中移除，并进行处理。 官方文档已经给出了示例代码，在此借用一下，以测试实际结果： 在不同线程中post和转发一个Notification123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#import &quot;ViewController.h&quot;@interface ViewController ()&lt;NSMachPortDelegate&gt;@property (nonatomic ,strong) NSMachPort *machPort;@property (nonatomic ,strong) NSThread *thread;@property (nonatomic ,strong) NSLock *lock;@property (nonatomic ,strong) NSMutableArray *notifiQueue;//通知队列@end@implementation ViewControllerstatic void Callback(CFNotificationCenterRef center, void *observer, CFStringRef name, const void *object, CFDictionaryRef userInfo)&#123; NSLog(@&quot;CFNotificationCenterRef====%@====%@&quot;,[NSThread currentThread],name);&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; self.notifiQueue = @[].mutableCopy; self.thread = [NSThread currentThread]; self.lock = [[NSLock alloc] init]; self.machPort = [[NSMachPort alloc] init]; self.machPort.delegate = self; // 往当前线程的run loop添加端口源 // 当Mach消息到达而接收线程的runloop没有运行时，则内核会保存这条消息，直到下一次进入runloop [[NSRunLoop currentRunLoop] addPort:self.machPort forMode:(__bridge NSString *)kCFRunLoopCommonModes]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(processNotification:) name:@&quot;TestNotification&quot; object:nil]; //CFNotificationCenterRef:通过CFNotificationCenterRef发送出来的通知无论是在子线程还是主线程最终都会h转发到主线程中 CFNotificationCenterRef center = CFNotificationCenterGetDarwinNotifyCenter(); CFNotificationSuspensionBehavior behavior = CFNotificationSuspensionBehaviorDeliverImmediately; CFNotificationCenterAddObserver(center, NULL, Callback, CFSTR(&quot;notification.identifier&quot;), NULL, behavior); //NSNotificationCenter:子线程发出的通知依旧在子线程 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(doSome:) name:@&quot;notification.identifier&quot; object:nil];&#125;- (void)doSome:(NSNotification *)notifi &#123; NSLog(@&quot;NSNotificationCenter====%@====%@&quot;,[NSThread currentThread],notifi.name);&#125;- (void)processNotification:(NSNotification *)notifi &#123; if ([NSThread currentThread] != self.thread) &#123; NSLog(@&quot;NSMachPort if====%@====%@&quot;,[NSThread currentThread],notifi.name); [self.lock lock]; [self.notifiQueue addObject:notifi]; [self.lock unlock]; //通过MachPort转发子线程通知到主线程 [self.machPort sendBeforeDate:[NSDate date] components:nil from:nil reserved:0]; &#125; else &#123; NSLog(@&quot;NSMachPort else====%@====%@&quot;, [NSThread currentThread],notifi.name); &#125;&#125;// MARK: - NSMachPortDelegate- (void)handleMachMessage:(void *)msg &#123; [self.lock lock]; NSLog(@&quot;self.notifiQueue ==== %@&quot;,self.notifiQueue); while ([self.notifiQueue count]) &#123; NSNotification *notification = [self.notifiQueue objectAtIndex:0]; [self.notifiQueue removeObjectAtIndex:0]; [self.lock unlock]; [self processNotification:notification]; [self.lock lock]; &#125;; [self.lock unlock];&#125;@end// 其它地方dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; void *Object; CFDictionaryRef userInfo; CFNotificationCenterRef center = CFNotificationCenterGetDarwinNotifyCenter(); CFNotificationCenterPostNotification(center, CFSTR(&quot;notification.identifier&quot;), Object, userInfo, true); NSLog(@&quot;CFNotificationCenterRef====%@====%p&quot;,[NSThread currentThread],Object); [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;notification.identifier&quot; object:nil]; [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;TestNotification&quot; object:nil]; NSLog(@&quot;NSNotificationCenter====%@&quot;,[NSThread currentThread]); &#125;); 上面的代码就是我们通常所做的事情：添加一个通知监听者，定义一个回调，并在所属对象释放时移除监听者；然后在程序的某个地方post一个通知。简单明了，如果这一切都是发生在一个线程里面，或者至少dealloc方法是在-postNotificationName:的线程中运行的(注意：NSNotification的post和转发是同步的)，那么都OK，没有线程安全问题。但如果dealloc方法和-postNotificationName:方法不在同一个线程中运行时，会出现什么问题呢？ 我们再改造一下上面的代码： NSNotificationCenter引发的线程安全问题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#pragma mark - Poster @interface Poster : NSObject @end @implementation Poster - (instancetype)init&#123; self = [super init]; if (self) &#123; [self performSelectorInBackground:@selector(postNotification) withObject:nil]; &#125; return self;&#125; - (void)postNotification&#123; [[NSNotificationCenter defaultCenter] postNotificationName:TEST_NOTIFICATION object:nil];&#125; @end #pragma mark - Observer @interface Observer : NSObject&#123; Poster *_poster;&#125; @property (nonatomic, assign) NSInteger i; @end @implementation Observer - (instancetype)init&#123; self = [super init]; if (self) &#123; _poster = [[Poster alloc] init]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:TEST_NOTIFICATION object:nil]; &#125; return self;&#125; - (void)handleNotification:(NSNotification *)notification&#123; NSLog(@&quot;handle notification begin&quot;); sleep(1); NSLog(@&quot;handle notification end&quot;); self.i = 10;&#125; - (void)dealloc&#123; [[NSNotificationCenter defaultCenter] removeObserver:self]; NSLog(@&quot;Observer dealloc&quot;);&#125; @end #pragma mark - ViewController @implementation ViewController - (void)viewDidLoad &#123; [super viewDidLoad]; __autoreleasing Observer *observer = [[Observer alloc] init];&#125; @end 这段代码是在主线程添加了一个TEST_NOTIFICATION通知的监听者，并在主线程中将其移除，而我们的NSNotification是在后台线程中post的。在通知处理函数中，我们让回调所在的线程睡眠1秒钟，然后再去设置属性i值。这时会发生什么呢？我们先来看看输出结果： 1234562015-03-14 00:31:41.286 SKTest[932:88791] handle notification begin2015-03-14 00:31:41.291 SKTest[932:88713] Observer dealloc2015-03-14 00:31:42.361 SKTest[932:88791] handle notification end(lldb) // 程序在self.i = 10处抛出了&quot;Thread 6: EXC_BAD_ACCESS(code=EXC_I386_GPFLT)&quot; 经典的内存错误，程序崩溃了。其实从输出结果中，我们就可以看到到底是发生了什么事。我们简要描述一下： 当我们注册一个观察者是，通知中心会持有观察者的一个弱引用，来确保观察者是可用的。 主线程调用dealloc操作会让Observer对象的引用计数减为0，这时对象会被释放掉。 后台线程发送一个通知，如果此时Observer还未被释放，则会向其转发消息，并执行回调方法。而如果在回调执行的过程中对象被释放了，就会出现上面的问题。 当然，上面这个例子是故意而为之，但不排除在实际编码中会遇到类似的问题。虽然NSNotificationCenter是线程安全的，但并不意味着我们在使用时就可以保证线程安全的，如果稍不注意，还是会出现线程问题。 那我们该怎么做呢？这里有一些好的建议： 尽量在一个线程中处理通知相关的操作，大部分情况下，这样做都能确保通知的正常工作。不过，我们无法确定到底会在哪个线程中调用dealloc方法，所以这一点还是比较困难。 注册监听都时，使用基于block的API。这样我们在block还要继续调用self的属性或方法，就可以通过weak-strong的方式来处理。具体大家可以改造下上面的代码试试是什么效果。 使用带有安全生命周期的对象，这一点对象单例对象来说再合适不过了，在应用的整个生命周期都不会被释放。 使用代理。 小结NSNotificationCenter虽然是线程安全的，但不要被这个事实所误导。在涉及到多线程时，我们还是需要多加小心，避免出现上面的线程问题。想进一步了解的话，可以查看Observers and Thread Safety。]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>通知</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS多线程编程之线程锁]]></title>
    <url>%2F2017%2F02%2F24%2FiOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E9%94%81%2F</url>
    <content type="text"><![CDATA[何所谓线程安全线程安全就是在多线程访问的同时，采用用了加锁机制，当一个线程访问该线程外的某个数据时，进行保护，其他线程不能进行访问，直到该线程读取完毕，其他线程才可以访问。保护线程安全无在乎就是对线程进行加锁。 在iOS开发中常用的加锁方式有以下几种： NSLock在iOS程序中NSLock中实现了一个简单的互斥锁，实现了NSLocking协议， lock为加锁， unlock为解锁， tryLock为尝试加锁，如果加锁失败则不会阻塞线程，只会立即回调，需要注意的是，使用tryLock并不能加锁成功 ，如果获取锁失败，则不会执行加锁。 NOLockBforeDate:在指定的date之前暂时阻塞线程（如果没有获取锁），如果在指定的时间仍然没有获取到🔐的话。线程会被立即唤醒，函数立即返回NO。 12345678910111213141516171819202122232425- (void)viewDidLoad &#123; [super viewDidLoad]; __weak typeof(self) weakSelf = self; dispatch_group_t group = dispatch_group_create(); dispatch_queue_t queueA = dispatch_queue_create(&quot;queueA&quot;, nil); dispatch_queue_t queueB = dispatch_queue_create(&quot;queueB&quot;, nil); dispatch_group_async(group, queueA, ^&#123; [weakSelf getWithArray:weakSelf.array]; NSLog(@&quot;%@线程A&quot;,weakSelf.array); &#125;); dispatch_group_async(group, queueB, ^&#123; [weakSelf getWithArray:weakSelf.array]; NSLog(@&quot;%@线程B&quot;,weakSelf.array); &#125;); NSLog(@&quot;%@主线程&quot;,weakSelf.array);&#125;- (void)getWithArray:(NSMutableArray *)array &#123; [self.lock lock]; if (array.count &gt; 0) &#123; NSLog(@&quot;%@...objc&quot;,array.lastObject); [array removeLastObject]; &#125; [self.lock unlock];&#125; 不加锁的打印：可看出线程A和线程B同时操作了getWithArray:(NSMutableArray *)array，由于资源抢占，导致了数组越界而崩溃 12345678910111213142016-07-22 22:18:55.695827+0800 ThreadLock[10764:315922] 4444...objc2016-07-22 22:18:55.695827+0800 ThreadLock[10764:315923] 4444...objc2016-07-22 22:18:55.695892+0800 ThreadLock[10764:315824] ( 1111, 2222, 3333, 4444)主线程2016-07-22 22:18:55.696036+0800 ThreadLock[10764:315922] ( 1111, 2222, 3333)线程A2016-07-22 22:18:55.697056+0800 ThreadLock[10764:315923] *** Terminating app due to uncaught exception &apos;NSRangeException&apos;, reason: &apos;*** -[__NSArrayM removeObjectsInRange:]: range &#123;3, 1&#125; extends beyond bounds [0 .. 2]&apos; 加锁打印：加锁后，线程A先跑，跑的过程中由于线程加锁，线程B无法访问getWithArray:(NSMutableArray *)array，线程A结束之后，线程B发现array中只剩下3个元素，所以把最后一个元素3333给remove掉了，从而达到了线程运行的安全。 12345678910111213141516172016-07-22 22:10:40.114063+0800 ThreadLock[10425:305487] 4444...objc2016-07-22 22:10:40.113988+0800 ThreadLock[10425:305421] ( 1111, 2222, 3333, 4444)主线程2016-07-22 22:10:40.117108+0800 ThreadLock[10425:305487] ( 1111, 2222, 3333)线程A2016-07-22 22:10:40.117076+0800 ThreadLock[10425:305486] 3333...objc2016-07-22 22:10:40.117703+0800 ThreadLock[10425:305486] ( 1111, 2222)线程B @synchronized@synchronized在早期接触的iOS开发中经常接触，尤其是在创建单利模式的时候。 代码以及打印如下： 12345678- (void)getWithArray:(NSMutableArray *)array &#123; @synchronized (self) &#123; if (array.count &gt; 0) &#123; NSLog(@&quot;%@...objc&quot;,array.lastObject); [array removeLastObject]; &#125; &#125;&#125; 12345678910111213141516172016-07-22 22:20:33.083045+0800 ThreadLock[10837:317900] 4444...objc2016-07-22 22:20:33.083278+0800 ThreadLock[10837:317693] ( 1111, 2222, 3333, 4444)主线程2016-07-22 22:20:33.083437+0800 ThreadLock[10837:317900] ( 1111, 2222, 3333)线程A2016-07-22 22:20:33.083438+0800 ThreadLock[10837:317899] 3333...objc2016-07-22 22:20:33.083814+0800 ThreadLock[10837:317899] ( 1111, 2222)线程B 条件信号量dispatch_semaphore_t条件信号量详细用法见上一遍，GCD的用法 dispatch_barrier_async/dispatch_barrier_sync详细用法见上一遍，GCD的用法，但有一点值得注意的是： 如果在当前线程调用dispatch_barrier_sync阻塞线程会发生死锁 NSConditionNSCondition同样实现了NSLocking协议，所以它和NSLock一样，也有NSLocking协议的lock和unlock方法，可以当做NSLock来使用解决线程同步问题，用法完全一样。 12345678- (void)getWithArray:(NSMutableArray *)array &#123; [self.lock lock]; if (array.count &gt; 0) &#123; NSLog(@&quot;%@...objc&quot;,array.lastObject); [array removeLastObject]; &#125; [self.lock unlock];&#125; 同时，NSCondition提供更高级的用法。wait和signal，和条件信号量类似。 比如我们要监听imageNames数组的个数，当imageNames的个数大于0的时候就执行清空操作。思路是这样的，当imageNames个数大于0时执行清空操作，否则，wait等待执行清空操作。当imageNames个数增加的时候发生signal信号，让等待的线程唤醒继续执行。 NSCondition和NSLock、@synchronized等是不同的是，NSCondition可以给每个线程分别加锁，加锁后不影响其他线程进入临界区。这是非常强大。但是正是因为这种分别加锁的方式，NSCondition使用wait并使用加锁后并不能真正的解决资源的竞争。比如我们有个需求：不能让m&lt;0。假设当前m=0,线程A要判断到m&gt;0为假,执行等待；线程B执行了m=1操作，并唤醒线程A执行m-1操作的同时线程C判断到m&gt;0，因为他们在不同的线程锁里面，同样判断为真也执行了m-1，这个时候线程A和线程C都会执行m-1,但是m=1，结果就会造成m=-1. 当我用数组做删除试验时，做增删操作并不是每次都会出现，大概3-4次后会出现。单纯的使用lock、unlock是没有问题的。 条件锁NSConditionLock也有人说这是个互斥锁。NSConditionLock同样实现了NSLocking协议，试验过程中发现性能很低。 123456789- (void)getIamgeName:(NSMutableArray *)imageNames&#123; NSString *imageName; [lock lock]; if (imageNames.count&gt;0) &#123; imageName = [imageNames lastObject]; [imageNames removeObject:imageName]; &#125; [lock unlock];&#125; NSConditionLock也可以像NSCondition一样做多线程之间的任务等待调用，而且是线程安全的。 12345678910111213141516171819202122232425262728293031323334- (void)getIamgeName:(NSMutableArray *)imageNames&#123; NSString *imageName; [lock lockWhenCondition:1]; //加锁 if (imageNames.count&gt;0) &#123; imageName = [imageNames lastObject]; [imageNames removeObjectAtIndex:0]; &#125; [lock unlockWithCondition:0]; //解锁&#125;- (void)createImageName:(NSMutableArray *)imageNames&#123; [lock lockWhenCondition:0]; [imageNames addObject:@&quot;0&quot;]; [lock unlockWithCondition:1];&#125;#pragma mark - 多线程取出图片后删除- (void)getImageNameWithMultiThread&#123; NSMutableArray *imageNames = [[NSMutableArray alloc]init]; dispatch_group_t dispatchGroup = dispatch_group_create(); __block double then, now; then = CFAbsoluteTimeGetCurrent(); for (int i=0; i&lt;10000; i++) &#123; dispatch_group_async(dispatchGroup, self.synchronizationQueue, ^()&#123; [self getIamgeName:imageNames]; &#125;); dispatch_group_async(dispatchGroup, self.synchronizationQueue, ^()&#123; [self createImageName:imageNames]; &#125;); &#125; dispatch_group_notify(dispatchGroup, self.synchronizationQueue, ^()&#123; now = CFAbsoluteTimeGetCurrent(); printf(&quot;thread_lock: %f sec\nimageNames count: %ld\n&quot;, now-then,imageNames.count); &#125;);&#125; 递归锁NSRecursiveLock有时候“加锁代码”中存在递归调用，递归开始前加锁，递归调用开始后会重复执行此方法以至于反复执行加锁代码最终造成死锁，这个时候可以使用递归锁来解决。使用递归锁可以在一个线程中反复获取锁而不造成死锁，这个过程中会记录获取锁和释放锁的次数，只有最后两者平衡锁才被最终释放。 12345678910111213141516171819202122232425262728- (void)getIamgeName:(NSMutableArray *)imageNames&#123; NSString *imageName; [lock lock]; if (imageNames.count&gt;0) &#123; imageName = [imageNames firstObject]; [imageNames removeObjectAtIndex:0]; [self getIamgeName:imageNames]; &#125; [lock unlock];&#125;- (void)getImageNameWithMultiThread&#123; NSMutableArray *imageNames = [NSMutableArray new]; int count = 1024*10; for (int i=0; i&lt;count; i++) &#123; [imageNames addObject:[NSString stringWithFormat:@&quot;%d&quot;,i]]; &#125; dispatch_group_t dispatchGroup = dispatch_group_create(); __block double then, now; then = CFAbsoluteTimeGetCurrent(); dispatch_group_async(dispatchGroup, self.synchronizationQueue, ^()&#123; [self getIamgeName:imageNames]; &#125;); dispatch_group_notify(dispatchGroup, dispatch_get_main_queue(), ^()&#123; now = CFAbsoluteTimeGetCurrent(); printf(&quot;thread_lock: %f sec\nimageNames count: %ld\n&quot;, now-then,imageNames.count); &#125;);&#125; NSDistributedLockNSDistributedLock是MAC开发中的跨进程的分布式锁，底层是用文件系统实现的互斥锁。NSDistributedLock没有实现NSLocking协议，所以没有lock方法，取而代之的是非阻塞的tryLock方法。 12345678NSDistributedLock *lock = [[NSDistributedLock alloc] initWithPath:@&quot;/Users/mac/Desktop/lock.lock&quot;]; while (![lock tryLock]) &#123; sleep(1); &#125; //do something [lock unlock]; 当执行到do something时程序退出,程序再次启动之后tryLock就再也不能成功了,陷入死锁状态.其他应用也不能访问受保护的共享资源。在这种情况下，你可以使用breadLock方法来打破现存的锁以便你可以获取它。但是通常应该避免打破锁，除非你确定拥有进程已经死亡并不可能再释放该锁。 因为是MAC下的线程锁，所以demo里面没有，这里也不做过多关注。 互斥锁POSIXPOSIX和dispatch_semaphore_t很像，但是完全不同。POSIX是Unix/Linux平台上提供的一套条件互斥锁的API。 新建一个简单的POSIX互斥锁，引入头文件#import &lt;pthread.h&gt;声明并初始化一个pthread_mutex_t的结构。使用pthread_mutex_lock和pthread_mutex_unlock函数。调用pthread_mutex_destroy来释放该锁的数据结构。 123456789101112131415161718192021222324252627282930313233343536#import &lt;pthread.h&gt;@interface MYPOSIXViewController ()&#123; pthread_mutex_t mutex; //声明pthread_mutex_t的结构&#125;@end@implementation MYPOSIXViewController- (void)dealloc&#123; pthread_mutex_destroy(&amp;mutex); //释放该锁的数据结构&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. pthread_mutex_init(&amp;mutex, NULL); /** * 初始化 * */&#125;- (void)getIamgeName:(NSMutableArray *)imageNames&#123; NSString *imageName; /** * 加锁 */ pthread_mutex_lock(&amp;mutex); if (imageNames.count&gt;0) &#123; imageName = [imageNames firstObject]; [imageNames removeObjectAtIndex:0]; &#125; /** * 解锁 */ pthread_mutex_unlock(&amp;mutex);&#125; POSIX还可以创建条件锁，提供了和NSCondition一样的条件控制，初始化互斥锁同时使用pthread_cond_init来初始化条件数据结构， 1234567891011121314151617// 初始化 int pthread_cond_init (pthread_cond_t *cond, pthread_condattr_t *attr); // 等待（会阻塞） int pthread_cond_wait (pthread_cond_t *cond, pthread_mutex_t *mut); // 定时等待 int pthread_cond_timedwait (pthread_cond_t *cond, pthread_mutex_t *mut, const struct timespec *abstime); // 唤醒 int pthread_cond_signal (pthread_cond_t *cond); // 广播唤醒 int pthread_cond_broadcast (pthread_cond_t *cond); // 销毁 int pthread_cond_destroy (pthread_cond_t *cond); POSIX还提供了很多函数，有一套完整的API，包含Pthreads线程的创建控制等等，非常底层，可以手动处理线程的各个状态的转换即管理生命周期，甚至可以实现一套自己的多线程，感兴趣的可以继续深入了解。推荐一篇详细文章，但不是基于iOS的，是基于Linux的，但是介绍的非常详细 Linux 线程锁详解 自旋锁OSSpinLock首先要提的是OSSpinLock已经出现了BUG，导致并不能完全保证是线程安全的。 新版 iOS 中，系统维护了 5 个不同的线程优先级/QoS: background，utility，default，user-initiated，user-interactive。高优先级线程始终会在低优先级线程前执行，一个线程不会受到比它更低优先级线程的干扰。这种线程调度算法会产生潜在的优先级反转问题，从而破坏了 spin lock。 具体来说，如果一个低优先级的线程获得锁并访问共享资源，这时一个高优先级的线程也尝试获得这个锁，它会处于 spin lock 的忙等状态从而占用大量 CPU。此时低优先级线程无法与高优先级线程争夺 CPU 时间，从而导致任务迟迟完不成、无法释放 lock。这并不只是理论上的问题，libobjc 已经遇到了很多次这个问题了，于是苹果的工程师停用了 OSSpinLock。 苹果工程师 Greg Parker 提到，对于这个问题，一种解决方案是用 truly unbounded backoff 算法，这能避免 livelock 问题，但如果系统负载高时，它仍有可能将高优先级的线程阻塞数十秒之久；另一种方案是使用 handoff lock 算法，这也是 libobjc 目前正在使用的。锁的持有者会把线程 ID 保存到锁内部，锁的等待者会临时贡献出它的优先级来避免优先级反转的问题。理论上这种模式会在比较复杂的多锁条件下产生问题，但实践上目前还一切都好。 OSSpinLock 自旋锁，性能最高的锁。原理很简单，就是一直 do while 忙等。它的缺点是当等待时会消耗大量 CPU 资源，所以它不适用于较长时间的任务。对于内存缓存的存取来说，它非常合适。 -摘自ibireme 12345678910111213141516171819202122232425262728293031323334353637&lt;libkern/OSAtomic.h&gt;#import &lt;libkern/OSAtomic.h&gt;@interface MYOSSpinLockViewController ()&#123; OSSpinLock spinlock; //声明pthread_mutex_t的结构&#125;@end@implementation MYOSSpinLockViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. spinlock = OS_SPINLOCK_INIT; /** * 初始化 * */&#125;- (void)getIamgeName:(NSMutableArray *)imageNames&#123; NSString *imageName; /** * 加锁 */ OSSpinLockLock(&amp;spinlock); if (imageNames.count&gt;0) &#123; imageName = [imageNames firstObject]; [imageNames removeObjectAtIndex:0]; &#125; /** * 解锁 */ OSSpinLockUnlock(&amp;spinlock);&#125;@end 自旋锁os_unfair_lock由于OSSpinLock的线程安全问题，Apple已经在iOS10废弃了OSSpinLock自旋锁，取而代之的是os_unfair_lock，虽然os_unfair_lock是线程安全的，但代价就是os_unfair_lock的性能效果相对于OSSpinLock大打折扣 os_unfair_lock用法： 12345678910111213#import &lt;os/lock.h&gt;// 初始化 os_unfair_lock unfair_lock = OS_UNFAIR_LOCK_INIT;// 加锁os_unfair_lock_lock(&amp;unfair_lock);// 解锁os_unfair_lock_unlock(&amp;unfair_lock);// 尝试加锁，可以加锁则立即加锁并返回 YES,反之返回 NOos_unfair_lock_trylock(&amp;unfair_lock);/*注:解决不同优先级的线程申请锁的时候不会发生优先级反转问题.不过相对于 OSSpinLock , os_unfair_lock性能方面减弱了许多.*/ 总结@synchronized：适用线程不多，任务量不大的多线程加锁； NSLock：其实NSLock并没有想象中的那么差，不知道大家为什么不推荐使用； dispatch_semaphore_t：使用信号来做加锁，性能提升显著； NSCondition：使用其做多线程之间的通信调用不是线程安全的； NSConditionLock：单纯加锁性能非常低，比NSLock低很多，但是可以用来做多线程处理不同任务的通信调用； NSRecursiveLock：递归锁的性能出奇的高，但是只能作为递归使用,所以限制了使用场景； NSDistributedLock：因为是MAC开发的，就不讨论了； POSIX(pthread_mutex)：底层的api，复杂的多线程处理建议使用，并且可以封装自己的多线程； OSSpinLock：性能也非常高，可惜出现了线程问题； os_unfair_lock iOS10以后用于替代OSSpinLock的另外一种自旋锁，线程安全，性能相对于OSSpinLock大打折扣 dispatch_barrier_async/dispatch_barrier_sync：测试中发现dispatch_barrier_sync比dispatch_barrier_async性能要高，真是大出意外。]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>iOS线程锁</tag>
      </tags>
  </entry>
</search>
